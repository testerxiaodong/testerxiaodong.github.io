[{"content":"Emmet 语法 Emmet语法用于快速编写html标签与css样式\n快速生成 html 结构 生成网页骨架：html: 5 生成标签：输入标签名，按下tab键 生成多个相同标签：输入标签名*number，按下tab键 生成父子关系标签：输入标签名\u0026gt;标签名，按下tab键 生成兄弟关系标签：输入标签名+标签名，按下tab键 生成带类名的：输入标签名#classname或者标签名.classname，按下tab键 类名自增 快速生成 css 样式 通过单词缩写快速生成 css 样式属性值\nCSS 复合选择器 复合选择器可以更准确、高效定位元素\n通过两个或者多个``基础选择器组成\n复合选择器主要有以下几种：\n后代选择器 子选择器 并集选择器 伪类选择器 后代选择器 后代选择器选择的是父元素里的后代元素\n格式：标签1 标签2 ... 标签n { 样式声明 }\n既可以选择孩子，也可以选择孙子。\n选择器可以是任意基础选择器的组合\n.nav ol li\n子选择器 子选择器选择的是父元素里的子元素\n格式：父元素\u0026gt;子元素 { 样式声明 }\n并集选择器 并集选择器可以选择多组标签，为他们设定相同的样式\n格式：元素1, 元素2, ... 元素n { 样式声明 }\n伪类选择器 伪类选择器可以给某些选择器添加特殊效果(链接)，或者用于选择第1个或者第n个元素\n链接伪类选择器 链接伪类选择器种类：\na:link(未访问) a:visited(已访问) a:hover(鼠标经过) a:active(鼠标点击但未抬起) 注意事项：\n必须按照lvha顺序编写链接伪类选择器\nfocus 伪类选择器 focus伪类选择器用于选择获得焦点的表单元素\n格式：input:focus { 样式声明 }\nCSS 元素显示模式 块元素 常见的块元素有：h1-h6、p、div、ul、ol、li 等\n块元素`独占一行`` 可以对块元素的宽、高、内外间距进行设置 默认宽度为父元素的宽度 块元素内部可以放其他行内元素/块元素 文本块元素(p、h1-h6)内部不能放置块元素 行内元素 常见的行内元素有：a、文本格式化标签、span\n多个行内元素一行展示 不可以直接对行内元素进行宽、高设置 行内元素默认宽度为内容的宽度 行内元素内部可以放文本或其他行内元素 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;标签内部不能放置\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; 特殊情况\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;内部可以放块元素 行内块元素 常见的行内块元素有：img、input、td，同时具有行内元素和块元素的特点：\n多个一行展示 可以设置宽和高 默认宽度为内容宽度 显示模式转换 增加\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;链接触发范围\ndisplay: bolck; display: inline; display: inline-block; CSS 背景 CSS背景用于设置背景颜色、图片、平铺、图片位置、图片固定\n背景颜色 通过background-color设置\ntransparent(默认值) 和文本color一样 背景图片 通过background-image设置，小图片一般通过背景图片设置\n既可以设置背景图片，也可以设置背景颜色，背景图片会压住背景颜色\nnone url() 背景平铺 背景平铺就是背景图片重复展示，通过background-repeat设置\nno-repeat repeat(默认值) repeat-x repeat-y 背景位置 background-position: x y;属性可以改变背景图片的位置\n方位名词：background-position: left top;，可以省略一个参数，第二个参数居中 精准单位：background-position: x y; 混合单位：严格顺序，第一个为x，第二个为y 背景固定 background-attchment用于设置背景图片是随着页面滚动，还是随着页面固定\nscroll(默认值) fixed 背景复合写法 background: 背景颜色 背景图片 背景平铺 背景图片滚动 背景图片位置;\n背景颜色半透明 rgba(0, 0, 0, 0.3)，a 的取值范围为 0-1，越小越淡.\nCSS 三大特性 层叠性 继承性 优先级 层叠性 为了解决样式冲突，就近原则\n继承性 子标签继承父标签的某些样式：文本颜色和字号/(text-、font-、line-、color)\nline-height可以不设置单位，最终显示当前元素``文字大小的倍数：font: 12px/1.5 'Microsoft YaHei'\n优先级 当给同一个元素指定多个选择器名，就会有优先级产生\n选择器相同：执行层叠行 选择器不同：执行优先级 选择器 选择器权重 继承或者* 0,0,0,0 标签选择器 0,0,0,1 类选择器、伪类选择器 0,0,1,0 id 选择器 0,1,0,0 行内样式 1,0,0,0 !important +∞ 注意事项：\n权重计算有四位，但是不会进位 从左至右判断 权重叠加 ","date":"2024-04-02T18:04:46+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss%E4%B8%8B/","title":"【前端】CSS下"},{"content":"CSS 简介 HTML 局限性 用html修改网页外观代价太大\nCSS 的作用 CSS(Cascading style sheets)用于进行网页布局\n用于改变文字、图片、网页布局、外观\nCSS 语法规范 构成 选择器 + 一个或者多个声明：属性: 值;\n书写位置 内部样式表：\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;标签中，用\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt;标签声明 行内样式表：标签内部style属性，style=\u0026quot;key: value; key: value\u0026quot; 外部样式表(推荐)：\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;文件路径\u0026quot;\u0026gt; 规范 一般采用分散式：一行设置一个属性值 选择器与括号、属性 key/value 之间需要一个空格 CSS 选择器 选择器的作用 选出需求的标签\n选择器分类 基础选择器 标签选择器 id 选择器 class 选择器 通配符选择器 复合选择器 选择器使用方式 基础选择器 作用 特点 使用情况 用法 标签选择器 选出所有相同标签 不能差异化选择 较多 p {color: red;} 类选择器 选出一个或多个标签 可以根据需求选择 非常多 .nav {color: red;} id 选择器 一次只能选择一个标签 id 具有唯一性 一般和 js 搭配使用 #red {color: red;} 通配符选择器 选择所有标签 一般用于设置盒子间距 特殊情况使用 * {color: red;} class 多类名 一个标签可以使用多个类选择器定义的css 样式，多个类名之间使用空格分隔\n\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot; class=\u0026quot;red green\u0026quot;\u0026gt;百度一下，你就知道\u0026lt;/a\u0026gt;\n字体属性 CSS 字体属性用于定义字体系列、大小、粗细、文字样式\nfont-family font-family用于给字体设置系列\n多种字体之间使用逗号分隔，从左至右依次匹配\n有空格分开的多个单词组成的字体，使用单引号包裹\nfont-size/line-height font-size用于设置字体大小，必须使用单位px\nline-height用于设置行高\n文字垂直居中的技巧：line-height等于元素高度\n可以给\u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签设置整个 html 文档的字体大小\n标题标签应使用额外样式设置字体大小\nfont-weight font-weight用于给字体设置粗细，值可以设置以下几种：\nnormal(默认，400) bold(粗体，700) bolder(特粗体) lighter(细体) number(100-900)，不能跟单位 font-style font-style用于设置字体样式，有以下属性值：\nnormal italic(斜体) 复合属性 复合属性通过font属性设置\nfont: font-style font-weight font-size/line-height font-family\n必须严格按照顺序书写\nfont-size与font-family必须设置，其他可以省略\n文本属性 color color属性用于设置标签内字体颜色\n颜色有三种表示方式\n英语单词(red、green 等) #16 进制表示(用的最多) rgb 表示 text-align text-align用于设置文本对齐方式，有以下三种值：\ncenter left(默认值) right text-decoration text-decoration用于设置文本装饰，有以下四种值：\nnone underline overline line-through text-indent text-indent用于设置文本缩进，单位是 px/em，1em 等于一个文字大小\np {text-indent: 2em;}\n注意，只缩进首行\nline-height line-height用于设置文字行间距离\nline-height = font-size + 上间距 + 下间距，上下间距相等\n","date":"2024-04-01T18:40:44+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss/","title":"【前端】CSS"},{"content":"表格标签 表格的作用 表格标签用于展示数据\n\u0026lt;table\u0026gt;\u0026lt;/table\u0026gt;标签定义一个表格\n\u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;标签表示一行(table row)\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;标签表示一个单元格(table data)\n\u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;标签表示表头单元格(table header)，内容会加粗居中展示\n表格属性 align：对齐方式 border：边框 cellpadding：边缘与内容之间的距离(默认 1 像素) cellspacing：单元格之间的距离(默认 2 像素) width：表格宽度 表格标签结构 \u0026lt;table\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;thead\u0026gt;\u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; 合并单元格 合并单元格方式：\n跨行合并：rowspan=\u0026ldquo;个数\u0026rdquo; 跨列合并：colspan=\u0026ldquo;个数\u0026rdquo; 列表标签 列表的作用 列表标签用于布局\n列表分类 无序列表：\u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 有序列表：\u0026lt;ol\u0026gt;\u0026lt;/ol\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 自定义列表：\u0026lt;dl\u0026gt;\u0026lt;/dl\u0026gt;、\u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt;、\u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; 自定义列表用于对名词或者专业术语进行解释\n表单标签 表单的作用 表单标签用于收集用户信息\n表单组成 表单域：\u0026lt;form\u0026gt;\u0026lt;/form\u0026gt; 表单控件：表单元素 提示信息： 表单域属性 action：提交地址 method：提交方式(get/post) name: 表单域名称 input 表单元素 input 元素作用 input 元素用于收集用户信息\ninput 标签属性 type： button：按钮 cehckbox：复选框 file：文件选择 hidden：隐藏 image：图片 password：密码 text：文本 radio：单选框 reset 重置按钮 submit：提交按钮 name：name是表单的名字，单选框必须有相同的名字才可以实现多选一 value：表单的默认值，使用placeholder更好 checked：规定 input 元素首次加载时自动被选中 maxlength：输入字段中字符最大长度 label 标签 label 标签用于 input 聚焦\n通过label标签的for属性与input标签的id属性\n\u0026lt;lable for=\u0026quot;sex\u0026quot;\u0026gt;男\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; id=\u0026quot;sex\u0026quot;/\u0026gt;\nselect 下拉表单元素 下拉表单元素的作用 如果有多个选项提供用户选择，节约空间\n标签 1 2 3 4 5 \u0026lt;select\u0026gt; \u0026lt;option\u0026gt;选项1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选项2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选项3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 属性 option标签有一个selected=\u0026quot;selected\u0026quot;属性，表示默认选中\ntextarea 文本域元素 textarea 使用场景 当用户要输入的内容比较多时，不应使用text类型的input标签，而是应该使用textarea标签\n","date":"2024-04-01T14:36:49+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml%E6%A0%87%E7%AD%BE%E4%B8%8B/","title":"【前端】HTML标签下"},{"content":"浏览器内核 浏览器内核就是浏览器的渲染引擎，目前引擎分类：\n浏览器 内核 IE Trident firefox Gecko safari Webkit chrome/opera Blink Web 标准 W3C 主要包括：结构(HTML)、表现(CSS)、行为(JAVASCRIPT)三个部分。\nWEB 标准提出的最佳解决方案：结构、样式、行为相分离。\nHtml 语法规范 标签一般成对出现，也有单标签 标签之间的关系：包含/并列 Html 基本结构标签 \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt;标签 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;标签 \u0026lt;meta\u0026gt;标签 \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;标签 \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签 html 常用标签 标题标签 h1-h6 分别代表不同级别标题\n段落标签 \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;标签表示一个段落\n换行标签 \u0026lt;br/\u0026gt;标签表示换行\n空格 \u0026amp;nbsp;表示空格\n文本格式化标签 粗体：\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;或者\u0026lt;strong\u0026gt;\u0026lt;/strong\u0026gt; 倾斜：\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;或者\u0026lt;i\u0026gt;\u0026lt;/i\u0026gt; 删除线：\u0026lt;del\u0026gt;\u0026lt;/del\u0026gt;或者\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt; 下划线：\u0026lt;ins\u0026gt;\u0026lt;/ins\u0026gt;或者\u0026lt;u\u0026gt;\u0026lt;/u\u0026gt; 盒子标签 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;标签，独占一行 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;标签，多个在同一行展示 图像标签 \u0026lt;img/\u0026gt;标签表示一张图片，是一个单标签\n图像标签的属性：\nsrc：图片路径 title：图片标题，提示文本 alt：替换文本(图片展示不了时的文本) width：图片宽度 height：图片高度 border：图片边框 超链接标签 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;标签表示一个超链接\n超链接标签的属性：\nhref：链接的地址 target：以何种方式打开：_self(默认)、_blank 超链接的种类：\n外部链接：跳转到外部网站 内部链接：跳转到内部 html 页面 空链接：href=\u0026quot;#\u0026quot; 下载链接：地址链接的是文件 网页元素链接：为网页元素添加超链接：文本、图片、表格、音频、视频 锚点链接：href=\u0026quot;#id\u0026quot; 注释标签与特殊字符 \u0026lt;!-- 注释 --\u0026gt;进行注释\n特殊字符：\n空格：\u0026amp;nbsp; 大于：\u0026amp;gt; 小于：\u0026amp;lt; ","date":"2024-04-01T10:04:06+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml%E6%A0%87%E7%AD%BE/","title":"【前端】HTML标签"},{"content":"通过docker安装gitlab 安装gitlab，你起码需要一台2c4g的服务器，gitlab依赖很多很重的组件，我的环境是一台2c4g的虚拟机\n挂载三个目录：/etc/gitlab、/var/log/gitlab、/var/opt/gitlab\n映射三个端口：443/https、80/http、22/ssh\n443端口如果不用到证书不需要挂载\n1 2 3 4 5 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab \\ --restart always -v ~/data/gitlab/config:/etc/gitlab \\ -v ~/data/gitlab/logs:/var/log/gitlab \\ -v ~/data/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce 等待几分钟之后，通过网站访问gitlab，用户名为admin，密码挂载在/Users/cengdong/data/gitlab/config目录下\n修改gitlab配置 编辑挂载的配置目录：/Users/cengdong/data/gitlab/config/gitlab.rb\ngitlab的配置项非常多，只修改一项就能满足基本需求：external_url 'http://192.168.184.9'\n重启容器docker restart gitlab或者进入容器通过gitlab-ctl reconfigure命令使配置生效\n通过docker安装gitlab-runner gitlab-runner不建议与gitlab安装在同一台服务器上\n挂载容器运行时以及配置文件 1 2 3 4 docker run -d --name gitlab-runner --restart always \\ -v ~/data/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner 非交互式注册runner 有三种类型的runner：shared、group、specific\n全局类型runner所有人都能用，组类型runner只有组内人能用，特殊runner只有当前项目能用\n在不同地方的settings-\u0026gt;cicd中可以查看不同的token\nrunner有很多类型的执行器，常用的有shell、docker、k8s，通过--execuotr参数指定\n1 2 3 4 5 6 7 8 9 10 docker run --rm -v ~/data/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \\ --non-interactive\\ --executor \u0026#34;docker\u0026#34; \\ --docker-image alpine\u0026#34;latest \\ --url \u0026#34;http://192.168.184.9\u0026#34; \\ --registeration-token \u0026#34;your token\u0026#34; \\ --description \u0026#34;test \\ --tag-list \u0026#34;build\u0026#34; \\ --run-untagged=\u0026#34;true\u0026#34; \\ --locked=\u0026#34;false\u0026#34; 修改gitlab-runner配置 修改～/data/gitlab-runner/config/config.toml文件concurrent = 10\nconcurrent控制一个stage能最多同时执行多少个job，默认为1的情况下如果一个stage有多个job无法并发执行\n在[runners.docker]项下面添加pull_policy = if-not-present，否则每次都需要拉取镜像\n运行流水线 现在，你可以愉快的运行流水线了。通过创建或者导入项目，在项目的根目录下创建.gitlab-ci.yml文件\n通过pipeline语法控制流水线的流程\n","date":"2024-03-28T04:20:36+08:00","permalink":"https://www.cengdong.store/p/devopsgitlabci%E5%AE%9E%E8%B7%B5/","title":"【Devops】GitLabCI实践"},{"content":"1. 听力短句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 August is coming to an end. 八月就要结束了。 How old is this temple? 这座寺庙有多古老？ Please don\u0026#39;t call me after ten 请不要在十点以后给我打电话！ You are going to wait for a little bit. 你要稍微等一下。 The boy didn\u0026#39;t change his mind. 男孩没有改变他的想法。 I\u0026#39;m sorry, but I can\u0026#39;t accept such an expensive gift. 对不起，我不能接受这么贵重的礼物。 On Thursday we went to the poor. 周四，我们去了游泳池。 Monday Tuesday Wednesday Thursday Friday Saturday Sunday I\u0026#39;m talking to a friend. 我正在和朋友谈话。 Your plan is good, but my is better. 你的计划不错，但我的更好。 I fell into a trap. 我掉进了一个陷阱。 trap：陷阱 Cut the cake with this knife. 用这把刀切蛋糕。 knife：刀 It may sound strange, but it is true. 这听起来很奇怪，但他是真的。 He doesn\u0026#39;t know anything yet. 他还什么都不知道。 He is thinking about something else. 他在思考其他的事情。 The room is clean and comfortable. 房间整洁又舒适。 We\u0026#39;ll make our announcement on Thursday. 我们将在周四宣布。 announcement：宣布，声明 Have you chosen a name for the baby？ 你为孩子起好名字了吗？ chosen/choice：选择 Have you forgotten about your promise? 你忘记你的承诺了吗？promise：承诺 propose：求婚 Tom was blindfolded and taken out of the house. 汤姆被蒙上眼睛，带出了房子。 blind：失明 blindfold：被遮住 A short walk will bring you to the station. 走一小段路你就能到达车站。 2. 学到的知识点 生词： temple：寺庙 trap：陷阱 announcement: 宣布、声明 blindfold：被遮住 短语： fell into: 掉进 fell into love with：爱上某人 wait for a little bit：等一会儿 ","date":"2023-09-30T22:44:05+08:00","permalink":"https://www.cengdong.store/p/english%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0day1/","title":"【English】英语学习Day1"},{"content":"1. go-zero分布式锁实现 看下go-zero中redis分布式锁的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 var ( lockScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;PX\u0026#34;, ARGV[2]) return \u0026#34;OK\u0026#34; else return redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;NX\u0026#34;, \u0026#34;PX\u0026#34;, ARGV[2]) end`) delScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) else return 0 end`) ) 加锁和解锁的过程都是通过lua脚本实现的，因为lua脚本能够保证redis的原子性。\n2. 分布式锁必须拥有的属性 排他性(只能有一个协程持有) 可重入(已经获取锁的协程能再次访问) 防死锁(必须有超时时间，达到后持有者自动释放) 高性能高可用 3. go-zero分布式锁加锁流程 1 2 3 4 5 6 7 8 # 判断ARGV[1]是否等于KEY[1]的值 # 如果相等，说明是该锁的持有者重入，更新锁的过期时间，返回OK # 如果不想等，说明锁不存在或者该用户不是锁的持有者，用set nx px命令操作该key lockScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;PX\u0026#34;, ARGV[2]) return \u0026#34;OK\u0026#34; else return redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;NX\u0026#34;, \u0026#34;PX\u0026#34;, ARGV[2]) 4. go-zero分布式锁解锁流程 1 2 3 4 5 6 7 # 判断ARGV[1]是否等于KEY[1]的值 # 如果相等，说明是锁的拥有者，删除分布式锁的KEY # 如果不想等，说明不是锁的拥有者，返回0 delScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) else return 0 ","date":"2023-09-28T09:30:39+08:00","permalink":"https://www.cengdong.store/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","title":"【分布式锁】利用Redis实现分布式锁"},{"content":"1. 起因 最近在学习go-zero，用go-zero自带的sqlx+sqlc操作数据库。因为sqlx+sqlc不会像gorm一样自动管理软删除字段，所以对表结构进行重新的设计。 下面是新的表结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT \u0026#39;用户id\u0026#39;, `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT \u0026#39;用户名\u0026#39;, `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT \u0026#39;密码\u0026#39;, `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, `delete_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;删除时间\u0026#39;, `is_delete` tinyint unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;是否被删除\u0026#39;, `version` bigint unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;版本号\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `idx_username` (`username`,`is_delete`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=\u0026#39;用户记录\u0026#39;; 业务上需要username上这个唯一索引，同时当业务需要删除数据时只能软删除，方便数据溯源与恢复。\n2. 遇到的问题 当时只考虑到业务语义上username需要唯一索引，写完代码后用postman进行测试，插入一条数据，再删除这条数据。再插入一条相同用户名的数据时， 接口报错唯一索引冲突。参考go-zero微信群的建议，给软删除字段is_delete也加上唯一索引。插入一条数据，再删除这条数据。再插入一条相同用户名的数据， 再删除这条数据时，接口还是报错唯一索引冲突。\n3. 再加索引 群里立马又有大佬说还需要给删除时间加上唯一索引，因为删除时业务上会把删除时间更新为当前时间，不会有冲突。一顿操作下来，就给三个字段加上了唯一索引。 个人感觉这个索引还是有点大，又去网上找了不少相关博客。首先确定的是：\n有唯一索引需要的字段必须加上唯一索引，不能因为业务上有校验就删除该索引。 同时删除数据时应该使用软删除。 但是有一点可以优化，就是标记软删除的字段不必只是0和1，当删除数据时，更新该字段为该记录的主键值。 4. 又遇到问题 因为go-zero的数据库操作代码是靠代码生成的，会根据索引字段自动生成方法名，当有唯一索引需求是，自动生成的方法名会带上索引的所有字段，包括 软删除字段，方法名格外尴尬不说，内部生成的代码还多判断了一次is_delete = 0，请教了looklook项目作者，这种需要fork go-zero源代码再自己进行魔改。\n","date":"2023-09-28T08:37:51+08:00","permalink":"https://www.cengdong.store/p/mysql%E8%A7%A3%E5%86%B3%E8%BD%AF%E5%88%A0%E9%99%A4%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/","title":"【MySQL】解决软删除中的唯一索引问题"},{"content":"1. 需求 需要把mysql的数据聚合同步到es以提供海量数据检索能力\n2. 解决方案 变更mysql数据时同步调用es的api 变更mysql数据时异步调用es的api(先发送消息到消息队列，搜索微服务调用es的api消费数据) canal监听mysql的binlog日志，再同步到es flink-cdc监听mysql的binlog日志同步到es 3. 选用方案 最终选择flink-cdc的方案，一是go-canal的仓库不活跃，就三个issue，提了bug也没人修，而且后续可能有实时分析的大数据需求，本身就有flink集群的需求。 二是canal的release版本要最近才会更新，最后一次更新是21年4月，害怕烂尾。三是俺尝试部署canal，最后失败了💦。\n4. 部署环境 选用docker-compose部署mysql、link与elasticsearch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 version: \u0026#39;3\u0026#39; services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.17.13 container_name: elasticsearch user: root environment: - discovery.type=single-node - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; - TZ=Asia/Shanghai volumes: - ./data/elasticsearch/data:/usr/share/elasticsearch/data restart: always ports: - \u0026#34;9200:9200\u0026#34; - \u0026#34;9300:9300\u0026#34; networks: - douyin_net kibana: image: docker.elastic.co/kibana/kibana:7.17.13 container_name: kibana environment: - elasticsearch.hosts=http://elasticsearch:9200 - TZ=Asia/Shanghai restart: always networks: - douyin_net ports: - \u0026#34;5601:5601\u0026#34; depends_on: - elasticsearch mysql: image: mysql:latest container_name: mysql environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: my-secret-pw ports: - \u0026#34;3306:3306\u0026#34; volumes: # 数据挂载 - Data mounting - ./data/mysql/data:/var/lib/mysql - ./data/mysql/my.cnf:/etc/my.cnf privileged: true restart: always networks: - douyin_net jobmanager: image: flink:latest container_name: jobmanager expose: - \u0026#34;6123\u0026#34; ports: - \u0026#34;8081:8081\u0026#34; command: jobmanager environment: - TZ=Asia/Shanghai - JOB_MANAGER_RPC_ADDRESS=jobmanager restart: always networks: - douyin_net taskmanager: image: flink:latest container_name: taskmanager expose: - \u0026#34;6121\u0026#34; - \u0026#34;6122\u0026#34; depends_on: - jobmanager command: taskmanager environment: - JOB_MANAGER_RPC_ADDRESS=jobmanager - TZ=Asia/Shanghai restart: always networks: - douyin_net networks: douyin_net: driver: bridge ipam: config: - subnet: 172.16.0.0/16 其中mysql挂载的配置文件内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [mysqld] skip-host-cache skip-name-resolve datadir=/var/lib/mysql socket=/var/run/mysqld/mysqld.sock secure-file-priv=/var/lib/mysql-files user=mysql log-bin=mysql-bin binlog-format=ROW server_id=66 pid-file=/var/run/mysqld/mysqld.pid [client] socket=/var/run/mysqld/mysqld.sock !includedir /etc/mysql/conf.d/ 主要是为了开启binlog\n5. 配置 先启动集群\n1 docker-compose up -d 检查binlog是否开启\n1 2 3 docker exec mysql -uroot -pmy-secret-pw show variables like \u0026#39;log_bin\u0026#39;; show variables like \u0026#39;binlog_format\u0026#39;; 下载mysql、es的connector并拷贝到容器内部\nflink-sql-connector-elasticsearch7-3.0.1-1.17.jar flink-sql-connector-mysql-cdc-2.4.1.jar 1 2 3 docker cp ./flink-sql-connector-elasticsearch7-3.0.1-1.17.jar jobmanager:/opt/flink/lib/ docker cp ./flink-sql-connector-mysql-cdc-2.4.1.jar jobmanager:/opt/flink/lib/ docker restart jobmanager 6. 测试 进入mysql容器/连接mysql创建mysql数据库表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE DATABASE mydb; USE mydb; CREATE TABLE orders ( order_id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, order_date DATETIME NOT NULL, customer_name VARCHAR(255) NOT NULL, price DECIMAL(10, 5) NOT NULL, product_id INTEGER NOT NULL, order_status BOOLEAN NOT NULL -- Whether order has been placed ) AUTO_INCREMENT = 10001; INSERT INTO orders VALUES (default, \u0026#39;2020-07-30 10:08:22\u0026#39;, \u0026#39;Jark\u0026#39;, 50.50, 102, false), (default, \u0026#39;2020-07-30 10:11:09\u0026#39;, \u0026#39;Sally\u0026#39;, 15.00, 105, false), (default, \u0026#39;2020-07-30 12:00:30\u0026#39;, \u0026#39;Edward\u0026#39;, 25.25, 106, false); 进入jobmanager容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 docker exec -it jobmanager /bin/bash cd bin \u0026amp;\u0026amp; ./sql-client.sh SET execution.checkpointing.interval = 3s; CREATE TABLE orders ( order_id INT, order_date TIMESTAMP(0), customer_name STRING, price DECIMAL(10, 5), product_id INT, order_status BOOLEAN, PRIMARY KEY (order_id) NOT ENFORCED ) WITH ( \u0026#39;connector\u0026#39; = \u0026#39;mysql-cdc\u0026#39;, \u0026#39;hostname\u0026#39; = \u0026#39;192.168.2.248\u0026#39;, \u0026#39;port\u0026#39; = \u0026#39;3306\u0026#39;, \u0026#39;username\u0026#39; = \u0026#39;root\u0026#39;, \u0026#39;password\u0026#39; = \u0026#39;my-secret-pw\u0026#39;, \u0026#39;database-name\u0026#39; = \u0026#39;mydb\u0026#39;, \u0026#39;table-name\u0026#39; = \u0026#39;orders\u0026#39; ); CREATE TABLE es_orders ( order_id INT, order_date TIMESTAMP(0), customer_name STRING, price DECIMAL(10, 5), product_id INT, order_status BOOLEAN, PRIMARY KEY (order_id) NOT ENFORCED ) WITH ( \u0026#39;connector\u0026#39; = \u0026#39;elasticsearch-7\u0026#39;, \u0026#39;hosts\u0026#39; = \u0026#39;http://192.168.2.248:9200\u0026#39;, \u0026#39;index\u0026#39; = \u0026#39;orders\u0026#39; ); INSERT INTO es_orders SELECT * FROM orders; 访问kibana查询es数据\n1 2 3 4 5 6 GET orders/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;: {} } } ","date":"2023-09-20T22:34:29+08:00","permalink":"https://www.cengdong.store/p/flink%E5%88%A9%E7%94%A8flink-cdc%E5%90%8C%E6%AD%A5mysql%E6%95%B0%E6%8D%AE%E5%88%B0es/","title":"【Flink】利用flink Cdc同步mysql数据到es"},{"content":"1. 遇到的问题：上传文件到阿里云Oss失败，通过日志定位到是Linux系统时间不正确 2. 解决方案 1 2 3 4 5 timedatectl set-timezone Asia/Shanghai sudo yum -y install ntp ntpdate pool.ntp.org systemctl start ntpd systemctl enable ntpd ","date":"2023-09-15T02:58:36+08:00","permalink":"https://www.cengdong.store/p/linuxcentos7%E8%A7%A3%E5%86%B3%E6%97%B6%E9%97%B4%E4%B8%8D%E6%AD%A3%E7%A1%AE%E9%97%AE%E9%A2%98/","title":"【Linux】Centos7解决时间不正确问题"},{"content":"1. 环境准备 M1 Mac Vmware Fusion Tech Preview 终端连接工具Termius Centos7虚拟机三台，内存都为4G，磁盘30G，线程数为4 master: 192.168.2.3 node-1: 192.168.2.4 node-2: 192.168.2.5 2. 修改主机名 在三台节点上都执行\n1 2 3 4 5 cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF 192.168.2.3 master 192.168.2.4 node-1 192.168.2.5 node-2 EOF 1 2 3 4 5 6 # master上执行 hostnamectl set-hostname master # node-1上执行 hostnamectl set-hostname node-1 # node-2上执行 hostnamectl set-hostname node-2 3. 关闭selinux、swap 1 2 3 4 5 6 swapoff -a sed -i \u0026#39;s/enforcing/disabled/\u0026#39; /etc/selinux/config setenforce 0 echo \u0026#34;net.bridge.bridge-nf-call-iptables = 1 \u0026#34;\u0026gt;\u0026gt;/etc/sysctl.d/k8s.conf echo \u0026#34;net.bridge.bridge-nf-call-ip6tables = 1 \u0026#34;\u0026gt;\u0026gt;/etc/sysctl.d/k8s.conf sysctl --system 4. ipvs安装 1 2 3 4 modprobe br_netfilter echo 1 \u0026gt; /proc/sys/net/bridge/bridge-nf-call-iptables echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward lsmod | grep br_netfilter 1 yum -y install ipset ipvsadm 1 2 3 4 5 6 7 cat \u0026gt; /etc/sysconfig/modules/ipvs.modules \u0026lt;\u0026lt;EOF modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack EOF 1 chmod a+x /etc/sysconfig/modules/ipvs.modules 执行脚本 /etc/sysconfig/modules/ipvs.modules\n验证ipvs模块 lsmod | grep -e ip_vs -e nf_conntrack_ipv4\n1 2 3 4 5 # 执行脚本 /etc/sysconfig/modules/ipvs.modules # 验证ipvs模块 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 1 2 3 4 cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/modules-load.d/containerd.conf overlay br_netfilter EOF 1 2 modprobe overlay modprobe br_netfilter 5. 安装docker 1 2 3 4 5 6 7 yum install -y yum-utils yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo yum install docker-ce-19.03.5 docker-ce-cli-19.03.5 systemctl enable docker systemctl start docker 配置docker\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/docker/daemon.json { \u0026#34;insecure-registries\u0026#34;:[\u0026#34;47.99.140.12:8077\u0026#34;], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://l10nt4hq.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; ] } EOF #重新加载服务的配置文件 systemctl daemon-reload #重启docker systemctl restart docker systemctl status docker.service 6. 配置k8s源 1 2 3 4 5 6 7 8 9 10 11 12 13 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-aarch64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF yum clean all yum makecache 7. 安装kubeadm、kubectl、kubelet 1 2 3 4 5 yum install -y kubeadm-1.23.3-0 kubectl-1.23.3-0 kubelet-1.23.3-0 --disableexcludes=kubernetes # 只在master节点执行 systemctl enable kubelet systemctl start kubelet 8. master节点加入K8s集群 1 kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.23.3 --apiserver-advertise-address 192.168.2.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.1.0.0/16 9. master节点部署flannel网络 1 2 3 4 tar zxvf cni-plugins-linux-arm-v0.8.6.tgz cp flannel /opt/cni/bin chmod 777 /opt/cni/bin/flannel kubectl apply -f kube-flannel.yml 10. node节点加入k8s集群 1 2 kubeadm join 192.168.2.2:6443 --token uxohvw.84c30cwr4g6t8he8 \\ --discovery-token-ca-cert-hash sha256:cc7e139e28e61db426dc91a3ecccc0a72f26b09af6dfd12c6171d58f4359c0e5 token失效后重新生成\n1 2 3 4 5 kubeadm token create # master 执行 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u0026gt;/dev/null | openssl dgst -sha256 -hex | sed \u0026#39;s/^.* //\u0026#39; 11. node节点加入flannel网络 1 2 3 4 5 6 7 8 # 子节点上创建文件夹 mkdir -p /etc/cni/net.d # master节点拷贝文件到node节点 scp /etc/cni/net.d/10-flannel.conflist root@192.168.2.3:/etc/cni/net.d systemctl daemon-reload systemctl restart kubelet ","date":"2023-08-28T19:51:03+08:00","permalink":"https://www.cengdong.store/p/kubernetesarm%E6%9E%B6%E6%9E%84centos7%E9%80%9A%E8%BF%87kubeadm%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/","title":"【Kubernetes】arm架构Centos7通过kubeadm安装k8s集群"},{"content":"1. 起因 最近在学习go-zero框架，把faker-douyin项目重构成微服务项目。在重构的过程中有一些变动：\n原来使用本地虚拟机构建服务中间件依赖，现在使用阿里云的服务 原来上传视频时直接通过ftp上传到虚拟机，现在直接上传到阿里云oss 在代码上传github上之后，阿里云发现我的accessKey在github上泄漏（主要是我安全意识不好）\n2. 解决办法 使用.gitignore文件使git忽视配置文件上传 在.gitignore文件中添加.yaml忽视所有yaml类型文件 3. 遇到问题 更改.gitignore文件之后，本地仓库没有生效（没有删除gitignore文件匹配的文件）\n4. 解决办法 1 2 3 4 git rm --cached -r . git add . git commit -am \u0026#39;注释\u0026#39; git push ","date":"2023-08-12T15:00:13+08:00","permalink":"https://www.cengdong.store/p/git%E6%B7%BB%E5%8A%A0gitignore%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E5%88%A0%E9%99%A4github%E4%B8%8A%E5%A4%9A%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6/","title":"【Git】添加gitignore文件之后删除github上多上传的文件"},{"content":"1. 介绍 RabbitMQ is the most widely deployed open source message broker.\n直接把RabbitMQ官网的介绍抄过来：它是部署最广泛的消息代理\n2. 作用 消息代理中间件的作用：\n削峰：大量请求写入消息中间件，服务器按照自己能力去消费 解耦：服务上游与下游解耦，上游只需把请求写入消息代理，下游只需要去消息中间件消费 异步：实时性不高的功能放入代理，快速响应客户端请求 3. 竞品 ActiveMQ(已经寄了) RocketMQ（阿里开源，广泛应用在电商场景） Kafka（大数据利器，日志系统重要组件） 4. 系统架构 生产者：消息发送方 channel：通信信道，一个连接里有多个可用信道（感觉是资源池），生产者和消费者都会与broker建立连接 exchange：交换机，生产者将消息发送给对应交换机（生产者只与交换机打交道），交换机通过routingKey将消息发送给消息队列 queue：消息队列，存放消息的实体 消费者：从消息队列中消费消息 虚拟主机：多租户的资源隔离（不想深入，也不做过多了解） 5. 工作模式 RabbitMQ官方给出了七种工作模式\nHello World Work Queues Publish/Subscribe Routing Topics RPC Publisher confirms 6. 安装RabbitMQ 我的虚拟机已经安装好Docker，通过Docker安装带web可视化插件的RabbitMQ，其中5672是服务端的端口，15672是web可视化的端口\n1 docker run --name rabbit --restart=always -p 15672:15672 -p 5672:5672 -d rabbitmq:management 访问web管理界面，用户名密码都是guest\n7. 创建项目 创建目录：mkdir rabbitmq-demo 初始化项目：go mod init rabbitmq-demo go客户端选用：老规矩，最多star的项目，虽然已经停止维护很久了github.com/streadway/amqp 8. 发送消息：以简单模式为例 简单模式就是点对点的消息传输模型，官网称之为Hello World模式。生产者发送消息给指定队列，消费者从指定队列消费消息，其中生产者以及消费者都绑定的是默认交换机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; ) const url = \u0026#34;amqp://guest:guest@192.168.18.3:5672/\u0026#34; func main() { // 连接服务器 conn, err := amqp.Dial(url) if err != nil { fmt.Println(err) } defer conn.Close() // 获取channel channel, err := conn.Channel() defer channel.Close() if err != nil { fmt.Println(err) } // 声明队列 queue, err := channel.QueueDeclare(\u0026#34;test\u0026#34;, false, false, false, false, nil) if err != nil { fmt.Println(err) } // 发布消息 err = channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(\u0026#34;hello world\u0026#34;)}) if err != nil { fmt.Println(err) } } 9. 接受消息：以简单模式为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; ) const rabbit_url = \u0026#34;amqp://guest:guest@192.168.18.3:5672/\u0026#34; func main() { // 链接服务器 conn, err := amqp.Dial(rabbit_url) if err != nil { fmt.Println(err) } defer conn.Close() // 建立链接 channel, err := conn.Channel() if err != nil { fmt.Println(err) } defer channel.Close() // 声明队列 queue, err := channel.QueueDeclare(\u0026#34;test\u0026#34;, false, false, false, false, nil) if err != nil { fmt.Println(err) } // 消费消息 msg, err := channel.Consume(queue.Name, \u0026#34;\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } // 遍历管道，读取消息 for d := range msg { fmt.Println(string(d.Body)) } } 10. 如何保障消息不丢失 10.1 消息应答机制 RabbitMQ有两种消息应答机制：自动应答和手动应答，自动应答即NOACK，不需要接收方回应ACK消息，默认是这种应答方式。要开启手动应答，首先要把channel.Consume方法的第三个参数设置为false\n1 func (ch *Channel) Consume(queue, consumer string, autoAck, exclusive, noLocal, noWait bool, args Table) (\u0026lt;-chan Delivery, error) 还需要在消费消息时调用Ack或Reject或Nack方法\n1 func (d Delivery) Ack(multiple bool) error 10.2 消息持久化 要保障消息不丢失，就要保障消息的持久化，避免服务器故障或重启时内存中的消息丢失。消息持久化分为两部分：队列持久化、消息持久化。\n队列持久化需要在声明队列时把参数durable传为true\n1 func (ch *Channel) QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args Table) (Queue, error) 消息持久化需要在实例化消息时把Publishing结构体的DeliveryMode字段设置为Persistent\n1 2 3 4 5 6 channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ DeliveryMode: amqp.Persistent, ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(\u0026#34;hello world\u0026#34;), } ) 10.3 生产方发布确认 生产方发布确认又叫发布确认模式，是一种保障生产方能确认发布消息到Broker的机制\n要开启发布确认模式需要调用channel.Conform方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Confirm puts this channel into confirm mode so that the client can ensure all publishings have successfully been received by the server. After entering this mode, the server will send a basic.ack or basic.nack message with the deliver tag set to a 1 based incremental index corresponding to every publishing received after the this method returns. Add a listener to Channel.NotifyPublish to respond to the Confirmations. If Channel.NotifyPublish is not called, the Confirmations will be silently ignored. The order of acknowledgments is not bound to the order of deliveries. Ack and Nack confirmations will arrive at some point in the future. Unroutable mandatory or immediate messages are acknowledged immediately after any Channel.NotifyReturn listeners have been notified. Other messages are acknowledged when all queues that should have the message routed to them have either received acknowledgment of delivery or have enqueued the message, persisting the message if necessary. When noWait is true, the client will not wait for a response. A channel exception could occur if the server does not support this method. */ func (ch *Channel) Confirm(noWait bool) error { if err := ch.call( \u0026amp;confirmSelect{Nowait: noWait}, \u0026amp;confirmSelectOk{}, ); err != nil { return err } ch.confirmM.Lock() ch.confirming = true ch.confirmM.Unlock() return nil } 再调用NotifyPublish方法或NotifyConfirm注册发布消息的回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* NotifyConfirm calls NotifyPublish and starts a goroutine sending ordered Ack and Nack DeliveryTag to the respective channels. For strict ordering, use NotifyPublish instead. */ func (ch *Channel) NotifyConfirm(ack, nack chan uint64) (chan uint64, chan uint64) { confirms := ch.NotifyPublish(make(chan Confirmation, cap(ack)+cap(nack))) go func() { for c := range confirms { if c.Ack { ack \u0026lt;- c.DeliveryTag } else { nack \u0026lt;- c.DeliveryTag } } close(ack) if nack != ack { close(nack) } }() return ack, nack } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* NotifyPublish registers a listener for reliable publishing. Receives from this chan for every publish after Channel.Confirm will be in order starting with DeliveryTag 1. There will be one and only one Confirmation Publishing starting with the delivery tag of 1 and progressing sequentially until the total number of Publishings have been seen by the server. Acknowledgments will be received in the order of delivery from the NotifyPublish channels even if the server acknowledges them out of order. The listener chan will be closed when the Channel is closed. The capacity of the chan Confirmation must be at least as large as the number of outstanding publishings. Not having enough buffered chans will create a deadlock if you attempt to perform other operations on the Connection or Channel while confirms are in-flight. It\u0026#39;s advisable to wait for all Confirmations to arrive before calling Channel.Close() or Connection.Close(). */ func (ch *Channel) NotifyPublish(confirm chan Confirmation) chan Confirmation { ch.notifyM.Lock() defer ch.notifyM.Unlock() if ch.noNotify { close(confirm) } else { ch.confirms.Listen(confirm) } return confirm } 11. 工作队列模式 11.1 公平调度的工作队列模式 工作队列模式类似于Kafka的消费者组，为了提高消费者的消费能力。生产者代码与简单模式一致，为了能从命令行控制要发送的消息，做一些改造。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) const url = \u0026#34;amqp://guest:guest@47.99.140.12:5672/\u0026#34; func main() { connection, err := amqp.Dial(url) if err != nil { fmt.Println(err) } defer connection.Close() channel, err := connection.Channel() if err != nil { fmt.Println(err) } defer channel.Close() queue, err := channel.QueueDeclare(\u0026#34;work_queues\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } body := bodyFrom(os.Args) err = channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ ContentType: \u0026#34;text/plain\u0026#34;, DeliveryMode: amqp.Persistent, Body: []byte(body), }) if err != nil { fmt.Println(err) } fmt.Printf(\u0026#34;send msg %s\u0026#34;, body) } func bodyFrom(args []string) string { var s string if len(args) \u0026lt; 2 || os.Args[1] == \u0026#34;\u0026#34; { s = \u0026#34;hello\u0026#34; } else { s = strings.Join(args[1:], \u0026#34; \u0026#34;) } return s } 消费者代码也与简单模式一致，为了能从多个消费者区分差异，对消息做了一些虚假的业务处理（按照消息中字符.的个数睡眠相应秒数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; \u0026#34;time\u0026#34; ) const rabbit_url = \u0026#34;amqp://guest:guest@47.99.140.12:5672/\u0026#34; func main() { connection, err := amqp.Dial(rabbit_url) if err != nil { fmt.Println(err) } defer connection.Close() channel, err := connection.Channel() if err != nil { fmt.Println(err) } defer channel.Close() queue, err := channel.QueueDeclare(\u0026#34;work_queues\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } deliveries, err := channel.Consume(queue.Name, \u0026#34;\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } for delivery := range deliveries { fmt.Printf(\u0026#34;receive work: %s\\n\u0026#34;, delivery.Body) dotCount := bytes.Count(delivery.Body, []byte(\u0026#34;.\u0026#34;)) d := time.Duration(dotCount) time.Sleep(d * time.Second) fmt.Printf(\u0026#34;work done after %d\\n\u0026#34;, d) } } 先分别在两个终端中启动两个消费者\n1 go run receive.go 再启动生产者发送多条消息\n1 2 3 4 5 go run send.go First Message. go run send.go Second Message.. go run send.go Third Message... go run send.go Fourth message.... go run send.go Fifth message..... 生产者 消费者1 消费者2 消费者1消费了消息135，消费者2消费了消息24，这样提高了消费者消费的能力，并且由于工作队列模式默认的消息分发机制是轮询，官网称之为Fair dispatch(公平调度)\n当有多个消费者时，每个消费者的消费能力不一样，轮询的方式会有问题。\n11.2 设置预取值的工作队列方式 为了解决公平调度带来的问题，我们可以将预取计数设置为值1。这告诉RabbitMQ不要一次向一个worker提供多条消息。\n或者，换句话说，在worker处理并确认前一条消息之前，不要向worker发送新消息。相反，它会将其调度给下一个尚未繁忙的工作人员。\n设置预取值需要调用channel.Qos方法\n1 2 3 4 5 6 7 8 9 10 11 # 通常设置 prefetchCount = 1 prefetchSize = 0 global = false func (ch *Channel) Qos(prefetchCount, prefetchSize int, global bool) error { return ch.call( \u0026amp;basicQos{ PrefetchCount: uint16(prefetchCount), PrefetchSize: uint32(prefetchSize), Global: global, }, \u0026amp;basicQosOk{}, ) } ","date":"2023-07-31T00:02:07+08:00","permalink":"https://www.cengdong.store/p/gorabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"【Go】RabbitMQ学习笔记"}]