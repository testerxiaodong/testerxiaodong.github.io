[{"content":"运算符 赋值运算符 赋值运算符用于简化变量自身的算数运算\n=：普通赋值 +=：算数赋值 -= *= /= %= 自增运算符 自增运算符常用于计数\n++number：前置自增 number++：后置自增 --number：前置自减 number--：后置自减 前置自增和后置自增的区别：前置自增先自增再参与运算，后置自增先参与运算再自增\n比较运算符 \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= !==：左右两边是否不全等 ==：左右两边值是否相等 ===：左右两边值和类型是否都相等 注意事项：\n字符串比较，比较的是 ASCII 码，从左至右依次比较 NaN 不等于任何值，包括它本身 尽量不要比较小数，有精度问题 逻辑运算符 \u0026amp;\u0026amp; || ! 运算符优先级 小括号 一元运算符 算数运算符：先*/后+- 关系运算符 相等运算符 逻辑运算符：先\u0026amp;\u0026amp;后|| 赋值运算符 逗号运算符 语句 表达式和语句 表达式是可以被求值的代码\n语句是一段可以执行的代码，不一定有值\nif 语句 if 单分支语句 1 2 3 4 let age = Number(prompt(\u0026#39;请输入您的年龄‘)) if (age \u0026gt; 18) { console.log(\u0026#39;成年人\u0026#39;) } 括号内为 true 时，执行大括号内代码 小括号内不是 boolean 类型数据时，会发生隐式转换 大括号只有一条语句时，可以省略大括号，但是不提倡 if 双分支语句 1 2 3 4 5 6 let age = Number(prompt(\u0026#34;请输入您的年龄\u0026#34;)); if (age \u0026gt; 18) { console.log(\u0026#34;成年人\u0026#34;); } else { console.log(\u0026#34;少年人\u0026#34;); } if 三分支语句 1 2 3 4 5 6 7 8 let score = Number(prompt(\u0026#39;请输入您的成绩\u0026#39;); if (score \u0026gt; 90) { console.log(\u0026#39;优秀\u0026#39;); } else if (score \u0026gt; 80) { console.log(\u0026#39;良好\u0026#39;); } else { console.log(\u0026#39;一般\u0026#39;); } 三元运算符 比 if 双分支更简单的写法\n?与:结合\n条件 ? 满足条件执行的代码 : 不满足条件执行的代码\n1 2 3 4 let a = 1; let b = 2; // 三目运算符 a \u0026gt; b ? a : b; switch 语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let number = +prompt(\u0026#34;请输入一个1-7数字\u0026#34;); switch (number) { case 1: console.log(\u0026#34;星期一\u0026#34;); break; case 2: console.log(\u0026#34;星期二\u0026#34;); break; case 3: console.log(\u0026#34;星期三\u0026#34;); break; case 4: console.log(\u0026#34;星期四\u0026#34;); break; case 5: console.log(\u0026#34;星期五\u0026#34;); break; case 6: console.log(\u0026#34;星期六\u0026#34;); break; case 7: console.log(\u0026#34;星期七\u0026#34;); break; default: console.log(\u0026#34;输入有误\u0026#34;); } 表达式的值必须与 case 语句后的值全等 case 语句后应该加上 break 语句，否则会穿透 应该加上 default 语句，没有匹配的值时，执行该语句 断点调试 打开开发者工具 添加断点 刷新浏览器 while 循环语句 1 2 3 4 5 let n = 0; while (n \u0026lt; 5) { console.log(n); n++; } 退出循环 break 退出整个循环 continue 跳过本次循环，继续下一个循环 for 循环语句 相比于 while 循环，for 循环把起始量，循环条件，循环量自增放在一起，更加清晰。\n1 2 3 for (var i = 0; i \u0026lt; 10; i++) { console.log(i); } 遍历数组\n1 2 3 4 let arr = [1, 2, 3, 4, 5]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } 退出 for 循环 break continue 循环嵌套 1 2 3 4 5 6 7 8 // 外层循环，控制行数 for (let i = 0; i \u0026lt; 10; i++) { // 内层循环，控制列数 for (let j = 0; j \u0026lt;= i; j++) { document.write(`${i} * ${j} = ${i * j}`); } document.write(`\u0026lt;/br\u0026gt;`); } ","date":"2024-04-21T02:18:42+08:00","permalink":"https://www.cengdong.store/p/javascriptjavascript%E5%9F%BA%E7%A1%80%E4%BA%8C/","title":"【JavaScript】JavaScript基础二"},{"content":"rem 基础 rem 的优点 文字能随着屏幕大小发生变化 元素高度和宽度都能随着屏幕大小发生变化 rem 单位 rem(root em)是一个相对单位，类似于em，em 是父元素字体大小。 rem的基准是相对于 html 元素的字体大小。 父元素文字大小可能不一致， 但是整个页面只有一个 html，可以很好来控制整个页面的元素大小 媒体查询 什么是媒体查询 媒体查询（Media Query）是 CSS3 新语法 使用 @media 查询，可以针对不同的媒体类型定义不同的样式 媒体查询语法 1 2 3 @media mediatype and|not|only (media feature) { CSS-Code; } 用 @media 开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性 必须有小括号包含 mediatype 查询类型 值 解释说明 all 用于所有设备 print 用于打印机和打印预览 scree 用于电脑屏幕，平板电脑，智能手机等 关键字 and：可以将多个媒体特性连接到一起，相当于“且”的意思。 not：排除某个媒体类型，相当于“非”的意思，可以省略。 only：指定某个特定的媒体类型，可以省略。 媒体特性 值 解释说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域宽度 max-width 定义输出设备中页面最大可见区域宽度 从小到大来写，这样代码更简洁\n引入资源 语法规范：\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;mediatype and|not|only (media feature)\u0026#34; href=\u0026#34;mystylesheet.css\u0026#34;\u0026gt; less 基础 css 弊端 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。 不方便维护及扩展，不利于复用。 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 less 介绍 中文官网\nLess （Leaner Style Sheets 的缩写） 是一门 CSS 扩展语言，也成为 CSS 预处理器 它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写 常见的 CSS 预处理器：Sass、Less、Stylus less 安装 安装 nodejs，可选择版本(8.0)，网址：http://nodejs.cn/download/ 检查是否安装成功，使用 cmd 命令（win10 是 window +r 打开 运行输入 cmd） \u0026mdash; 输入“ node –v ”查看版本即可 基于 nodejs 在线安装 Less，使用 cmd 命令“ npm install -g less ”即可 检查是否安装成功，使用 cmd 命令“ lessc -v ”查看版本即可 less 语法 less 语法包括以下几个方面：\nLess 变量 Less 编译 Less 嵌套 Less 运算 less 变量 变量是指没有固定的值，可以改变的。因为我们 CSS 中的一些颜色和数值等经常使用。\n语法规范：\n1 @color: pink; 使用变量：\n1 2 3 4 5 6 7 //直接使用 body { color: @color; } a:hover { color: @color; } 变量命名规范：\n必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 less 编译 vocode Less 插件: easy less\n保存 less 文件，自动生成 css 文件\nless 嵌套 1 2 3 4 5 #header { .logo { width: 300px; } } 如果遇到：交集|伪类|伪元素选择器\n内层选择器的前面没有 \u0026amp; 符号，则它被解析为父选择器的后代； 如果有 \u0026amp; 符号，它就被解析为父元素自身或父元素的伪类。 less 运算 任何数字、颜色或者变量都可以参与运算。就是 Less 提供了加（+）、减（-）、乘（*）、除（/）算术运算。\n1 2 3 4 5 6 7 8 9 10 11 /*Less 里面写*/ @witdh: 10px + 5; div { border: @witdh solid red; } /*生成的css*/ div { border: 15px solid red; } /*Less 甚至还可以这样 */ width: (@width + 5) * 2; 注意事项：\n乘号（*）和除号（/）的写法 运算符中间左右有个空格隔开 1px + 5 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位 rem 适配方案 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。 rem 实际开发适配方案 按照设计稿与设备宽度的比例，动态计算并设置 html 根标签的 font-size 大小；（媒体查询） CSS 中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为 rem 为单位的值； rem 适配方案技术使用（市场主流） 技术方案 1 less 媒体查询 rem 技术方案 2（推荐） flexible.js rem ","date":"2024-04-20T05:34:54+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFrem%E5%B8%83%E5%B1%80/","title":"【前端】rem布局"},{"content":"移动端基础 浏览器现状 兼容移动端主流浏览器，处理Webkit内核浏览器即可\n手机屏幕现状 移动端设备屏幕尺寸非常多，碎片化严重\n移动端调试技巧 Chrome DevTools（谷歌浏览器）的模拟手机调试 搭建本地 web 服务器，手机和服务器一个局域网内，通过手机访问服务器 视口 视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口\n布局视口 layout viewport 视觉视口 visual viewport 理想视口 ideal viewport 用理想视口布局 理想视口，对设备来讲，是最理想的视口尺寸\nmeta 视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽\nmeta 视口标签 1 2 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; 属性 解释说明 width 宽度设置的是viewport宽度，可以设置device-width特殊值 initial-scale 初始缩放比，大于 0 的数字 maximum-scale 最大缩放比，大于 0 的数字 minimum-scale 最小缩放比，大于 0 的数字 user-scalable 用户是否可以缩放，yes 或 no（1 或 0） 标准的 viewport 设置：\n视口宽度和设备保持一致 视口的默认缩放比例 1.0 不允许用户自行缩放 最大允许的缩放比例 1.0 最小允许的缩放比例 1.0 二倍图 物理像素\u0026amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。\n我们开发时候的 1px不是一定等于1 个物理像素的\nPC 端页面，1 个 px 等于 1 个物理像素的，但是移动端就不尽相同\n一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比\n多倍图 对于一张图片,在手机屏中打开，物理像素比会放大倍数，这样会造成图片模糊\n在标准的 viewport 设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题\n通常使用二倍图，还存在3倍图4倍图的情况\n1 2 3 4 5 6 7 8 9 10 /* 在 iphone8 下面 */ img { /*原始图片100*100px*/ width: 50px; height: 50px; } .box { /*原始图片100*100px*/ background-size: 50px 50px; } 背景缩放 background-size background-size 属性规定背景图像的尺寸\n语法格式：background-size: 背景图片宽度 背景图片高度;\n注意事项：\n单位： 长度|百分比|cover|contain; cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容 二倍精灵图做法 在firework里面把精灵图等比例缩放为原来的一半 之后根据大小测量坐标 注意代码里面background-size也要写： 精灵图原来宽度的一半 移动端开发选择 移动端主流方案：\n单独制作移动端页面（主流） 响应式页面兼容移动端（其次） 单独移动端页面 通常情况下，网址域名前面加 m(mobile) 可以打开移动端。\n通过判断设备/user-agent，如果是移动设备打开，则跳到移动端页面。\n响应式兼容 PC 移动端 通过判断屏幕宽度来改变样式，以适应不同终端。\n制作麻烦，需要花很大精力去调兼容性问题\n移动端技术解决方案 移动端浏览器 移动端浏览器基本以webkit内核为主，因此我们就考虑webkit兼容性问题\nCSS 初始化 normalize.css 移动端 CSS 初始化推荐使用 normalize.css/\nNormalize.css：保护了有价值的默认值 Normalize.css：修复了浏览器的 bug Normalize.css：是模块化的 Normalize.css：拥有详细的文档 官网地址\nCSS3 盒子模型 box-sizing 传统模式宽度计算：盒子的宽度 = CSS 中设置的 width + border + padding CSS3 盒子模型： 盒子的宽度 = CSS 中设置的宽度 width 里面包含了 border 和 padding 特殊样式 1 2 3 4 5 6 7 8 9 10 11 12 /*CSS3盒子模型*/ box-sizing: border-box; -webkit-box-sizing: border-box; /*点击高亮我们需要清除清除 设置为transparent 完成透明*/ -webkit-tap-highlight-color: transparent; /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/ -webkit-appearance: none; /*禁用长按页面时的弹出菜单*/ img, a { -webkit-touch-callout: none; } 移动端常见布局 流式布局 flex 布局 rem 布局 流式布局（百分比布局） 流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 流式布局方式是移动 web 开发使用的比较常见的布局方式。 max-width 最大宽度 （max-height 最大高度） min-width 最小宽度 （min-height 最小高度） flex 布局 传统布局\u0026amp;flex 布局 传统布局：\n兼容性好 布局繁琐 局限性，不能再移动端很好的布局 flex 弹性布局：\n操作方便，布局极为简单，移动端应用很广泛 PC 端浏览器支持情况较差 IE 11 或更低版本，不支持或仅部分支持 flex 布局原理 flex 是flexible Box的缩写，意为弹性布局，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。\n当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 =flex 布局 体验中 div 就是 flex 父容器 体验中 span 就是 子容器 flex 项目 子容器可以横向排列也可以纵向排列 flex 布局父元素常见属性 属性值 说明 flex-direction 设置主轴的方向 justify-content 设置主轴上的子元素排列方式 flex-wrap 设置子元素是否换行  align-content：设置侧轴上的子元素的排列方式（多行） align-items 设置侧轴上的子元素排列方式（单行） flex-flow 复合属性，相当于同时设置了 flex-direction 和 flex-wrap flex-direction flex-direction属性决定主轴的方向（即项目的排列方向）\n主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。\n属性值 说明 row 默认值从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 justify-content justify-content属性定义了项目在主轴上的对齐方式\n属性值 说明 flex-start 默认值 从头部开始 如果主轴是 x 轴，则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐（如果主轴是 x 轴则 水平居中） space-around 平分剩余空间 space-between 先两边贴边 再平分剩余空间（重要） flex-wrap flex-wrap设置子元素是否换行\n属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items align-items设置侧轴上的子元素排列方式（单行）\n属性值 说明 flex-start 从上到下 flex-end 从下到上 center 挤在一起居中（垂直居中） stretch 拉伸 （默认值 ） align-content align-content设置侧轴上的子元素的排列方式（多行）\n属性值 说明 flex-start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 align-content 和 align-items 区别 align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content 适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、 下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找 align-items/多行找 align-content flex-flow flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性\n1 flex-flow: row wrap; flex 布局子项常见属性 属性值 说明 flex 子项目占的份数 align-self 控制子项自己在侧轴的排列方式 order 属性定义子项的排列顺序（前后顺序） flex flex属性定义子项目分配剩余空间，用 flex 来表示占多少份数。\nalign-self align-self 控制子项自己在侧轴上的排列方式\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。\n默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于stretch。\norder order 属性定义项目的排列顺序\n数值越小，排列越靠前，默认为 0\n","date":"2024-04-18T05:04:57+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AF%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7/","title":"【前端】移动端布局技巧"},{"content":"2D 变换 2D 变换有三种形式：\ntranslate：平移 rotate：旋转 scale：伸缩 可以同时使用多个形式\n2D 变换-平移 语法格式：transform: translate(x, y)，\nx、y 的单位可以是px，也可以是百分比，当值是百分比时，表示自身宽度/高度的比例\n也可以分开写：translateX()/translateY()\n注意事项：\ntranslate 对行内标签没有作用 translate(x, y)表示相对于父元素移动的距离，且是一种声明式写法 translate 最大的特点：不会影响其他元素的位置(不脱标) 2D 变换-旋转 语法格式：transform: rotate(60deg)，单位是deg\n角度为正时，顺时针，负时，为逆时针\n默认旋转的中心点是元素的中心点\n2D 旋转-中心点 语法格式：transform-origin: x y;\n注意事项：\n的参数 x 和 y 用空格隔开，单位可以是px/百分比/方位名词 x y 默认转换的中心点是元素的中心点 (50% 50%) 可以给 x y 设置 像素 或者 方位名词 （top bottom left right center） 2D 变换-伸缩 语法格式：transform:scale(x,y);\n注意事项：\n宽和高都放大一倍，相对于没有放大 只写一个参数，第二个参数则和第一个参数一样 sacle 缩放最大的优势：默认以中心点缩放的，而且不影响其他盒子(不脱标) CSS 动画 制作动画可以分为两部：\n定义 调用 动画的定义 语法格式：\n1 2 3 4 5 6 7 8 @keyframes 动画名称 { 0% { width: 100px; } 100% { width: 200px; } } 注意事项：\n0%是动画的开始，100%是动画的完成。这样的规则就是动画序列(关键帧) 用关键词from和to，等同于0%和100% 在0%和100%中间可以随意定义多个百分比关键帧 动画的调用 在需要使用该动画的元素上加上animation-name、animation-duration等属性\n动画常用属性：\n属性 描述 @keyframes 定义动画 animation 所有动画属性的简写 animation-name 动画名称 animation-duration 动画持续时间 animation-time-function 动画速度曲线，默认是ease，还有liner/steps/ease-in等属性 animation-delay 动画何时开始 animation-iteration-count 动画播放次数，默认是1，还有infinite animation-direction 是否在下一个周期逆向播放，默认值是normal，还有alternate(逆向播放) animation-fill-mode 规定动画结束之后保持forwards，回到起点backwards animation-play-state 动画播放状态，running/paused 3D 变换 3D 变换有三种形式：\ntranslate3d：3D 平移 rotate3d：3D 旋转 3 维坐标系 三维坐标系其实就是指立体空间，立体空间是由 3 个轴共同组成的。\nx 轴：水平向右 注意： x 右边是正值，左边是负值 y 轴：垂直向下 注意： y 下面是正值，上面是负值 z 轴：垂直屏幕 注意： 往外面是正值，往里面是负值 因为 z 轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动\n透视 perspective perspective在 2D 平面产生近大远小视觉立体，但是只是效果二维的\n注意事项：\n视距应该给父元素/祖元素添加 透视我们也称为视距：视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大，越远成像越小 透视的单位是px 3D 变换-平移 语法格式：transform:translate3d(x,y,z)\n也可以分开写：translateX/translateY/translateZ\n3D 变换-旋转 语法格式：transform:rotate3d(x,y,z,deg)，了解即可\n也可以按照坐标轴旋转：rotateX(45deg)/rotateY(45deg)/rotateZ(45deg)\n注意事项：\n旋转方向遵循左手准则 3D 呈现 transfrom-style 给父元素添加变换属性时，子元素的变换属性可能失效\n为了保持子元素 3D 变换效果，应该给父元素添加transfrom-style: preserve-3d;属性(默认值是flat)\n私有浏览器前缀 浏览器私有前缀是为了兼容老版本的写法，比较新版本的浏览器无须添加。\n私有前缀：\n-moz-：代表 firefox 浏览器私有属性 -ms-：代表 ie 浏览器私有属性 -webkit-：代表 safari、chrome 私有属性 -o-：代表 Opera 私有属性 ","date":"2024-04-18T03:15:42+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss3%E5%8A%A8%E7%94%BB/","title":"【前端】CSS3动画"},{"content":"模块化开发 项目目录结构 一个好的项目目录结构清晰：\ncss(样式：通过外部样式引入) fonts(字体图标) images(网站静态图片) upload(用户上传的图片) js(javascrip 脚本) favicon.ico(网站图标) index.html(网站入口) 样式的模块化开发 样式的初始化放在 base.css 文件中 可共用的样式放在 common.css 文件中 网站 SEO 优化 TDK 三大标签 title(网站标题-解释说明) description(网站说明) Keywords(关键字) 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 网站标题 --\u0026gt; \u0026lt;title\u0026gt;品优购商城-正品低价、品质保障、配送及时、轻松购物！\u0026lt;/title\u0026gt; \u0026lt;!-- 网站描述 --\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;品优购商城-专业的综合网上购物商城，为您提供正品低价的购物选择、优质便捷的服务体验。商品来自全球数十万品牌商家，囊括家电、手机、电脑、服装、居家、母婴、美妆、个护、食品、生鲜等丰富品类，满足各种购物需求。\u0026#34; /\u0026gt; \u0026lt;!-- 关键字 --\u0026gt; \u0026lt;meta name=\u0026#34;Keywords\u0026#34; content=\u0026#34;网上购物,网上商城,家电,手机,电脑,服装,居家,母婴,美妆,个护,食品,生鲜,京东\u0026#34; /\u0026gt; favicon.ico 图标制作与使用 figma切图切出 png 格式的图片 https://favicon.io/进行格式转化，转化为 ico 格式 放在项目根目录下，通过\u0026lt;link rel=\u0026quot;shortcut icon\u0026quot; href=\u0026quot;./favicon.ico\u0026quot; /\u0026gt;引入 网站 logo 制作 先放置一个\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;标签 标签里放置一个链接，链接里的文字是网站名称，会跳转网站首页，文字不展示。链接的背景图片是 logo 文字不展示的方法： text-indent: -9999px; overflow: hidden; font-size: 0; 给链接一个title属性 ","date":"2024-04-09T09:04:08+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFweb%E7%AB%AF%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/","title":"【前端】Web端网页项目实战技巧"},{"content":"HTML5 新特性 新的标签 新的表单 新的表单属性 新的标签 针对搜索引擎的，可以多次使用，移动端更常见\n语义化标签 header(头部标签) nav(导航标签) article(内容标签) section(区域标签) aside(侧边栏标签) footer(尾部标签) 视频标签：\u0026lt;video\u0026gt;\u0026lt;/video\u0026gt; 视频格式 mp4(所有浏览器都支持，尽量使用该格式) WebM Ogg 属性 src(文件地址) autoplay(自动播放：autoplay，谷歌浏览器需要添加muted属性解决自动播放) controls(显示播放控件：controls) loop(循环播放) preload(预先加载：auto/none) width(宽度) height(高度) poster(加载等待的图片) muted(静音播放：muted) 音频标签：\u0026lt;audio\u0026gt;\u0026lt;/audio\u0026gt; 音频格式 mp3(所有浏览器都支持，尽量使用该格式) Wav Ogg 属性 src(文件地址) autoplay(自动播放：autoplay) controls(播放控件：controls) loop(循环播放：loop) muted(静音：muted) 新的表单 HTML5 中input表单新增了很多种类型：\nnumber(数字) email(邮箱) tel(电话) search(搜索框) color(颜色) date(日期) time(时间) month(月) week(周) 新的表单属性 required(必填) placeholder(提示文本) autocomplete(自动补全之前搜索记录) autofocus(自动聚焦：百度首页) multiple(可以提交多个文件) CSS3 新特性 CSS3 新增特性：\n新的选择器 新的盒子模型 图片模糊处理 属性过度 属性选择器 属性选择器通过元素具有的属性来选择元素\n语法：input[属性]\n选择符 简介 E[att] 选择具有属性的 E 元素 E[att=\u0026ldquo;val\u0026rdquo;] 选择具有属性 att 且其值等于 val 的 E 元素 E[att^=\u0026ldquo;vale] 选择具有属性 att 且其值以 val 开头 的 E 元素 E[att$=\u0026ldquo;val\u0026rdquo;] 选择具有属性 att 且其值以 val 结尾的 E 元素 E[att*=\u0026ldquo;val\u0026rdquo;] 选择具有属性 att 且其值包含 val 的 E 元素 结构伪类选择器 结构伪类选择器通过文档的结构来选择元素，常用于选择父级里的子元素\n选择符 简介 E:first-child 匹配父元素里的第一个子元素 E:last-child 匹配父元素里的最后一个子元素 E:nth-child(n) 匹配父元素里的第 n 个子元素 E:first-of-type 匹配父元素里指定类型的第一个子元素 E:last-of-type 匹配父元素里指定类型的最后一个子元素 E:nth-of-type(n) 匹配父元素里指定类型的第 n 个元素 nth结构伪类选择器中的n既可以是数字也可以是公式/关键字\n数字 even(偶数)、odd(奇数) 包含n的公式：n 从零开始计算，超过的不计算 nth-child(n)与 nth-of-type(n)的区别：\nnth-child(n)会把所有子元素进行排序，再看前面选择的类型，如果匹配不上，则选不上 nth-of-type(n)只会把指定类型的元素进行排序，再选择第 n 个 伪元素选择器 伪元素选择器的由来：伪元素选择器可以利用CSS创建新标签，简化HTML代码\n选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意事项：\nbefore 和 after 创建一个元素，但是属于行内元素 新创建的元素在文档树中不存在，所以叫做伪元素 before 和 after 伪元素选择器必须包含content属性 伪元素选择器和标签选择器一样权重是1 使用场景：\n字体图标 遮罩层 清除浮动 CSS3 盒子模型 CSS2 的盒子模型，边框、内边距都会撑开盒子\nCSS3 可以通过box-sizing无需考虑\n可选择的值：\ncontent-box(和 CSS2 盒子模型一样) border-box(新的盒子模型) CSS3 其他特性 图片变模糊 img {filter: blur(n px);}\nn 越大，图片越模糊。当 n=0 时，没有模糊效果\n盒子宽度计算函数 calc() width: calc(100% - 30px)\nCSS3 属性过渡 是一种简单的动画效果\n语法：transtion: 要过渡的属性 花费时间 运动曲线 何时开始;，在原选择器上写(谁做过渡给谁加)。\n属性：宽度/高度/背景颜色/内外边距/all，如果想要写多个属性，应该使用逗号分隔 花费时间：单位是秒 运动曲线：默认是 ease(可以省略) linear(匀速) ease(逐渐慢下来) ease-in(加速) ease-out(减速) ease-in-out(先加速后减速) 何时开始：单位是秒，用于设置延迟触发时间 ","date":"2024-04-07T19:32:51+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml5css3/","title":"【前端】HTML5CSS3"},{"content":"JavaScript 简介 Javascript 是什么 是一种运行在客户端(浏览器)的编程语言，实现人机交互效果\nJavaScript 应用场景 网页特效(事件监听) 表单验证(针对表单数据的合法性进行判断) 数据交互(获取后台数据，渲染到前端) 服务端编程(node.js) JavaScript 组成 JavaScript：\nECMScript(JavaScript 语言基础) js 基础核心语法知识 变量 分支语句 循环语句 对象 WebAPIs DOM(文档对象模型) BOM(浏览器对象模型) JavaScript 书写位置 行内 JavaScript 内部 JavaScript 外部 JavaScript(通过 src 属性引入，中间无需写代码，否则会被忽略) 内部 JavaScript 放在\u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签最下方\n浏览器按照代码在文件中顺序加载html\n放在其他位置，可能会由于HTML未加载而失败\nJavaScript 注释和结束符 注释 单行注释：// (ctrl + /) 多行注释：/* */ (alt + shift + a) 结束符 作用： ;，代表语句结束 实际情况： 可写可不写 现状：更多人主张省略结束符 约定：风格统一，按照团队要求 JavaScript 输入输出语法和字面量 文档输出内容 1 document.write(\u0026#34;我是div标签\u0026#34;); 页面弹出警告 1 alert(\u0026#34;hello world\u0026#34;); 控制台输出内容 1 console.log(\u0026#34;hello world\u0026#34;); 输入语句 1 prompt(\u0026#34;请输入您的年龄\u0026#34;); 字面量 就是常量的意思：\n数字字面量 字符串字面量 数组字面量 对象字面量 JavaScript 变量 变量是什么 计算机存储数据的容器\n变量的作用 存储数据\n变量的声明与赋值 1 2 3 4 5 6 7 8 9 10 11 // 声明变量 let age; // 变量赋值 age = 18; // 声明多个变量，不提倡，可读性不好 let name = \u0026#34;xixi\u0026#34;, number = 20; // 打印变量的值 console.log(age); // 变量声明的同时赋值，叫做变量的初始化 let name = \u0026#34;cengdong\u0026#34;; 注意事项：\n变量不能重复声明 多个变量同时声明中间使用逗号隔开 交换两个变量的值 定义临时变量\n1 2 3 4 5 6 let number1 = 10; let number2 = 20; let tmp; tmp = number1; number1 = number2; number2 = tmp; 变量的本质与命名规则 变量的本质就是程序在内存中申请的一块存储数据的空间\n变量命名规则：\n只能包含字母``数字``$和下划线 不能以数字开头 不能用关键字 大小写敏感 变量命名规范：\n见名知意 小驼峰命名法：userName let 与 var 的区别 var 声明：\n可以先使用再声明(不合理) 可以重复声明(不合理) 变量提升、全局变量、没有块级作用域 数组 数组的声明与初始化 数组可以存储任意数据类型\n1 let arr = [1, 2, 3]; 数组相关术语：\n索引(从零开始) 元素 长度(arr.length) 常量 常量声明：const\n1 2 const COUNT = 100; console.log(COUNT); 注意事项：\n声明的时候必须赋值 不允许重新赋值 数据类型 JavaScript 数据类型 基本数据类型 number string boolean undefined null 引用数据类型 object 获取一个变量的数据类型：typeof()函数或者typeof x运算符\n数字类型与算数运算符 所有的数字都是数字型\n数字间有很多操作：\n+加 -减 *乘 /除 %取余 算数运算符有优先级，按照优先级先后顺序进行运算\n优先级口诀：先乘除后加减，有小括号先算小括号\n数字类型特殊的值：NaN(运算错误时)\nNaN 是粘性的，任何对 NaN 的操作都会返回 NaN\n字符串类型 通过单引号、双引号、反引号包裹的数据都叫字符串\n单引号与双引号本质没有区别，推荐使用单引号\n字符串拼接 通过+进行字符串拼接\n口诀：数字相加，字符拼接\n模版字符串 使用场景：拼接字符串与变量\n语法：\n反引号包裹 内容拼接变量时，使用${}包裹 boolean\u0026amp;undefined\u0026amp;null boolean boolean 类型数据有两种值：\ntrue false 可以与数字型进行运算，false 为 0，true 为 1\nundefined 只声明，不赋值的情况下，变量的默认值为 undefined 一般很少直接给变量赋值为 undefined null 代表无、空、未知的特殊值\nnull 和 undefined 的区别：\nundefined 表示没有赋值 null 表示赋值了，但是内容为空 计算时有区别，null 可表示为 0 变量类型转换 类型转换有两种：\n数据类型转换就是把一种数据类型的变量转换为我们需要的数据类型\n隐式转换(自动类型转换) 显示转换(强制类型转换) 隐式转换 任何数据和字符串相加结果都是字符串 除了+的其他运算符(比较运算符也会)，会把数字的字符串转换为 number 类型 +号作为正号解析可以转换为数字型 null 类型参与运算 boolean 类型数据参与运算 显示转换 转换为数字型 转换为数字型：Number()，转换失败时为NaN 只保留整数：parseInt() 保留小数：parseFloat() 1 2 3 4 5 6 console.log(Number(\u0026#34;1.1\u0026#34;)); console.log(Number(\u0026#34;abc\u0026#34;)); console.log(parseInt(\u0026#34;1.2\u0026#34;)); console.log(parseInt(\u0026#34;1.2px\u0026#34;)); console.log(parseFloat(\u0026#34;1.2px\u0026#34;)); console.log(parseFloat(\u0026#34;abc1.2px\u0026#34;)); 转换为字符串型 String() toString() 区别：\nString()可以转换所有数据类型，toString()不能转换 null、undefined toString 可以传参，表示以多少进制的格式输出结果；String 方法传参无效 ","date":"2024-04-06T19:02:31+08:00","permalink":"https://www.cengdong.store/p/javascriptjavascript%E5%9F%BA%E7%A1%80%E4%B8%80/","title":"【JavaScript】JavaScript基础一"},{"content":"精灵图 为什么需要精灵图技术 很多小图片，每一个小图片请求一次，浪费网络 IO\n为了减少服务器发送/接受请求次数，提高页面加载速度\n精灵图技术原理 精灵图技术主要针对背景图片 将多个背景图片整合到一张图片中 使用background-position/width/height属性将图片进行切割得到想要的图片 一般background-position都是负值 字体图标 字体图标产生的原因 网页上有许多小图标，使用精灵图技术实现有很多缺点\n精灵图是背景图片，图片占用存储比较大 图片进行放大缩小时会失真 精灵图一旦确定，修改很麻烦 字体图标的优点 展示的是图标，其实是字体 放大缩小不失真，可以随便改变颜色 字体图标使用 下载字体图标 引入字体图标 下载的字体图标放在项目根目录 通过 CSS 引入 在页面中通过font-family使用图标 更新下载图标 原来的文件不能删除 导入selection.json CSS 三角 CSS 三角的原理 通过边框实现\n一个没有大小的盒子：box { width: 0; height: 0;} 为盒子设置边框：大小为三角底边长度，颜色为透明，风格为实线：border: 10px solid transparent; 想要的三角形底边在哪，哪个方向的边框设置颜色border-left: red; 用户界面控制 用户界面样式，提高用户体验\n鼠标样式 通过li {cursor: value;}控制\ndefault(小白，默认) pointer(小手) move(移动) text(文本) not-allow(禁止) 表单轮廓 文本框默认有边框轮廓，通过outline: none;取消\n防止表单拖拽 文本域防拖拽，默认可以拖拽：resize: none;\n行内块元素与文本垂直居中 行内块元素(图片/表单)与文本垂直对齐\n为行内块元素设置vertical-align属性\nvertical-align: baseline | top | middle | bottom;\n值 描述 baseline 基线 top 顶线 middle 中线 bottom 底线 图片和文字默认是基线对齐\n图片底部空白缝隙 产生原因 因为图片默认和文字基线对齐，所以底部有缝隙\n解决方案 设置vertical-align: bottom | middle | top; 把图片转换为块元素 溢出文字省略号显示 单行文字溢出 单行文本溢出省略显示的三个条件：\n强制文本一行显示：white-space: nowrap; 默认normal自动换行 超出部分隐藏：overflow: hidden; 文字用省略号替代超出的部分：text-overflow: ellipsis; 多行文字溢出 多行文本溢出显示省略号，适用于 web-kit 内核，有较大的兼容性问题\noverflow: hidden; text-overflow: ellipsis; display: -webkit-box; -wbekit-line-clamp: 2; -webkit-box-orient: vertical; 常见布局技巧 margin 负值的应用 盒子细线边框(合并边框)：\nmargin-left: -边框宽度;，右边盒子压住左边盒子右边框 鼠标经过，边框变换颜色： 盒子没有定位，添加相对定位(不脱标) 盒子有定位：z-index: 9999 文字围绕浮动元素 利用浮动不会压住文字的特点，添加浮动之后，文字就会围绕浮动元素\n行内块元素巧妙应用 页码布局的实现\n利用行内块元素间自带的间隙 文字水平居中：text-align: center; 文字垂直居中：line-height: 行内块元素高度 所有的行内块元素与行内元素水平居中：给父元素text-align: center; CSS 三角强化 非等腰三角的实现\n等腰三角的实现：宽度高度为0的盒子 四条边框颜色不一样，除了直角边设置颜色，其他边设置为transparent 无关的边框设置为 0 短边对面的边框调整宽度 1 2 3 4 5 6 7 8 box { width: 0; height: 0; border-color: transparent red transparent transparent; border-style: solid; border-width: 22px 8px 0 0; } `` CSS 初始化 不同浏览器对于有些标签的默认值不一样，为了消除这个，需要对 CSS 进行初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /* 清除元素默认内外边距 */ * { margin: 0; padding: 0 } /* 斜体样式正常化 */ em, i { font-style: normal } /* 清除列表默认样式：小圆点 */ li { list-style: none } /* 图片与文字垂直对齐 */ img { border: 0; vertical-align: middle } /* 用户界面：按钮鼠标变为小手 */ button { cursor: pointer } /* 清除链接下划线 */ a { color: #666; text-decoration: none } a:hover { color: #c81623 } button, input { font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif } body { -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif; color: #666 } .hide, .none { display: none } /* 清除浮动 */ .clearfix:after { visibility: hidden; clear: both; display: block; content: \u0026#34;.\u0026#34;; height: 0 } .clearfix { *zoom: 1 } ","date":"2024-04-06T18:33:34+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"【前端】网页布局常用技巧"},{"content":"网页布局入门 网页布局的本质就是通过CSS把盒子摆到相应位置。\n网页布局方式 网页布局有以下三种方式：\n普通流布局 浮动布局 定位布局 网页布局准则 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动\n网页布局第二准则：先设置盒子大小，再设置盒子位置\n网页布局流程 确认页面版心(可视区)，可视区水平居中 分析页面中行模块，以及每个行中的列模块 一行中列模块经常浮动布局，先确定列大小，再确定列位置 先制作 html 结构。先结构，后样式。 标准流/普通流 标准流就是元素按照规定的默认方式排序\n行内元素 块元素 行内块元素 浮动布局 为什么需要浮动 使多个\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;在同一行展示：在标准流中使用display: inline-block，但是盒子之间会有缝隙 实现两个盒子左右对齐：标准流很难实现 什么是浮动 float属性用于创建浮动框，将其移动到一边，直至左边缘/右边缘遇到其他块，或者是另一个浮动框的边缘\n浮动语法：float: 属性值\nnone(默认值) left right 浮动的特性 加了浮动的元素会脱离标准流 浮动的元素会一行显示并且元素顶部对齐 浮动的元素具有行内块元素特性 浮动的注意点 浮动和标准流父盒子搭配使用 一个元素浮动，其他元素也要浮动 浮动的盒子只会影响后面的标准流 清除浮动 不一定需要给父盒子设置高度\n理想的状态：子盒子撑开父盒子\n浮动的元素不占位置(浮动布局中没有子盒子撑开父盒子)\n因此需要清除浮动，清除浮动有以下几种方式：\n额外标签法(w3c 推荐)：在最后一个浮动的元素添加块级元素并添加属性clear: left/right/both(推荐) 父级元素添加overflow: hidden/auto/scroll属性 父级添加after伪元素 父级添加双伪元素 1 2 3 4 5 .clearfix:after { content: \u0026#34;\u0026#34;; display: block; clear: both; } 1 2 3 4 5 6 .clearfix::before, .clearfix::after { content: \u0026#34;\u0026#34;; display: table; clear: both; } 切图 常见的图片格式 jpg：对色彩保留信息好，产品类图片 gif：显示简单的图形及字体，图片动画。特点：保存透明背景和动画效果 png：结合 jpg 与 gif psd：photoshop 的专用格式 切图方式 图层切图：移动工具、合并图层(ctrl + e) 切片切图：切片工具 插件切图：Cutterman 其他软件：蓝湖、幕客 定位 为什么需要定位 盒子自由移动，并且压住其他盒子 盒子位置固定 定位组成 定位方式 static(默认值) relative absolute fixed sticky 边偏移 top right bottom left 相对定位：relative 相对定位是相对于盒子自己原来位置 相对定位原来位置继续占有(不脱标，保留原来位置) 绝对定位：absolute 没有父元素/父元素没有定位则相对浏览器进行移动 父元素有定位(相对/决定/固定)则相对最近一级有定位的父元素进行移动 绝对定位脱标，不占有原来位置 子绝父相 子级使用绝对定位，父亲需要相对定位\n子级绝对定位，不会占有位置，可以放在任何地方 父级相对定位，约束子级相对自己移动，并且相对定位占有原来位置 固定定位 固定定位是固定于浏览器可视区的位置 固定定位会脱标，可以看做是特殊的绝对定位 固定版心右侧：left: 50%; margin-left: 1/2版心宽度 粘性定位 position: sticky 必须设置top/right/bottom/left中的一个 不脱标 定位的叠放顺序 z-index，值越大，越在上面\n绝对定位的盒子水平/垂直居中 left: 50%; margin-left: -1/2自己宽度 top: 50%; margin-top: -1/2自己宽度 定位特性 加了绝对/固定定位/浮动的盒子会变成行内块元素 加了绝对/固定定位/浮动的元素默认宽度是内容宽度 绝对/固定定位/浮动的盒子不会发生外边距合并 绝对/固定定位会压住标准流所有(盒子+文字)，浮动不会压住文字 元素的显示与隐藏 display 通过display控制隐藏的元素不会占有原来位置，有以下几个主要可选的值：\nnone(隐藏元素) block(显示元素/更改为块元素) visibility 通过visibility控制隐藏的元素还会占有原来位置，有以下几个可选的值：\ninherit(继承，默认值) visible(可见的) hidden(隐藏) collapse(隐藏表格) overflow overflow主要控制溢出部分的显示策略，有以下几个可选的值：\nhidden(隐藏) visible(可见的，默认值) auto(有溢出，才展示滚轮。textarea元素的默认值) scroll(总是展示滚轮) ","date":"2024-04-04T19:32:48+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/","title":"【前端】网页布局"},{"content":"盒子模型组成 盒子模型有以下四个成员：\ncontent(内容) padding(内边距) border(边框) margin(外边距) 盒子模型 border 边框会影响盒子实际大小\n边框属性 border-width：宽度 border-style：样式 solid(实线) dashed(虚线) dotted(点线) border-color：颜色 边框简写： border: border-widtgh border-style border-color，没有顺序要求\n边框分开写法 border-top border-bottom border-left border-right 合并相邻边框：border-collapse: collapse\n盒子模型 padding padding会影响盒子实际大小\n内边距属性 padding-left padding-top padding-right padding-bottom 内边距简写 值的个数 效果 padding: 5px; 1 个值，代表上下左右 padding: 5px 10px; 2 个值，上下 5px，左右 10px padding: 5px 10px 20px; 3 个值，上边距 5px，左右边距 10px，下边距 20px padding: 5px 10px 15px 20px; 4 个值，上边距 5px，右边距 10px，下边距 15px，左边距 20px padding 不会影响盒子的情况 不设置width/height的情况下，不会影响盒子没有设置的属性。\n盒子模型 margin 外边距属性 margin-top margin-right margin-bottom margin-left 外边距简写 值的个数 效果 margin: 5px; 1 个值，代表上下左右 margin: 5px 10px; 2 个值，上下 5px，左右 10px margin: 5px 10px 20px; 3 个值，上边距 5px，左右边距 10px，下边距 20px margin: 5px 10px 15px 20px; 4 个值，上边距 5px，右边距 10px，下边距 15px，左边距 20px 外边距应用场景 块元素水平居中：margin: 0 auto;\n行内元素/行内块元素水平居中，给其父亲添加：text-align: center;\n外边距注意点 相邻垂直外边距合并：只给一个元素添加外边距 嵌套垂直外边距塌陷： 给父元素添加上边框 给父元素添加上内边距 给父元素添加overflow: hidden; 内外边距注意事项 清除内外边距 清除网页元素自带的内外边距\n1 2 3 4 * { margin: 0; padding: 0; } 开发建议 行内元素一般只设置左右内外边距 块元素之间使用外边距 块元素内部使用内边距 取消列表原点：lisr-style: none; 圆角边框 圆角边框的作用是可以把盒子变成圆形\n语法格式 border-radius: length; length既可以是单位/px，也可以是百分比. 可以设置4个值，从左上角开始顺时针变化 length越大，弧度越大 盒子阴影 使用box-shadow属性为盒子添加阴影\n语法格式 box-shadow: h-shadow v-shadow blur spread color inset;\n属性值 值 描述 h-shadow 必需。水平阴影。允许负值 v-shadow 必需。垂直阴影。允许负值 blur 可选。模糊距离 spread 可选。阴影尺寸 color 可选。阴影颜色 inset 可选。将外部阴影(outset)改为内部阴影 注意事项 阴影默认 outset，但是不可以书写，否则失效 阴影不占位置，不影响其他元素布局 文字阴影 text-shadow: h-shadow v-shadow blur color;\n相关属性的意义与盒子阴影一样\n","date":"2024-04-03T21:32:09+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","title":"【前端】CSS盒子模型"},{"content":"Emmet 语法 Emmet语法用于快速编写html标签与css样式\n快速生成 html 结构 生成网页骨架：html: 5 生成标签：输入标签名，按下tab键 生成多个相同标签：输入标签名*number，按下tab键 生成父子关系标签：输入标签名\u0026gt;标签名，按下tab键 生成兄弟关系标签：输入标签名+标签名，按下tab键 生成带类名的：输入标签名#classname或者标签名.classname，按下tab键 类名自增 快速生成 css 样式 通过单词缩写快速生成 css 样式属性值\nCSS 复合选择器 复合选择器可以更准确、高效定位元素\n通过两个或者多个``基础选择器组成\n复合选择器主要有以下几种：\n后代选择器 子选择器 并集选择器 伪类选择器 后代选择器 后代选择器选择的是父元素里的后代元素\n格式：标签1 标签2 ... 标签n { 样式声明 }\n既可以选择孩子，也可以选择孙子。\n选择器可以是任意基础选择器的组合\n.nav ol li\n子选择器 子选择器选择的是父元素里的子元素\n格式：父元素\u0026gt;子元素 { 样式声明 }\n并集选择器 并集选择器可以选择多组标签，为他们设定相同的样式\n格式：元素1, 元素2, ... 元素n { 样式声明 }\n伪类选择器 伪类选择器可以给某些选择器添加特殊效果(链接)，或者用于选择第1个或者第n个元素\n链接伪类选择器 hover 伪类选择器种类：\na:link(未访问) a:visited(已访问) a:hover(鼠标经过) a:active(鼠标点击但未抬起) 注意事项：\n必须按照lvha顺序编写链接伪类选择器\nfocus 伪类选择器 focus伪类选择器用于选择获得焦点的表单元素\n格式：input:focus { 样式声明 }\nCSS 元素显示模式 块元素 常见的块元素有：h1-h6、p、div、ul、ol、li 等\n块元素`独占一行`` 可以对块元素的宽、高、内外间距进行设置 默认宽度为父元素的宽度 块元素内部可以放其他行内元素/块元素 文本块元素(p、h1-h6)内部不能放置块元素 行内元素 常见的行内元素有：a、文本格式化标签、span\n多个行内元素一行展示 不可以直接对行内元素进行宽、高设置 行内元素默认宽度为内容的宽度 行内元素内部可以放文本或其他行内元素 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;标签内部不能放置\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; 特殊情况\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;内部可以放块元素 行内块元素 常见的行内块元素有：img、input、td，同时具有行内元素和块元素的特点：\n多个一行展示 可以设置宽和高 默认宽度为内容宽度 显示模式转换 增加\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;链接触发范围\ndisplay: bolck; display: inline; display: inline-block; CSS 背景 CSS背景用于设置背景颜色、图片、平铺、图片位置、图片固定\n背景颜色 通过background-color设置\ntransparent(默认值) 和文本color一样 背景图片 通过background-image设置，小图片一般通过背景图片设置\n既可以设置背景图片，也可以设置背景颜色，背景图片会压住背景颜色\nnone url() 背景平铺 背景平铺就是背景图片重复展示，通过background-repeat设置\nno-repeat repeat(默认值) repeat-x repeat-y 背景位置 background-position: x y;属性可以改变背景图片的位置\n方位名词：background-position: left top;，可以省略一个参数，第二个参数居中 精准单位：background-position: x y; 混合单位：严格顺序，第一个为x，第二个为y 背景固定 background-attchment用于设置背景图片是随着页面滚动，还是随着页面固定\nscroll(默认值) fixed 背景复合写法 background: 背景颜色 背景图片 背景平铺 背景图片滚动 背景图片位置;\n背景颜色半透明 rgba(0, 0, 0, 0.3)，a 的取值范围为 0-1，越小越淡.\nCSS 三大特性 层叠性 继承性 优先级 层叠性 为了解决样式冲突，就近原则\n继承性 子标签继承父标签的某些样式：文本颜色和字号/(text-、font-、line-、color)\nline-height可以不设置单位，最终显示当前元素``文字大小的倍数：font: 12px/1.5 'Microsoft YaHei'\n优先级 当给同一个元素指定多个选择器名，就会有优先级产生\n选择器相同：执行层叠行 选择器不同：执行优先级 选择器 选择器权重 继承或者* 0,0,0,0 标签选择器 0,0,0,1 类选择器、伪类选择器、属性选择器 0,0,1,0 id 选择器 0,1,0,0 行内样式 1,0,0,0 !important +∞ 注意事项：\n权重计算有四位，但是不会进位 从左至右判断 权重叠加 如果是复合选择器，则会有权重叠加问题\n","date":"2024-04-02T18:04:46+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss%E4%B8%8B/","title":"【前端】CSS下"},{"content":"CSS 简介 HTML 局限性 用html修改网页外观代价太大\nCSS 的作用 CSS(Cascading style sheets)用于进行网页布局\n用于改变文字、图片、网页布局、外观\nCSS 语法规范 构成 选择器 + 一个或者多个声明：属性: 值;\n书写位置 内部样式表：\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;标签中，用\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt;标签声明 行内样式表：标签内部style属性，style=\u0026quot;key: value; key: value\u0026quot; 外部样式表(推荐)：\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;文件路径\u0026quot;\u0026gt; 规范 一般采用分散式：一行设置一个属性值 选择器与括号、属性 key/value 之间需要一个空格 CSS 书写顺序： 布局定位属性(display/position/float/clear/visibility/overflow) 自身属性(width/height/margin/padding/border/background) 文本属性(color/font/text-decoration/text-align/vertical-align) 其他属性(CSS3)：content/cursor/border-radius/box-shadow/text-shadow CSS 选择器 选择器的作用 选出需求的标签\n选择器分类 基础选择器 标签选择器 id 选择器 class 选择器 通配符选择器 复合选择器 选择器使用方式 基础选择器 作用 特点 使用情况 用法 标签选择器 选出所有相同标签 不能差异化选择 较多 p {color: red;} 类选择器 选出一个或多个标签 可以根据需求选择 非常多 .nav {color: red;} id 选择器 一次只能选择一个标签 id 具有唯一性 一般和 js 搭配使用 #red {color: red;} 通配符选择器 选择所有标签 一般用于设置盒子间距 特殊情况使用 * {color: red;} class 多类名 一个标签可以使用多个类选择器定义的css 样式，多个类名之间使用空格分隔\n\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot; class=\u0026quot;red green\u0026quot;\u0026gt;百度一下，你就知道\u0026lt;/a\u0026gt;\n字体属性 CSS 字体属性用于定义字体系列、大小、粗细、文字样式\nfont-family font-family用于给字体设置系列\n多种字体之间使用逗号分隔，从左至右依次匹配\n有空格分开的多个单词组成的字体，使用单引号包裹\nfont-size/line-height font-size用于设置字体大小，必须使用单位px\nline-height用于设置行高\n文字垂直居中的技巧：line-height等于元素高度\n可以给\u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签设置整个 html 文档的字体大小\n标题标签应使用额外样式设置字体大小\nfont-weight font-weight用于给字体设置粗细，值可以设置以下几种：\nnormal(默认，400) bold(粗体，700) bolder(特粗体) lighter(细体) number(100-900)，不能跟单位 font-style font-style用于设置字体样式，有以下属性值：\nnormal italic(斜体) 复合属性 复合属性通过font属性设置\nfont: font-style font-weight font-size/line-height font-family\n必须严格按照顺序书写\nfont-size与font-family必须设置，其他可以省略\n文本属性 color color属性用于设置标签内字体颜色\n颜色有三种表示方式\n英语单词(red、green 等) #16 进制表示(用的最多) rgb 表示 text-align text-align用于设置文本对齐方式，有以下三种值：\ncenter left(默认值) right text-decoration text-decoration用于设置文本装饰，有以下四种值：\nnone underline overline line-through text-indent text-indent用于设置文本缩进，单位是 px/em，1em 等于一个文字大小\np {text-indent: 2em;}\n注意，只缩进首行\nline-height line-height用于设置文字行间距离\nline-height = font-size + 上间距 + 下间距，上下间距相等\n","date":"2024-04-01T18:40:44+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss/","title":"【前端】CSS"},{"content":"表格标签 表格的作用 表格标签用于展示数据\n\u0026lt;table\u0026gt;\u0026lt;/table\u0026gt;标签定义一个表格\n\u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;标签表示一行(table row)\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;标签表示一个单元格(table data)\n\u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;标签表示表头单元格(table header)，内容会加粗居中展示\n表格属性 align：对齐方式 border：边框 cellpadding：边缘与内容之间的距离(默认 1 像素) cellspacing：单元格之间的距离(默认 2 像素) width：表格宽度 表格标签结构 \u0026lt;table\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;thead\u0026gt;\u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; 合并单元格 合并单元格方式：\n跨行合并：rowspan=\u0026ldquo;个数\u0026rdquo; 跨列合并：colspan=\u0026ldquo;个数\u0026rdquo; 列表标签 列表的作用 列表标签用于布局\n列表分类 无序列表：\u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 有序列表：\u0026lt;ol\u0026gt;\u0026lt;/ol\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 自定义列表：\u0026lt;dl\u0026gt;\u0026lt;/dl\u0026gt;、\u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt;、\u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; 自定义列表用于对名词或者专业术语进行解释\n表单标签 表单的作用 表单标签用于收集用户信息\n表单组成 表单域：\u0026lt;form\u0026gt;\u0026lt;/form\u0026gt; 表单控件：表单元素 提示信息： 表单域属性 action：提交地址 method：提交方式(get/post) name: 表单域名称 input 表单元素 input 元素作用 input 元素用于收集用户信息\ninput 标签属性 type： button：按钮 cehckbox：复选框 file：文件选择 hidden：隐藏 image：图片 password：密码 text：文本 radio：单选框 reset 重置按钮 submit：提交按钮 name：name是表单的名字，单选框必须有相同的名字才可以实现多选一 value：表单的默认值，使用placeholder更好 checked：规定 input 元素首次加载时自动被选中 maxlength：输入字段中字符最大长度 label 标签 label 标签用于 input 聚焦\n通过label标签的for属性与input标签的id属性\n\u0026lt;lable for=\u0026quot;sex\u0026quot;\u0026gt;男\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; id=\u0026quot;sex\u0026quot;/\u0026gt;\nselect 下拉表单元素 下拉表单元素的作用 如果有多个选项提供用户选择，节约空间\n标签 1 2 3 4 5 \u0026lt;select\u0026gt; \u0026lt;option\u0026gt;选项1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选项2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选项3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 属性 option标签有一个selected=\u0026quot;selected\u0026quot;属性，表示默认选中\ntextarea 文本域元素 textarea 使用场景 当用户要输入的内容比较多时，不应使用text类型的input标签，而是应该使用textarea标签\n","date":"2024-04-01T14:36:49+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml%E6%A0%87%E7%AD%BE%E4%B8%8B/","title":"【前端】HTML标签下"},{"content":"浏览器内核 浏览器内核就是浏览器的渲染引擎，目前引擎分类：\n浏览器 内核 IE Trident firefox Gecko safari Webkit chrome/opera Blink Web 标准 W3C 主要包括：结构(HTML)、表现(CSS)、行为(JAVASCRIPT)三个部分。\nWEB 标准提出的最佳解决方案：结构、样式、行为相分离。\nHtml 语法规范 标签一般成对出现，也有单标签 标签之间的关系：包含/并列 Html 基本结构标签 \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt;标签 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;标签 \u0026lt;meta\u0026gt;标签 \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;标签 \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签 html 常用标签 标题标签 h1-h6 分别代表不同级别标题\n段落标签 \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;标签表示一个段落\n换行标签 \u0026lt;br/\u0026gt;标签表示换行\n空格 \u0026amp;nbsp;表示空格\n文本格式化标签 粗体：\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;或者\u0026lt;strong\u0026gt;\u0026lt;/strong\u0026gt; 倾斜：\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;或者\u0026lt;i\u0026gt;\u0026lt;/i\u0026gt; 删除线：\u0026lt;del\u0026gt;\u0026lt;/del\u0026gt;或者\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt; 下划线：\u0026lt;ins\u0026gt;\u0026lt;/ins\u0026gt;或者\u0026lt;u\u0026gt;\u0026lt;/u\u0026gt; 盒子标签 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;标签，独占一行 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;标签，多个在同一行展示 图像标签 \u0026lt;img/\u0026gt;标签表示一张图片，是一个单标签\n图像标签的属性：\nsrc：图片路径 title：图片标题，提示文本 alt：替换文本(图片展示不了时的文本) width：图片宽度 height：图片高度 border：图片边框 超链接标签 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;标签表示一个超链接\n超链接标签的属性：\nhref：链接的地址 target：以何种方式打开：_self(默认)、_blank 超链接的种类：\n外部链接：跳转到外部网站 内部链接：跳转到内部 html 页面 空链接：href=\u0026quot;#\u0026quot; 下载链接：地址链接的是文件 网页元素链接：为网页元素添加超链接：文本、图片、表格、音频、视频 锚点链接：href=\u0026quot;#id\u0026quot; 注释标签与特殊字符 \u0026lt;!-- 注释 --\u0026gt;进行注释\n特殊字符：\n空格：\u0026amp;nbsp; 大于：\u0026amp;gt; 小于：\u0026amp;lt; ","date":"2024-04-01T10:04:06+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml%E6%A0%87%E7%AD%BE/","title":"【前端】HTML标签"},{"content":"通过docker安装gitlab 安装gitlab，你起码需要一台2c4g的服务器，gitlab依赖很多很重的组件，我的环境是一台2c4g的虚拟机\n挂载三个目录：/etc/gitlab、/var/log/gitlab、/var/opt/gitlab\n映射三个端口：443/https、80/http、22/ssh\n443端口如果不用到证书不需要挂载\n1 2 3 4 5 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab \\ --restart always -v ~/data/gitlab/config:/etc/gitlab \\ -v ~/data/gitlab/logs:/var/log/gitlab \\ -v ~/data/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce 等待几分钟之后，通过网站访问gitlab，用户名为admin，密码挂载在/Users/cengdong/data/gitlab/config目录下\n修改gitlab配置 编辑挂载的配置目录：/Users/cengdong/data/gitlab/config/gitlab.rb\ngitlab的配置项非常多，只修改一项就能满足基本需求：external_url 'http://192.168.184.9'\n重启容器docker restart gitlab或者进入容器通过gitlab-ctl reconfigure命令使配置生效\n通过docker安装gitlab-runner gitlab-runner不建议与gitlab安装在同一台服务器上\n挂载容器运行时以及配置文件 1 2 3 4 docker run -d --name gitlab-runner --restart always \\ -v ~/data/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner 非交互式注册runner 有三种类型的runner：shared、group、specific\n全局类型runner所有人都能用，组类型runner只有组内人能用，特殊runner只有当前项目能用\n在不同地方的settings-\u0026gt;cicd中可以查看不同的token\nrunner有很多类型的执行器，常用的有shell、docker、k8s，通过--execuotr参数指定\n1 2 3 4 5 6 7 8 9 10 docker run --rm -v ~/data/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \\ --non-interactive\\ --executor \u0026#34;docker\u0026#34; \\ --docker-image alpine\u0026#34;latest \\ --url \u0026#34;http://192.168.184.9\u0026#34; \\ --registeration-token \u0026#34;your token\u0026#34; \\ --description \u0026#34;test \\ --tag-list \u0026#34;build\u0026#34; \\ --run-untagged=\u0026#34;true\u0026#34; \\ --locked=\u0026#34;false\u0026#34; 修改gitlab-runner配置 修改～/data/gitlab-runner/config/config.toml文件concurrent = 10\nconcurrent控制一个stage能最多同时执行多少个job，默认为1的情况下如果一个stage有多个job无法并发执行\n在[runners.docker]项下面添加pull_policy = if-not-present，否则每次都需要拉取镜像\n运行流水线 现在，你可以愉快的运行流水线了。通过创建或者导入项目，在项目的根目录下创建.gitlab-ci.yml文件\n通过pipeline语法控制流水线的流程\n","date":"2024-03-28T04:20:36+08:00","permalink":"https://www.cengdong.store/p/devopsgitlabci%E5%AE%9E%E8%B7%B5/","title":"【Devops】GitLabCI实践"},{"content":"1. 听力短句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 August is coming to an end. 八月就要结束了。 How old is this temple? 这座寺庙有多古老？ Please don\u0026#39;t call me after ten 请不要在十点以后给我打电话！ You are going to wait for a little bit. 你要稍微等一下。 The boy didn\u0026#39;t change his mind. 男孩没有改变他的想法。 I\u0026#39;m sorry, but I can\u0026#39;t accept such an expensive gift. 对不起，我不能接受这么贵重的礼物。 On Thursday we went to the poor. 周四，我们去了游泳池。 Monday Tuesday Wednesday Thursday Friday Saturday Sunday I\u0026#39;m talking to a friend. 我正在和朋友谈话。 Your plan is good, but my is better. 你的计划不错，但我的更好。 I fell into a trap. 我掉进了一个陷阱。 trap：陷阱 Cut the cake with this knife. 用这把刀切蛋糕。 knife：刀 It may sound strange, but it is true. 这听起来很奇怪，但他是真的。 He doesn\u0026#39;t know anything yet. 他还什么都不知道。 He is thinking about something else. 他在思考其他的事情。 The room is clean and comfortable. 房间整洁又舒适。 We\u0026#39;ll make our announcement on Thursday. 我们将在周四宣布。 announcement：宣布，声明 Have you chosen a name for the baby？ 你为孩子起好名字了吗？ chosen/choice：选择 Have you forgotten about your promise? 你忘记你的承诺了吗？promise：承诺 propose：求婚 Tom was blindfolded and taken out of the house. 汤姆被蒙上眼睛，带出了房子。 blind：失明 blindfold：被遮住 A short walk will bring you to the station. 走一小段路你就能到达车站。 2. 学到的知识点 生词： temple：寺庙 trap：陷阱 announcement: 宣布、声明 blindfold：被遮住 短语： fell into: 掉进 fell into love with：爱上某人 wait for a little bit：等一会儿 ","date":"2023-09-30T22:44:05+08:00","permalink":"https://www.cengdong.store/p/english%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0day1/","title":"【English】英语学习Day1"},{"content":"1. go-zero分布式锁实现 看下go-zero中redis分布式锁的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 var ( lockScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;PX\u0026#34;, ARGV[2]) return \u0026#34;OK\u0026#34; else return redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;NX\u0026#34;, \u0026#34;PX\u0026#34;, ARGV[2]) end`) delScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) else return 0 end`) ) 加锁和解锁的过程都是通过lua脚本实现的，因为lua脚本能够保证redis的原子性。\n2. 分布式锁必须拥有的属性 排他性(只能有一个协程持有) 可重入(已经获取锁的协程能再次访问) 防死锁(必须有超时时间，达到后持有者自动释放) 高性能高可用 3. go-zero分布式锁加锁流程 1 2 3 4 5 6 7 8 # 判断ARGV[1]是否等于KEY[1]的值 # 如果相等，说明是该锁的持有者重入，更新锁的过期时间，返回OK # 如果不想等，说明锁不存在或者该用户不是锁的持有者，用set nx px命令操作该key lockScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;PX\u0026#34;, ARGV[2]) return \u0026#34;OK\u0026#34; else return redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;NX\u0026#34;, \u0026#34;PX\u0026#34;, ARGV[2]) 4. go-zero分布式锁解锁流程 1 2 3 4 5 6 7 # 判断ARGV[1]是否等于KEY[1]的值 # 如果相等，说明是锁的拥有者，删除分布式锁的KEY # 如果不想等，说明不是锁的拥有者，返回0 delScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) else return 0 ","date":"2023-09-28T09:30:39+08:00","permalink":"https://www.cengdong.store/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","title":"【分布式锁】利用Redis实现分布式锁"},{"content":"1. 起因 最近在学习go-zero，用go-zero自带的sqlx+sqlc操作数据库。因为sqlx+sqlc不会像gorm一样自动管理软删除字段，所以对表结构进行重新的设计。 下面是新的表结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT \u0026#39;用户id\u0026#39;, `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT \u0026#39;用户名\u0026#39;, `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT \u0026#39;密码\u0026#39;, `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, `delete_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;删除时间\u0026#39;, `is_delete` tinyint unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;是否被删除\u0026#39;, `version` bigint unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;版本号\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `idx_username` (`username`,`is_delete`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=\u0026#39;用户记录\u0026#39;; 业务上需要username上这个唯一索引，同时当业务需要删除数据时只能软删除，方便数据溯源与恢复。\n2. 遇到的问题 当时只考虑到业务语义上username需要唯一索引，写完代码后用postman进行测试，插入一条数据，再删除这条数据。再插入一条相同用户名的数据时， 接口报错唯一索引冲突。参考go-zero微信群的建议，给软删除字段is_delete也加上唯一索引。插入一条数据，再删除这条数据。再插入一条相同用户名的数据， 再删除这条数据时，接口还是报错唯一索引冲突。\n3. 再加索引 群里立马又有大佬说还需要给删除时间加上唯一索引，因为删除时业务上会把删除时间更新为当前时间，不会有冲突。一顿操作下来，就给三个字段加上了唯一索引。 个人感觉这个索引还是有点大，又去网上找了不少相关博客。首先确定的是：\n有唯一索引需要的字段必须加上唯一索引，不能因为业务上有校验就删除该索引。 同时删除数据时应该使用软删除。 但是有一点可以优化，就是标记软删除的字段不必只是0和1，当删除数据时，更新该字段为该记录的主键值。 4. 又遇到问题 因为go-zero的数据库操作代码是靠代码生成的，会根据索引字段自动生成方法名，当有唯一索引需求是，自动生成的方法名会带上索引的所有字段，包括 软删除字段，方法名格外尴尬不说，内部生成的代码还多判断了一次is_delete = 0，请教了looklook项目作者，这种需要fork go-zero源代码再自己进行魔改。\n","date":"2023-09-28T08:37:51+08:00","permalink":"https://www.cengdong.store/p/mysql%E8%A7%A3%E5%86%B3%E8%BD%AF%E5%88%A0%E9%99%A4%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/","title":"【MySQL】解决软删除中的唯一索引问题"},{"content":"1. 需求 需要把mysql的数据聚合同步到es以提供海量数据检索能力\n2. 解决方案 变更mysql数据时同步调用es的api 变更mysql数据时异步调用es的api(先发送消息到消息队列，搜索微服务调用es的api消费数据) canal监听mysql的binlog日志，再同步到es flink-cdc监听mysql的binlog日志同步到es 3. 选用方案 最终选择flink-cdc的方案，一是go-canal的仓库不活跃，就三个issue，提了bug也没人修，而且后续可能有实时分析的大数据需求，本身就有flink集群的需求。 二是canal的release版本要最近才会更新，最后一次更新是21年4月，害怕烂尾。三是俺尝试部署canal，最后失败了💦。\n4. 部署环境 选用docker-compose部署mysql、link与elasticsearch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 version: \u0026#39;3\u0026#39; services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.17.13 container_name: elasticsearch user: root environment: - discovery.type=single-node - \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34; - TZ=Asia/Shanghai volumes: - ./data/elasticsearch/data:/usr/share/elasticsearch/data restart: always ports: - \u0026#34;9200:9200\u0026#34; - \u0026#34;9300:9300\u0026#34; networks: - douyin_net kibana: image: docker.elastic.co/kibana/kibana:7.17.13 container_name: kibana environment: - elasticsearch.hosts=http://elasticsearch:9200 - TZ=Asia/Shanghai restart: always networks: - douyin_net ports: - \u0026#34;5601:5601\u0026#34; depends_on: - elasticsearch mysql: image: mysql:latest container_name: mysql environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: my-secret-pw ports: - \u0026#34;3306:3306\u0026#34; volumes: # 数据挂载 - Data mounting - ./data/mysql/data:/var/lib/mysql - ./data/mysql/my.cnf:/etc/my.cnf privileged: true restart: always networks: - douyin_net jobmanager: image: flink:latest container_name: jobmanager expose: - \u0026#34;6123\u0026#34; ports: - \u0026#34;8081:8081\u0026#34; command: jobmanager environment: - TZ=Asia/Shanghai - JOB_MANAGER_RPC_ADDRESS=jobmanager restart: always networks: - douyin_net taskmanager: image: flink:latest container_name: taskmanager expose: - \u0026#34;6121\u0026#34; - \u0026#34;6122\u0026#34; depends_on: - jobmanager command: taskmanager environment: - JOB_MANAGER_RPC_ADDRESS=jobmanager - TZ=Asia/Shanghai restart: always networks: - douyin_net networks: douyin_net: driver: bridge ipam: config: - subnet: 172.16.0.0/16 其中mysql挂载的配置文件内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [mysqld] skip-host-cache skip-name-resolve datadir=/var/lib/mysql socket=/var/run/mysqld/mysqld.sock secure-file-priv=/var/lib/mysql-files user=mysql log-bin=mysql-bin binlog-format=ROW server_id=66 pid-file=/var/run/mysqld/mysqld.pid [client] socket=/var/run/mysqld/mysqld.sock !includedir /etc/mysql/conf.d/ 主要是为了开启binlog\n5. 配置 先启动集群\n1 docker-compose up -d 检查binlog是否开启\n1 2 3 docker exec mysql -uroot -pmy-secret-pw show variables like \u0026#39;log_bin\u0026#39;; show variables like \u0026#39;binlog_format\u0026#39;; 下载mysql、es的connector并拷贝到容器内部\nflink-sql-connector-elasticsearch7-3.0.1-1.17.jar flink-sql-connector-mysql-cdc-2.4.1.jar 1 2 3 docker cp ./flink-sql-connector-elasticsearch7-3.0.1-1.17.jar jobmanager:/opt/flink/lib/ docker cp ./flink-sql-connector-mysql-cdc-2.4.1.jar jobmanager:/opt/flink/lib/ docker restart jobmanager 6. 测试 进入mysql容器/连接mysql创建mysql数据库表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE DATABASE mydb; USE mydb; CREATE TABLE orders ( order_id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, order_date DATETIME NOT NULL, customer_name VARCHAR(255) NOT NULL, price DECIMAL(10, 5) NOT NULL, product_id INTEGER NOT NULL, order_status BOOLEAN NOT NULL -- Whether order has been placed ) AUTO_INCREMENT = 10001; INSERT INTO orders VALUES (default, \u0026#39;2020-07-30 10:08:22\u0026#39;, \u0026#39;Jark\u0026#39;, 50.50, 102, false), (default, \u0026#39;2020-07-30 10:11:09\u0026#39;, \u0026#39;Sally\u0026#39;, 15.00, 105, false), (default, \u0026#39;2020-07-30 12:00:30\u0026#39;, \u0026#39;Edward\u0026#39;, 25.25, 106, false); 进入jobmanager容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 docker exec -it jobmanager /bin/bash cd bin \u0026amp;\u0026amp; ./sql-client.sh SET execution.checkpointing.interval = 3s; CREATE TABLE orders ( order_id INT, order_date TIMESTAMP(0), customer_name STRING, price DECIMAL(10, 5), product_id INT, order_status BOOLEAN, PRIMARY KEY (order_id) NOT ENFORCED ) WITH ( \u0026#39;connector\u0026#39; = \u0026#39;mysql-cdc\u0026#39;, \u0026#39;hostname\u0026#39; = \u0026#39;192.168.2.248\u0026#39;, \u0026#39;port\u0026#39; = \u0026#39;3306\u0026#39;, \u0026#39;username\u0026#39; = \u0026#39;root\u0026#39;, \u0026#39;password\u0026#39; = \u0026#39;my-secret-pw\u0026#39;, \u0026#39;database-name\u0026#39; = \u0026#39;mydb\u0026#39;, \u0026#39;table-name\u0026#39; = \u0026#39;orders\u0026#39; ); CREATE TABLE es_orders ( order_id INT, order_date TIMESTAMP(0), customer_name STRING, price DECIMAL(10, 5), product_id INT, order_status BOOLEAN, PRIMARY KEY (order_id) NOT ENFORCED ) WITH ( \u0026#39;connector\u0026#39; = \u0026#39;elasticsearch-7\u0026#39;, \u0026#39;hosts\u0026#39; = \u0026#39;http://192.168.2.248:9200\u0026#39;, \u0026#39;index\u0026#39; = \u0026#39;orders\u0026#39; ); INSERT INTO es_orders SELECT * FROM orders; 访问kibana查询es数据\n1 2 3 4 5 6 GET orders/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;: {} } } ","date":"2023-09-20T22:34:29+08:00","permalink":"https://www.cengdong.store/p/flink%E5%88%A9%E7%94%A8flink-cdc%E5%90%8C%E6%AD%A5mysql%E6%95%B0%E6%8D%AE%E5%88%B0es/","title":"【Flink】利用flink Cdc同步mysql数据到es"},{"content":"1. 遇到的问题：上传文件到阿里云Oss失败，通过日志定位到是Linux系统时间不正确 2. 解决方案 1 2 3 4 5 timedatectl set-timezone Asia/Shanghai sudo yum -y install ntp ntpdate pool.ntp.org systemctl start ntpd systemctl enable ntpd ","date":"2023-09-15T02:58:36+08:00","permalink":"https://www.cengdong.store/p/linuxcentos7%E8%A7%A3%E5%86%B3%E6%97%B6%E9%97%B4%E4%B8%8D%E6%AD%A3%E7%A1%AE%E9%97%AE%E9%A2%98/","title":"【Linux】Centos7解决时间不正确问题"},{"content":"1. 环境准备 M1 Mac Vmware Fusion Tech Preview 终端连接工具Termius Centos7虚拟机三台，内存都为4G，磁盘30G，线程数为4 master: 192.168.2.3 node-1: 192.168.2.4 node-2: 192.168.2.5 2. 修改主机名 在三台节点上都执行\n1 2 3 4 5 cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF 192.168.2.3 master 192.168.2.4 node-1 192.168.2.5 node-2 EOF 1 2 3 4 5 6 # master上执行 hostnamectl set-hostname master # node-1上执行 hostnamectl set-hostname node-1 # node-2上执行 hostnamectl set-hostname node-2 3. 关闭selinux、swap 1 2 3 4 5 6 swapoff -a sed -i \u0026#39;s/enforcing/disabled/\u0026#39; /etc/selinux/config setenforce 0 echo \u0026#34;net.bridge.bridge-nf-call-iptables = 1 \u0026#34;\u0026gt;\u0026gt;/etc/sysctl.d/k8s.conf echo \u0026#34;net.bridge.bridge-nf-call-ip6tables = 1 \u0026#34;\u0026gt;\u0026gt;/etc/sysctl.d/k8s.conf sysctl --system 4. ipvs安装 1 2 3 4 modprobe br_netfilter echo 1 \u0026gt; /proc/sys/net/bridge/bridge-nf-call-iptables echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward lsmod | grep br_netfilter 1 yum -y install ipset ipvsadm 1 2 3 4 5 6 7 cat \u0026gt; /etc/sysconfig/modules/ipvs.modules \u0026lt;\u0026lt;EOF modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack EOF 1 chmod a+x /etc/sysconfig/modules/ipvs.modules 执行脚本 /etc/sysconfig/modules/ipvs.modules\n验证ipvs模块 lsmod | grep -e ip_vs -e nf_conntrack_ipv4\n1 2 3 4 5 # 执行脚本 /etc/sysconfig/modules/ipvs.modules # 验证ipvs模块 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 1 2 3 4 cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/modules-load.d/containerd.conf overlay br_netfilter EOF 1 2 modprobe overlay modprobe br_netfilter 5. 安装docker 1 2 3 4 5 6 7 yum install -y yum-utils yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo yum install docker-ce-19.03.5 docker-ce-cli-19.03.5 systemctl enable docker systemctl start docker 配置docker\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/docker/daemon.json { \u0026#34;insecure-registries\u0026#34;:[\u0026#34;47.99.140.12:8077\u0026#34;], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://l10nt4hq.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; ] } EOF #重新加载服务的配置文件 systemctl daemon-reload #重启docker systemctl restart docker systemctl status docker.service 6. 配置k8s源 1 2 3 4 5 6 7 8 9 10 11 12 13 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-aarch64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF yum clean all yum makecache 7. 安装kubeadm、kubectl、kubelet 1 2 3 4 5 yum install -y kubeadm-1.23.3-0 kubectl-1.23.3-0 kubelet-1.23.3-0 --disableexcludes=kubernetes # 只在master节点执行 systemctl enable kubelet systemctl start kubelet 8. master节点加入K8s集群 1 kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.23.3 --apiserver-advertise-address 192.168.2.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.1.0.0/16 9. master节点部署flannel网络 1 2 3 4 tar zxvf cni-plugins-linux-arm-v0.8.6.tgz cp flannel /opt/cni/bin chmod 777 /opt/cni/bin/flannel kubectl apply -f kube-flannel.yml 10. node节点加入k8s集群 1 2 kubeadm join 192.168.2.2:6443 --token uxohvw.84c30cwr4g6t8he8 \\ --discovery-token-ca-cert-hash sha256:cc7e139e28e61db426dc91a3ecccc0a72f26b09af6dfd12c6171d58f4359c0e5 token失效后重新生成\n1 2 3 4 5 kubeadm token create # master 执行 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u0026gt;/dev/null | openssl dgst -sha256 -hex | sed \u0026#39;s/^.* //\u0026#39; 11. node节点加入flannel网络 1 2 3 4 5 6 7 8 # 子节点上创建文件夹 mkdir -p /etc/cni/net.d # master节点拷贝文件到node节点 scp /etc/cni/net.d/10-flannel.conflist root@192.168.2.3:/etc/cni/net.d systemctl daemon-reload systemctl restart kubelet ","date":"2023-08-28T19:51:03+08:00","permalink":"https://www.cengdong.store/p/kubernetesarm%E6%9E%B6%E6%9E%84centos7%E9%80%9A%E8%BF%87kubeadm%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/","title":"【Kubernetes】arm架构Centos7通过kubeadm安装k8s集群"},{"content":"1. 起因 最近在学习go-zero框架，把faker-douyin项目重构成微服务项目。在重构的过程中有一些变动：\n原来使用本地虚拟机构建服务中间件依赖，现在使用阿里云的服务 原来上传视频时直接通过ftp上传到虚拟机，现在直接上传到阿里云oss 在代码上传github上之后，阿里云发现我的accessKey在github上泄漏（主要是我安全意识不好）\n2. 解决办法 使用.gitignore文件使git忽视配置文件上传 在.gitignore文件中添加.yaml忽视所有yaml类型文件 3. 遇到问题 更改.gitignore文件之后，本地仓库没有生效（没有删除gitignore文件匹配的文件）\n4. 解决办法 1 2 3 4 git rm --cached -r . git add . git commit -am \u0026#39;注释\u0026#39; git push ","date":"2023-08-12T15:00:13+08:00","permalink":"https://www.cengdong.store/p/git%E6%B7%BB%E5%8A%A0gitignore%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E5%88%A0%E9%99%A4github%E4%B8%8A%E5%A4%9A%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6/","title":"【Git】添加gitignore文件之后删除github上多上传的文件"},{"content":"1. 介绍 RabbitMQ is the most widely deployed open source message broker.\n直接把RabbitMQ官网的介绍抄过来：它是部署最广泛的消息代理\n2. 作用 消息代理中间件的作用：\n削峰：大量请求写入消息中间件，服务器按照自己能力去消费 解耦：服务上游与下游解耦，上游只需把请求写入消息代理，下游只需要去消息中间件消费 异步：实时性不高的功能放入代理，快速响应客户端请求 3. 竞品 ActiveMQ(已经寄了) RocketMQ（阿里开源，广泛应用在电商场景） Kafka（大数据利器，日志系统重要组件） 4. 系统架构 生产者：消息发送方 channel：通信信道，一个连接里有多个可用信道（感觉是资源池），生产者和消费者都会与broker建立连接 exchange：交换机，生产者将消息发送给对应交换机（生产者只与交换机打交道），交换机通过routingKey将消息发送给消息队列 queue：消息队列，存放消息的实体 消费者：从消息队列中消费消息 虚拟主机：多租户的资源隔离（不想深入，也不做过多了解） 5. 工作模式 RabbitMQ官方给出了七种工作模式\nHello World Work Queues Publish/Subscribe Routing Topics RPC Publisher confirms 6. 安装RabbitMQ 我的虚拟机已经安装好Docker，通过Docker安装带web可视化插件的RabbitMQ，其中5672是服务端的端口，15672是web可视化的端口\n1 docker run --name rabbit --restart=always -p 15672:15672 -p 5672:5672 -d rabbitmq:management 访问web管理界面，用户名密码都是guest\n7. 创建项目 创建目录：mkdir rabbitmq-demo 初始化项目：go mod init rabbitmq-demo go客户端选用：老规矩，最多star的项目，虽然已经停止维护很久了github.com/streadway/amqp 8. 发送消息：以简单模式为例 简单模式就是点对点的消息传输模型，官网称之为Hello World模式。生产者发送消息给指定队列，消费者从指定队列消费消息，其中生产者以及消费者都绑定的是默认交换机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; ) const url = \u0026#34;amqp://guest:guest@192.168.18.3:5672/\u0026#34; func main() { // 连接服务器 conn, err := amqp.Dial(url) if err != nil { fmt.Println(err) } defer conn.Close() // 获取channel channel, err := conn.Channel() defer channel.Close() if err != nil { fmt.Println(err) } // 声明队列 queue, err := channel.QueueDeclare(\u0026#34;test\u0026#34;, false, false, false, false, nil) if err != nil { fmt.Println(err) } // 发布消息 err = channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(\u0026#34;hello world\u0026#34;)}) if err != nil { fmt.Println(err) } } 9. 接受消息：以简单模式为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; ) const rabbit_url = \u0026#34;amqp://guest:guest@192.168.18.3:5672/\u0026#34; func main() { // 链接服务器 conn, err := amqp.Dial(rabbit_url) if err != nil { fmt.Println(err) } defer conn.Close() // 建立链接 channel, err := conn.Channel() if err != nil { fmt.Println(err) } defer channel.Close() // 声明队列 queue, err := channel.QueueDeclare(\u0026#34;test\u0026#34;, false, false, false, false, nil) if err != nil { fmt.Println(err) } // 消费消息 msg, err := channel.Consume(queue.Name, \u0026#34;\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } // 遍历管道，读取消息 for d := range msg { fmt.Println(string(d.Body)) } } 10. 如何保障消息不丢失 10.1 消息应答机制 RabbitMQ有两种消息应答机制：自动应答和手动应答，自动应答即NOACK，不需要接收方回应ACK消息，默认是这种应答方式。要开启手动应答，首先要把channel.Consume方法的第三个参数设置为false\n1 func (ch *Channel) Consume(queue, consumer string, autoAck, exclusive, noLocal, noWait bool, args Table) (\u0026lt;-chan Delivery, error) 还需要在消费消息时调用Ack或Reject或Nack方法\n1 func (d Delivery) Ack(multiple bool) error 10.2 消息持久化 要保障消息不丢失，就要保障消息的持久化，避免服务器故障或重启时内存中的消息丢失。消息持久化分为两部分：队列持久化、消息持久化。\n队列持久化需要在声明队列时把参数durable传为true\n1 func (ch *Channel) QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args Table) (Queue, error) 消息持久化需要在实例化消息时把Publishing结构体的DeliveryMode字段设置为Persistent\n1 2 3 4 5 6 channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ DeliveryMode: amqp.Persistent, ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(\u0026#34;hello world\u0026#34;), } ) 10.3 生产方发布确认 生产方发布确认又叫发布确认模式，是一种保障生产方能确认发布消息到Broker的机制\n要开启发布确认模式需要调用channel.Conform方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Confirm puts this channel into confirm mode so that the client can ensure all publishings have successfully been received by the server. After entering this mode, the server will send a basic.ack or basic.nack message with the deliver tag set to a 1 based incremental index corresponding to every publishing received after the this method returns. Add a listener to Channel.NotifyPublish to respond to the Confirmations. If Channel.NotifyPublish is not called, the Confirmations will be silently ignored. The order of acknowledgments is not bound to the order of deliveries. Ack and Nack confirmations will arrive at some point in the future. Unroutable mandatory or immediate messages are acknowledged immediately after any Channel.NotifyReturn listeners have been notified. Other messages are acknowledged when all queues that should have the message routed to them have either received acknowledgment of delivery or have enqueued the message, persisting the message if necessary. When noWait is true, the client will not wait for a response. A channel exception could occur if the server does not support this method. */ func (ch *Channel) Confirm(noWait bool) error { if err := ch.call( \u0026amp;confirmSelect{Nowait: noWait}, \u0026amp;confirmSelectOk{}, ); err != nil { return err } ch.confirmM.Lock() ch.confirming = true ch.confirmM.Unlock() return nil } 再调用NotifyPublish方法或NotifyConfirm注册发布消息的回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* NotifyConfirm calls NotifyPublish and starts a goroutine sending ordered Ack and Nack DeliveryTag to the respective channels. For strict ordering, use NotifyPublish instead. */ func (ch *Channel) NotifyConfirm(ack, nack chan uint64) (chan uint64, chan uint64) { confirms := ch.NotifyPublish(make(chan Confirmation, cap(ack)+cap(nack))) go func() { for c := range confirms { if c.Ack { ack \u0026lt;- c.DeliveryTag } else { nack \u0026lt;- c.DeliveryTag } } close(ack) if nack != ack { close(nack) } }() return ack, nack } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* NotifyPublish registers a listener for reliable publishing. Receives from this chan for every publish after Channel.Confirm will be in order starting with DeliveryTag 1. There will be one and only one Confirmation Publishing starting with the delivery tag of 1 and progressing sequentially until the total number of Publishings have been seen by the server. Acknowledgments will be received in the order of delivery from the NotifyPublish channels even if the server acknowledges them out of order. The listener chan will be closed when the Channel is closed. The capacity of the chan Confirmation must be at least as large as the number of outstanding publishings. Not having enough buffered chans will create a deadlock if you attempt to perform other operations on the Connection or Channel while confirms are in-flight. It\u0026#39;s advisable to wait for all Confirmations to arrive before calling Channel.Close() or Connection.Close(). */ func (ch *Channel) NotifyPublish(confirm chan Confirmation) chan Confirmation { ch.notifyM.Lock() defer ch.notifyM.Unlock() if ch.noNotify { close(confirm) } else { ch.confirms.Listen(confirm) } return confirm } 11. 工作队列模式 11.1 公平调度的工作队列模式 工作队列模式类似于Kafka的消费者组，为了提高消费者的消费能力。生产者代码与简单模式一致，为了能从命令行控制要发送的消息，做一些改造。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) const url = \u0026#34;amqp://guest:guest@47.99.140.12:5672/\u0026#34; func main() { connection, err := amqp.Dial(url) if err != nil { fmt.Println(err) } defer connection.Close() channel, err := connection.Channel() if err != nil { fmt.Println(err) } defer channel.Close() queue, err := channel.QueueDeclare(\u0026#34;work_queues\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } body := bodyFrom(os.Args) err = channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ ContentType: \u0026#34;text/plain\u0026#34;, DeliveryMode: amqp.Persistent, Body: []byte(body), }) if err != nil { fmt.Println(err) } fmt.Printf(\u0026#34;send msg %s\u0026#34;, body) } func bodyFrom(args []string) string { var s string if len(args) \u0026lt; 2 || os.Args[1] == \u0026#34;\u0026#34; { s = \u0026#34;hello\u0026#34; } else { s = strings.Join(args[1:], \u0026#34; \u0026#34;) } return s } 消费者代码也与简单模式一致，为了能从多个消费者区分差异，对消息做了一些虚假的业务处理（按照消息中字符.的个数睡眠相应秒数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; \u0026#34;time\u0026#34; ) const rabbit_url = \u0026#34;amqp://guest:guest@47.99.140.12:5672/\u0026#34; func main() { connection, err := amqp.Dial(rabbit_url) if err != nil { fmt.Println(err) } defer connection.Close() channel, err := connection.Channel() if err != nil { fmt.Println(err) } defer channel.Close() queue, err := channel.QueueDeclare(\u0026#34;work_queues\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } deliveries, err := channel.Consume(queue.Name, \u0026#34;\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } for delivery := range deliveries { fmt.Printf(\u0026#34;receive work: %s\\n\u0026#34;, delivery.Body) dotCount := bytes.Count(delivery.Body, []byte(\u0026#34;.\u0026#34;)) d := time.Duration(dotCount) time.Sleep(d * time.Second) fmt.Printf(\u0026#34;work done after %d\\n\u0026#34;, d) } } 先分别在两个终端中启动两个消费者\n1 go run receive.go 再启动生产者发送多条消息\n1 2 3 4 5 go run send.go First Message. go run send.go Second Message.. go run send.go Third Message... go run send.go Fourth message.... go run send.go Fifth message..... 生产者 消费者1 消费者2 消费者1消费了消息135，消费者2消费了消息24，这样提高了消费者消费的能力，并且由于工作队列模式默认的消息分发机制是轮询，官网称之为Fair dispatch(公平调度)\n当有多个消费者时，每个消费者的消费能力不一样，轮询的方式会有问题。\n11.2 设置预取值的工作队列方式 为了解决公平调度带来的问题，我们可以将预取计数设置为值1。这告诉RabbitMQ不要一次向一个worker提供多条消息。\n或者，换句话说，在worker处理并确认前一条消息之前，不要向worker发送新消息。相反，它会将其调度给下一个尚未繁忙的工作人员。\n设置预取值需要调用channel.Qos方法\n1 2 3 4 5 6 7 8 9 10 11 # 通常设置 prefetchCount = 1 prefetchSize = 0 global = false func (ch *Channel) Qos(prefetchCount, prefetchSize int, global bool) error { return ch.call( \u0026amp;basicQos{ PrefetchCount: uint16(prefetchCount), PrefetchSize: uint32(prefetchSize), Global: global, }, \u0026amp;basicQosOk{}, ) } ","date":"2023-07-31T00:02:07+08:00","permalink":"https://www.cengdong.store/p/gorabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"【Go】RabbitMQ学习笔记"}]