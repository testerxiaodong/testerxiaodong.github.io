[{"content":"Elasticsearch介绍 Elasticsearch是一个分布式数据存储，能够近实时地导入、索引和管理各种类型的数据，使其既可搜索又可分析。凭借专业的用户界面和工具，它提供了创建、部署和运行各种应用的灵活性，从搜索到分析再到 AI 驱动的解决方案。\n以下是Elasticsearch的使用案例：\n用例 业务目标 技术要求 向量搜索/混合搜索 运行最近邻搜索，结合文本生成混合结果 密集嵌入、稀疏嵌入，结合文本/BM25 电子商务/产品目录搜索 提供快速、相关且最新的结果，分面导航 库存同步、用户行为跟踪、结果缓存 工作场所/知识库搜索 跨数据源搜索，执行权限 第三方连接器、文档级安全、角色映射 网站搜索 提供相关且最新的结果 网页爬取、增量索引、查询缓存 客户支持搜索 呈现相关解决方案，管理访问控制，跟踪指标 知识图谱、基于角色的访问、分析 聊天机器人/RAG 促进自然对话，提供背景，保持知识 矢量搜索、机器学习模型、知识库集成 地理空间搜索 进程位置查询，按距离排序，按区域筛选 地理映射、空间索引、距离计算 最近工作内容和Elasticsearch相关，包括Elasticsearch查询压测以及性能优化，因此写一篇博客记录一下相关知识点。\n索引基础 索引是Elasticsearch中存储的基本单位。它是一组通过名字或别名唯一标识的文件。这个唯一名称很重要，因为它用于搜索查询和其他作中针对该索引。\n索引由以下组成部分组成：\nDocuments(文档) Metadata fields(元数据字段) Mappings and data types(映射与数据类型) Documents Elasticsearch以JSON文档的形式序列化和存储数据。文档是一组字段，这些字段是包含你数据的键值对。每个文档都有唯一的ID，你可以创建ID，也可以让Elasticsearch自动生成。\n一个简单的 Elasticsearch 文档可能如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;_index\u0026#34;: \u0026#34;my-first-elasticsearch-index\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;DyFpo5EBxE8fzbb95DOa\u0026#34;, \u0026#34;_version\u0026#34;: 1, \u0026#34;_seq_no\u0026#34;: 0, \u0026#34;_primary_term\u0026#34;: 1, \u0026#34;found\u0026#34;: true, \u0026#34;_source\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;john@smith.com\u0026#34;, \u0026#34;first_name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;info\u0026#34;: { \u0026#34;bio\u0026#34;: \u0026#34;Eco-warrior and defender of the weak\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;interests\u0026#34;: [ \u0026#34;dolphins\u0026#34;, \u0026#34;whales\u0026#34; ] }, \u0026#34;join_date\u0026#34;: \u0026#34;2024/05/01\u0026#34; } } Metadata fields 索引文档包含数据和元数据。 元数据字段是存储文档信息的系统字段。在 Elasticsearch 中，元数据字段前加下划线。例如，以下字段是元数据字段：\n_index：文档存储的索引名称。 _id：文档的 ID。ID 必须在每个索引中唯一。 Mappings and data types 每个索引都有一个mapping或schema，用于描述文档中字段的索引方式。映射定义了每个字段的数据类型 、字段应如何索引以及存储方式。\n创建索引 1 PUT /books 添加单一文档 请使用以下请求将单一文档添加到图书索引中。如果索引还不存在，这个请求会自动生成它。\n1 2 3 4 5 6 7 POST books/_doc { \u0026#34;name\u0026#34;: \u0026#34;Snow Crash\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Neal Stephenson\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;1992-06-01\u0026#34;, \u0026#34;page_count\u0026#34;: 470 } 添加多份文档 1 2 3 4 5 6 7 8 9 10 11 POST /_bulk { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;books\u0026#34; } } {\u0026#34;name\u0026#34;: \u0026#34;Revelation Space\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Alastair Reynolds\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;2000-03-15\u0026#34;, \u0026#34;page_count\u0026#34;: 585} { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;books\u0026#34; } } {\u0026#34;name\u0026#34;: \u0026#34;1984\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;George Orwell\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;1985-06-01\u0026#34;, \u0026#34;page_count\u0026#34;: 328} { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;books\u0026#34; } } {\u0026#34;name\u0026#34;: \u0026#34;Fahrenheit 451\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Ray Bradbury\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;1953-10-15\u0026#34;, \u0026#34;page_count\u0026#34;: 227} { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;books\u0026#34; } } {\u0026#34;name\u0026#34;: \u0026#34;Brave New World\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Aldous Huxley\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;1932-06-01\u0026#34;, \u0026#34;page_count\u0026#34;: 268} { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;books\u0026#34; } } {\u0026#34;name\u0026#34;: \u0026#34;The Handmaids Tale\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Margaret Atwood\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;1985-06-01\u0026#34;, \u0026#34;page_count\u0026#34;: 311} QueryDSL 全文搜索需要的是_search API 和 Query DSL\n先创建索引\n1 PUT /cooking_blog 创建映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 PUT /cooking_blog/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;standard\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;keyword\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;ignore_above\u0026#34;: 256 } } }, \u0026#34;description\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;keyword\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, \u0026#34;author\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;keyword\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, \u0026#34;date\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;yyyy-MM-dd\u0026#34; }, \u0026#34;category\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;keyword\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, \u0026#34;tags\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;keyword\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; } } }, \u0026#34;rating\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;float\u0026#34; } } } 批量添加数据\n1 2 3 4 5 6 7 8 9 10 11 POST /cooking_blog/_bulk?refresh=wait_for {\u0026#34;index\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;1\u0026#34;}} {\u0026#34;title\u0026#34;:\u0026#34;Perfect Pancakes: A Fluffy Breakfast Delight\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;Learn the secrets to making the fluffiest pancakes, so amazing you won\u0026#39;t believe your tastebuds. This recipe uses buttermilk and a special folding technique to create light, airy pancakes that are perfect for lazy Sunday mornings.\u0026#34;,\u0026#34;author\u0026#34;:\u0026#34;Maria Rodriguez\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2023-05-01\u0026#34;,\u0026#34;category\u0026#34;:\u0026#34;Breakfast\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;pancakes\u0026#34;,\u0026#34;breakfast\u0026#34;,\u0026#34;easy recipes\u0026#34;],\u0026#34;rating\u0026#34;:4.8} {\u0026#34;index\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;2\u0026#34;}} {\u0026#34;title\u0026#34;:\u0026#34;Spicy Thai Green Curry: A Vegetarian Adventure\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;Dive into the flavors of Thailand with this vibrant green curry. Packed with vegetables and aromatic herbs, this dish is both healthy and satisfying. Don\u0026#39;t worry about the heat - you can easily adjust the spice level to your liking.\u0026#34;,\u0026#34;author\u0026#34;:\u0026#34;Liam Chen\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2023-05-05\u0026#34;,\u0026#34;category\u0026#34;:\u0026#34;Main Course\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;thai\u0026#34;,\u0026#34;vegetarian\u0026#34;,\u0026#34;curry\u0026#34;,\u0026#34;spicy\u0026#34;],\u0026#34;rating\u0026#34;:4.6} {\u0026#34;index\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;3\u0026#34;}} {\u0026#34;title\u0026#34;:\u0026#34;Classic Beef Stroganoff: A Creamy Comfort Food\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;Indulge in this rich and creamy beef stroganoff. Tender strips of beef in a savory mushroom sauce, served over a bed of egg noodles. It\u0026#39;s the ultimate comfort food for chilly evenings.\u0026#34;,\u0026#34;author\u0026#34;:\u0026#34;Emma Watson\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2023-05-10\u0026#34;,\u0026#34;category\u0026#34;:\u0026#34;Main Course\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;beef\u0026#34;,\u0026#34;pasta\u0026#34;,\u0026#34;comfort food\u0026#34;],\u0026#34;rating\u0026#34;:4.7} {\u0026#34;index\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;4\u0026#34;}} {\u0026#34;title\u0026#34;:\u0026#34;Vegan Chocolate Avocado Mousse\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;Discover the magic of avocado in this rich, vegan chocolate mousse. Creamy, indulgent, and secretly healthy, it\u0026#39;s the perfect guilt-free dessert for chocolate lovers.\u0026#34;,\u0026#34;author\u0026#34;:\u0026#34;Alex Green\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2023-05-15\u0026#34;,\u0026#34;category\u0026#34;:\u0026#34;Dessert\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;vegan\u0026#34;,\u0026#34;chocolate\u0026#34;,\u0026#34;avocado\u0026#34;,\u0026#34;healthy dessert\u0026#34;],\u0026#34;rating\u0026#34;:4.5} {\u0026#34;index\u0026#34;:{\u0026#34;_id\u0026#34;:\u0026#34;5\u0026#34;}} {\u0026#34;title\u0026#34;:\u0026#34;Crispy Oven-Fried Chicken\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;Get that perfect crunch without the deep fryer! This oven-fried chicken recipe delivers crispy, juicy results every time. A healthier take on the classic comfort food.\u0026#34;,\u0026#34;author\u0026#34;:\u0026#34;Maria Rodriguez\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2023-05-20\u0026#34;,\u0026#34;category\u0026#34;:\u0026#34;Main Course\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;chicken\u0026#34;,\u0026#34;oven-fried\u0026#34;,\u0026#34;healthy\u0026#34;],\u0026#34;rating\u0026#34;:4.9} match 单字段查询 match query是全文搜索的标准查询。查询文本将根据每个字段（或查询时）指定的分析器配置进行分析。\n1 2 3 4 5 6 7 8 9 10 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;description\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;fluffy pancakes\u0026#34; } } } } 包含查询中所有匹配的术语 指定and算符，使描述字段包含这两个术语。这种更严格的搜索对样本数据没有结果 ，因为没有文档同时包含“fluffy”和“pancakes”\n1 2 3 4 5 6 7 8 9 10 11 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;description\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;fluffy pancakes\u0026#34;, \u0026#34;operator\u0026#34;: \u0026#34;and\u0026#34; } } } } 指定匹配的最低词数 使用minimum_should_match参数指定文档搜索结果中应包含的最少词数\n1 2 3 4 5 6 7 8 9 10 11 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;fluffy pancakes breakfast\u0026#34;, \u0026#34;minimum_should_match\u0026#34;: 2 } } } } multi_match 跨多个字段搜索 当你输入搜索查询时，可能不知道搜索词是否出现在某个特定字段中。multi_match查询可以让你同时搜索多个字段。\n1 2 3 4 5 6 7 8 9 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;vegetarian curry\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;title\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;tags\u0026#34;] } } } 使用字段增强来调整每个字段的重要性 1 2 3 4 5 6 7 8 9 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;vegetarian curry\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;title^3\u0026#34;, \u0026#34;description^2\u0026#34;, \u0026#34;tags\u0026#34;] } } } filter 筛选查询 filter查询是bool查询的子查询\n1 2 3 4 5 6 7 8 9 10 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;filter\u0026#34;: [ { \u0026#34;term\u0026#34;: { \u0026#34;category.keyword\u0026#34;: \u0026#34;Breakfast\u0026#34; } } ] } } } range 范围查询 1 2 3 4 5 6 7 8 9 10 11 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;date\u0026#34;: { \u0026#34;gte\u0026#34;: \u0026#34;2023-05-01\u0026#34;, \u0026#34;lte\u0026#34;: \u0026#34;2023-05-31\u0026#34; } } } } term 查询找到完全匹配的 1 2 3 4 5 6 7 8 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;author.keyword\u0026#34;: \u0026#34;Maria Rodriguez\u0026#34; } } } 结合多个搜索条件 你可以用bool查询组合多个查询子句，创建复杂的搜索。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 GET /cooking_blog/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ { \u0026#34;term\u0026#34;: { \u0026#34;tags\u0026#34;: \u0026#34;vegetarian\u0026#34; } }, { \u0026#34;range\u0026#34;: { \u0026#34;rating\u0026#34;: { \u0026#34;gte\u0026#34;: 4.5 } } } ], \u0026#34;should\u0026#34;: [ { \u0026#34;term\u0026#34;: { \u0026#34;category.keyword\u0026#34;: \u0026#34;Main Course\u0026#34; } }, { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;curry spicy\u0026#34;, \u0026#34;fields\u0026#34;: [ \u0026#34;title^2\u0026#34;, \u0026#34;description\u0026#34; ] } }, { \u0026#34;range\u0026#34;: { \u0026#34;date\u0026#34;: { \u0026#34;gte\u0026#34;: \u0026#34;now-1M/d\u0026#34; } } } ], \u0026#34;must_not\u0026#34;: [ { \u0026#34;term\u0026#34;: { \u0026#34;category.keyword\u0026#34;: \u0026#34;Dessert\u0026#34; } } ] } } } Compound queries 复合查询 boolean query 由一个或多个布尔子句构建，每个子句都带有类型出现。发生类型包括\nmust must_not should filter 其中must和should对得分有影响，不会被缓存。must_not和filter对得分没影响，会被缓存。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 POST _search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34; : { \u0026#34;must\u0026#34; : { \u0026#34;term\u0026#34; : { \u0026#34;user.id\u0026#34; : \u0026#34;kimchy\u0026#34; } }, \u0026#34;filter\u0026#34;: { \u0026#34;term\u0026#34; : { \u0026#34;tags\u0026#34; : \u0026#34;production\u0026#34; } }, \u0026#34;must_not\u0026#34; : { \u0026#34;range\u0026#34; : { \u0026#34;age\u0026#34; : { \u0026#34;gte\u0026#34; : 10, \u0026#34;lte\u0026#34; : 20 } } }, \u0026#34;should\u0026#34; : [ { \u0026#34;term\u0026#34; : { \u0026#34;tags\u0026#34; : \u0026#34;env1\u0026#34; } }, { \u0026#34;term\u0026#34; : { \u0026#34;tags\u0026#34; : \u0026#34;deployed\u0026#34; } } ], \u0026#34;minimum_should_match\u0026#34; : 1, \u0026#34;boost\u0026#34; : 1.0 } } } Boosting query 提升positive或者降低negative相关性得分，可以使用提升查询来降级某些文档，同时不排除它们在搜索结果中。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET /_search { \u0026#34;query\u0026#34;: { \u0026#34;boosting\u0026#34;: { \u0026#34;positive\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;apple\u0026#34; } }, \u0026#34;negative\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;pie tart fruit crumble tree\u0026#34; } }, \u0026#34;negative_boost\u0026#34;: 0.5 } } } Constant score query 对filter query进行封装，返回所有相关性评分等于boost参数值的匹配文档\n示例查询：\n1 2 3 4 5 6 7 8 9 10 11 GET /_search { \u0026#34;query\u0026#34;: { \u0026#34;constant_score\u0026#34;: { \u0026#34;filter\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;user.id\u0026#34;: \u0026#34;kimchy\u0026#34; } }, \u0026#34;boost\u0026#34;: 1.2 } } } Disjunction max query 返回匹配一个或多个包裹查询的文档，称为查询子句或子句。\n如果返回的文档匹配多个查询子句，dis_max query将赋予该文档任何匹配子句中最高的相关性分数，并对任何额外的匹配子查询加成平局破坏分数。\n示例查询：\n1 2 3 4 5 6 7 8 9 10 11 12 GET /_search { \u0026#34;query\u0026#34;: { \u0026#34;dis_max\u0026#34;: { \u0026#34;queries\u0026#34;: [ { \u0026#34;term\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Quick pets\u0026#34; } }, { \u0026#34;term\u0026#34;: { \u0026#34;body\u0026#34;: \u0026#34;Quick pets\u0026#34; } } ], \u0026#34;tie_breaker\u0026#34;: 0.7 } } } 查询参数：\nqueries tie_breaker Function score query function_score 允许你修改查询检索到的文档分数\n使用function_score时，用户必须定义一个查询和一个或多个函数，这些函数为查询返回的每个文档计算新的分数\n查询示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 GET /_search { \u0026#34;query\u0026#34;: { \u0026#34;function_score\u0026#34;: { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;boost\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;functions\u0026#34;: [ { \u0026#34;filter\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;bar\u0026#34; } }, \u0026#34;random_score\u0026#34;: {}, \u0026#34;weight\u0026#34;: 23 }, { \u0026#34;filter\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;cat\u0026#34; } }, \u0026#34;weight\u0026#34;: 42 } ], \u0026#34;max_boost\u0026#34;: 42, \u0026#34;score_mode\u0026#34;: \u0026#34;max\u0026#34;, \u0026#34;boost_mode\u0026#34;: \u0026#34;multiply\u0026#34;, \u0026#34;min_score\u0026#34;: 42 } } } ","date":"2025-12-21T23:56:02+08:00","permalink":"https://www.cengdong.store/p/elasticsearchelasticsearch%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"【Elasticsearch】Elasticsearch知识点"},{"content":"测试场景设计 场景 带宽限制 延迟 丢包率 判定标准 建议优化措施 2G 网络 ≤ 250 kbps 300–500 ms 5–10% - 页面首屏时间 ≤ 10s\n- 主要接口响应 ≤ 5s\n- 核心功能可用率 ≥ 95% - 图片懒加载\n- 压缩资源（JS/CSS/图片）\n- 接口返回精简数据\n- 异步加载非核心内容 弱 3G 网络 400–700 kbps 150–300 ms 2–5% - 页面首屏时间 ≤ 6s\n- 核心接口响应 ≤ 3s\n- 核心功能可用率 ≥ 98% - 启用缓存策略\n- 使用 CDN 加速\n- 减少请求数量\n- 使用骨架屏 普通 4G 网络 1–4 Mbps 50–150 ms 1–2% - 页面首屏时间 ≤ 3s\n- 接口响应 ≤ 1s\n- 核心功能可用率 ≥ 99% - 压缩资源\n- 合理预加载\n- 接口优化（减少 SQL 查询复杂度） 高延迟网络 网络正常 延迟 ≥ 300 ms ≤ 2% - 页面首屏时间 ≤ 2×正常网络\n- 接口响应延迟 ≤ 2×正常\n- 无明显卡顿 - 接口异步加载\n- 数据缓存\n- 合理降级（低质量图片、减少动画） 高丢包网络 网络正常 延迟正常 丢包率 ≥ 5% - 页面加载成功率 ≥ 95%\n- 核心功能可用率 ≥ 98%\n- 重试机制正常 - 接口幂等化\n- 重试策略（指数退避）\n- 使用稳定协议（HTTP/2） 离线或弱信号 无网络 / 极低带宽 极高延迟 丢包率高 - 应用不崩溃\n- 可缓存核心功能\n- 给用户提示网络不可用 - 离线缓存（Service Worker / localStorage）\n- 数据同步机制\n- 提示用户网络状态 测试执行流程 确定测试目标 页面加载性能 / 核心功能（登录、列表、下单、支付） / 交互流畅度 选择弱网模拟工具 H5 页面 → Chrome DevTools Throttling App（Android/iOS）→ Network Link Conditioner / Charles 配置网络条件 按对照表选择带宽、延迟、丢包率 执行测试 记录页面首屏时间（FCP / LCP） 测试关键接口响应时间 检查功能可用性（是否能正常执行核心操作） 检查 UI 流畅度（FPS / 卡顿情况） 对照判定标准 符合对照表中的判定标准即为“弱网测试通过” 输出报告 网络条件配置 测试结果（加载时间、接口耗时、错误率、可用性） 优化建议 ","date":"2025-10-10T11:26:22+08:00","permalink":"https://www.cengdong.store/p/app%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95app%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/","title":"【App专项测试】App弱网测试"},{"content":"为什么要写这篇博客 对移动应用测试感兴趣 在移动应用除功能测试之外了解的很少 目前工作的移动应用性能很差，想进行优化 Kotlin基础知识 kotlin类型 基本类型：\n数字 Byte Short Int(默认) Long(2L) Float(2.5f) Double(默认) 无符号整型 UByte UShort UInt ULong 布尔 true false 支持逻辑运算符(\u0026amp;\u0026amp; || !) 字符 单引号 转义字符 字符串 双引号 下标遍历 不可变 数组 长度不可变 创建数组(arrayOf/arrayOfNulls/emptyArray，加上类型与长度) 比较数组(contentEquals/contentDeepEquals) 数组api(sum/shuffle) 转换为集合(toList/toSet/toMap) 原生类型数组 类型检测与类型转换：\nkotlin不支持隐式转换 支持编辑器智能转换 类型推断(is/!is) 流程控制 逻辑运算符 内联函数 异常处理 kotlin流程控制 if表达式 ","date":"2025-08-31T23:42:32+08:00","permalink":"https://www.cengdong.store/p/androidandroid%E7%BC%96%E7%A8%8B/","title":"【Android】Android编程"},{"content":"为什么要写这个 目前来说 AI 编程的功能越来越强大，已经可以解决一些简单的项目问题\n短时间来说程序员不会被 AI 替代，因为 AI 有幻觉会胡乱回答，而且写出的代码有 bug 的概率不低\n作为一位 IT 从业者来说学好 AI 可以提高工作效率\nAI 的应用场景 代码编辑助手 agent mcp AI 编辑助手的选择 目前来说 AI 编辑助手有不少：\ngithub copilot cursor trae 目前我的选择是 cursor，因为它是目前最强的 AI 编辑器\ncursor 的核心功能 cursor 是一款 AI 编辑器，数百万工程师都在使用。由一系列自定义模型驱动，生成的代码量比世界上任何 LLM 都要大\n核心功能：\nTab：点击Tab可实现智能代码补全 Chat：使用Cmd + L打开统一的 AI 界面，其中包含询问、编辑和 Agent 模式 Command-K：使用Cmd + K进行內联代码编辑 MCP：模型上下文，比较新的功能 Tab 智能补全 Cursor 中的 Tab 键补全功能由先进的 AI 模型提供支持，这些模型能够理解你的代码上下文。输入时，你会收到以下智能建议：\n完成当前代码行 建议整个函数实现 帮助处理常见模式和样板 随着时间的推移适应你的编码风格 功能：\n当Cursor仅添加附加文本时，补全将显示为灰色文本。如果建议修改了现有代码，它将以差异弹出窗口的形式显示在当前行的右侧。 你可以按Tab接受建议，或按Esc拒绝建议。要逐字逐句地接受部分建议，按Ctrl/⌘ →键。要拒绝建议，只需继续输入，或使用Escape取消/隐藏建议。 每次按键或光标移动，Cursor都会尝试根据您最近的更改提供建议。但是，Cursor并非总是会显示建议；有时模型会预测无需进行任何更改。 要打开或关闭该功能，请将鼠标悬停在应用程序右下角状态栏上的Cursor Tab图标上。\nChat Cursor 提供统一的 AI 界面，具有三种可无缝协作的模式：\nAgent Mode (默认的) 进行代码库范围的更改和重构 根据需求实现新功能 调试多个文件中的复杂问题 生成测试和文档 保持整个项目的一致性 Ask Mode 询问有关特定代码部分的问题 获取复杂函数的解释 查找代码模式和示例 发现并了解你的代码库 Custom modes 创建适合你工作流程的模式 核心能力：\n理解代码：询问有关不熟悉的代码的问题、获取解释或探索你的代码库 编辑代码：无需手动浏览文件即可进行小的调整或大的多个文件更改 运行命令：获取针对你的特定用例的终端命令建议 自动化工作流程：让 Cursor 搜索、推理和执行来自动化你的工作流程 Context 上下文是 Cursor 所有 AI 功能的基础。其工作原理如下：\n当你打开代码库时，Cursor会自动索引你的代码 ，以使其可用作上下文 使用 @符号来精确控制你提供的上下文： @files 和 @folders 用于特定路径 @web 用于外部文档 @git 用于版本控制上下文 配置rules以自定义行为 为外部上下文提供者设置MCP ","date":"2025-06-01T23:09:49+08:00","permalink":"https://www.cengdong.store/p/ai%E7%BC%96%E7%A8%8Bai%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/","title":"【AI编程】AI编程技巧"},{"content":"什么是 k6 使用 k6，你可以测试应用程序和基础设施的可靠性和性能。\n工程团队（包括开发人员、QA 工程师、SDET 和 SRE）通常使用 k6 来：\n负载和性能测试 浏览器性能测试 性能和综合监控 性能测试自动化 混沌与弹性测试 安装 K6 K6 有能在多种平台安装：\nwindows mac linux 除此之外，还可以通过 Docker 容器方式运行 k6\n目前我用的开发主力机是 mac，在 mac 上安装 k6 的途径主要是通过homebrew\n1 brew install k6 此外就是通过 Docker 安装 k6\n1 docker pull grafana/k6 编写第一个 k6 测试脚本 前提条件 要编写 k6 测试脚本，需要以下前提：\njavascript 或者 typescript 知识 在电脑上安装 k6 用于编写测试脚本的代码编辑器(我目前使用的是 vscode) k6 测试脚本的结构 每个 k6 脚本都遵循一个通用结构，围绕几个核心组件：\n默认函数：这是测试逻辑所在的位置。它定义了测试将执行的操作以及在执行过程中的行为方式。它应作为脚本中的默认函数导出。 imports ：您可以进口额外的 k6 模块或 JavaScript 库 (jslibs) 用于扩展脚本功能，例如发出 HTTP 请求或模拟浏览器交互。请注意，k6 并非基于 Node.js 构建，而是使用其自身的 JavaScript 运行时。与某些 npm 模块的兼容性可能有所不同。 options（可选） ：允许您配置测试的执行，例如定义虚拟用户数量、测试时长或设置性能阈值。请参阅 选项以了解更多详细信息。 生命周期操作（可选） ：由于您的测试可能需要在执行测试逻辑之前和/或之后运行代码，例如从文件解析数据或从 Amazon S3 下载对象， 生命周期操作允许您编写代码，作为预定义函数或在特定代码范围内，这些代码将在测试执行的不同阶段执行。 编写 k6 测试脚本 创建测试脚本(手动创建一个 js 文件或者使用k6 new test.js) 导入模块(import http from 'k6/http') 定义函数(export default function() {}) 声明测试选项(export const options = {}) 接下来查看一个完整的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 导入模块 import http from \u0026#39;k6/http\u0026#39; import { sleep } from \u0026#39;k6\u0026#39; // 定义可选项 export const options = { iterations: 10, } // The default exported function is gonna be picked up by k6 as the entry point for the test script. It will be executed repeatedly in \u0026#34;iterations\u0026#34; for the whole duration of the test. // 默认函数，测试脚本逻辑就在这里面，必选项 export default function () { // Make a GET request to the target URL http.get(\u0026#39;https://quickpizza.grafana.com\u0026#39;) // Sleep for 1 second to simulate real-world usage sleep(1) } // 测试生命周期函数，可选的 更多的 http 请求方式 k6 支持所有的 http 请求方法\nget(GET) post(POST) put(PUT) del(DELETE) patch(PATCH) head(HEAD) options(OPTIONS) requests(类似于 python 的 request 库) batch(批量请求) get 方法 1 2 3 4 5 import http from \u0026#39;k6/http\u0026#39; export default function () { http.get(\u0026#39;http://test.k6.io\u0026#39;) } post 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import http from \u0026#39;k6/http\u0026#39; export default function () { const url = \u0026#39;http://test.k6.io/login\u0026#39; const payload = JSON.stringify({ email: \u0026#39;aaa\u0026#39;, password: \u0026#39;bbb\u0026#39;, }) const params = { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, } http.post(url, payload, params) } http 请求标签 标签示例 k6 会自动应用内置标签到 http 请求中，我们可以使用标签来过滤结果并组织分析\n以下是一些常用的 http 相关的标签\n标签名 描述 expected_response 是否是期望的响应，默认情况下 200-399 之间的都是 true，也可以通过setResponseCallback更改默认行为 group 当请求在某个 group 中时是组名，默认值是空 name 默认为请求的 url method http 请求方法 scenario 当请求在某个 scenario 中时，标签值是 scenario 名，默认为 default status 响应状态码 url 默认为 url 请求地址 以下代码展示了如何记录测试结果数据点的 JSON 示例，在此示例中，指标是 HTTP 请求的持续时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;type\u0026#34;: \u0026#34;Point\u0026#34;, \u0026#34;metric\u0026#34;: \u0026#34;http_req_duration\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;time\u0026#34;: \u0026#34;2017-06-02T23:10:29.52444541+02:00\u0026#34;, \u0026#34;value\u0026#34;: 586.831127, \u0026#34;tags\u0026#34;: { \u0026#34;expected_response\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;http://test.k6.io\u0026#34;, \u0026#34;scenario\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://test.k6.io\u0026#34; } } } 使用标签将 URL 分组 默认情况下，标签会有一个name字段，用于保存请求的 URL 的值，如果测试包含动态 URL 路径，我们希望将数据聚合分析，而不是大量的唯一 URL 进入指标流。\n1 2 3 4 5 6 7 8 9 import http from \u0026#39;k6/http\u0026#39; export default function () { for (let id = 1; id \u0026lt;= 100; id++) { http.get(`http://example.com/posts/${id}`) } } // tags.name=\\\u0026#34;http://example.com/posts/1\\\u0026#34;, // tags.name=\\\u0026#34;http://example.com/posts/2\\\u0026#34;, 我们更希望在单个指标中报告这个数据，要从动态的 URL 聚合数据，我们可以设置 http 请求的name标签\n1 2 3 4 5 6 7 8 9 10 11 import http from \u0026#39;k6/http\u0026#39; export default function () { for (let id = 1; id \u0026lt;= 100; id++) { http.get(`http://example.com/posts/${id}`, { tags: { name: \u0026#39;PostsItemURL\u0026#39; }, }) } } // tags.name=\\\u0026#34;PostsItemURL\\\u0026#34;, // tags.name=\\\u0026#34;PostsItemURL\\\u0026#34;, 上面的代码会产生如下的 JSON 输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // For http://example.com/1, note that the url is not present in the JSON. { \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;metric\u0026#34;:\u0026#34;http_req_duration\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;time\u0026#34;:\u0026#34;2017-06-02T23:10:29.52444541+02:00\u0026#34;, \u0026#34;value\u0026#34;:586.831127, \u0026#34;tags\u0026#34;: { \u0026#34;method\u0026#34;:\u0026#34;GET\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;PostsItemURL\u0026#34;, \u0026#34;status\u0026#34;:\u0026#34;200\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;PostsItemURL\u0026#34; } } } // and for http://example.com/2 { \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;metric\u0026#34;:\u0026#34;http_req_duration\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;time\u0026#34;:\u0026#34;2017-06-02T23:10:29.58582529+02:00\u0026#34;, \u0026#34;value\u0026#34;:580.839273, \u0026#34;tags\u0026#34;: { \u0026#34;method\u0026#34;:\u0026#34;GET\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;PostsItemURL\u0026#34;, \u0026#34;status\u0026#34;:\u0026#34;200\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;PostsItemURL\u0026#34; } } } 尽管两个对象的url不同，但是它们的name却是相同的\n或者，你也可以使用http.url包装器来设置具有模版字符串值的name标签\n1 2 3 4 5 6 7 8 9 import http from \u0026#39;k6/http\u0026#39; export default function () { for (let id = 1; id \u0026lt;= 100; id++) { http.get(http.url`http://example.com/posts/${id}`) } } // tags.name=\u0026#34;http://example.com/posts/${}\u0026#34;, // tags.name=\u0026#34;http://example.com/posts/${}\u0026#34;, 指标 指标衡量系统在测试条件下的性能。默认情况下，k6 会自动收集内置指标。除了内置指标外，还可以自定义指标。\n指标分类 指标大致分为四类：\nCounters 计算总和值。 Gauges 跟踪最小值、最大值和最新值。 Rates 跟踪非零值出现的频率。 Trends 计算多个值（如平均值、众数或百分位数）的统计数据。 为了使测试不满足某些标准，你可以编写一个基于指标标准的阈值。\n要过滤指标，你可以使用tag和group\n还可以导出各种摘要和粒度格式的指标，如Result output\n要观测的指标 每个指标都提供了不同的绩效视角，因此，最合适分析的指标取决于自身的目标\n如果你不确定要关注哪些指标，则可以从衡量请求、错误和持续时间的指标开始(RED 方法)\nhttp_reqs ，用于测量请求 http_req_failed ，测量错误率 http_req_duration ，用于测量持续时间 换句话说，这些指标衡量流量、可用性和延迟，SRE 可能会将这些指标视为four Golden Signals\n示例输出 当你运行测试时，所有内置的和自定义指标的汇总摘要将输出到stdout:\n1 2 3 4 5 import http from \u0026#39;k6/http\u0026#39; export default function () { http.get(\u0026#39;https://quickpizza.grafana.com\u0026#39;) } 上述脚本将输出如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 $ k6 run script.js /\\ Grafana /‾‾/ /\\ / \\ |\\ __ / / / \\/ \\ | |/ / / ‾‾\\ / \\ | ( | (‾) | / __________ \\ |_|\\_\\ \\_____/ execution: local script: http_get.js output: - scenarios: (100.00%) 1 scenario, 1 max VUs, 10m30s max duration (incl. graceful stop): * default: 1 iterations for each of 1 VUs (maxDuration: 10m0s, gracefulStop: 30s) █ TOTAL RESULTS HTTP http_req_duration.......................................................: avg=117.55ms min=117.55ms med=117.55ms max=117.55ms p(90)=117.55ms p(95)=117.55ms { expected_response:true }............................................: avg=117.55ms min=117.55ms med=117.55ms max=117.55ms p(90)=117.55ms p(95)=117.55ms http_req_failed.........................................................: 0.00% 0 out of 1 http_reqs...............................................................: 1 2.768749/s EXECUTION iteration_duration......................................................: avg=361.09ms min=361.09ms med=361.09ms max=361.09ms p(90)=361.09ms p(95)=361.09ms iterations..............................................................: 1 2.768749/s NETWORK data_received...........................................................: 6.8 kB 19 kB/s data_sent...............................................................: 541 B 1.5 kB/s running (00m03.8s), 0/1 VUs, 1 complete and 0 interrupted iterations default ✓ [======================================] 1 VUs 00m03.8s/10m0s 1/1 iters, 1 per VU 在该输出中，所有以http、interation、vu开头的指标都是内置指标\n指标名称限制 指标名称必须符合 OpenTelemetry 和 Prometheus 的限制 。字符限制与 k6 在限制字符集之前的限制相同\n意味着：\n包含最多 128 个符号（ASCII 字母、数字或下划线）。 以字母或下划线开头。 内置指标 无论测试什么协议(http/websocket/grpc)，k6 始终收集以下指标\n指标名 类型 描述 checks Rate 检查成功率 data_received Counter 已接收到的数据 data_send Counter 已发送的数据 dropped_iterations Counter 由于 vu 不足或时间不足而未启动的迭代次数 iteration_duration Trend 完成一次完整的迭代所需的时间，包括setup和teardown iterations Counter vu 执行 js 脚本(default 函数)的总次数 vus Gauge 当前活跃虚拟用户数 vus_max Gauge 最大可能的虚拟用户数 http 内置指标 指标名称 类型 描述 http_req_blocked Trend 发起请求之前阻塞的时间float http_req_connecting Trend 与远程主机建立 TCP 连接所花费的时间float http_req_duration Trend 请求的总时间。它等于 http_req_sending + http_req_waiting + http_req_receiving （即远程服务器处理请求和响应所需的时间，不包括初始 DNS 查找/连接时间） float http_req_failed Rate 根据 setResponseCallback 回调函数定义为失败的请求 http_req_receiving Trend 从远程主机接收响应数据所花费的时间 float http_req_sending Trend 向远程主机发送数据所花费的时间float http_req_tls_handshaking Trend 与远程主机握手 TLS 会话所用的时间 http_req_waiting Trend 等待远程主机响应的时间（又称“第一个字节的时间”或“TTFB”） float http_reqs Counter k6 总共生成了多少个 HTTP 请求 浏览器指标 K6 浏览器指标基于Core Web Vitals\n随着技术的变化，这些核心指标也会随之变化，目前，K6 跟踪以下核心网络生命力：\nMetric name Description browser_web_vital_cls 通过量化可见页面内容的意外布局偏移量来衡量网页的视觉稳定性。请参阅Cumulative Layout Shift以获取更多信息。 browser_web_vital_fid 通过量化用户首次交互（例如点击按钮）与浏览器响应之间的延迟来衡量网页的响应能力。请参阅First Input Delay了解更多信息。 browser_web_vital_lcp 测量页面上最大内容元素可见所需的时间。请参阅 请参阅Larger Contentful Paint 以了解更多信息。 除了核心 Web 指标外，浏览器模块还报告Other Web Vitals\n指标名称 描述 browser_web_vital_fcp 测量浏览器渲染页面上第一个 DOM 元素（无论是文本、图片还是标题）所需的时间。请参阅First Contentful Paint 了解更多信息 browser_web_vital_inp 衡量页面响应能力的实验性指标请参阅Interaction to Next Paint以获取更多信息. browser_web_vital_ttfb 测量浏览器请求和服务器响应之间的时间。请参阅Time to First Byte以获取更多信息 内置 Websocket 指标 ","date":"2025-05-18T20:55:24+08:00","permalink":"https://www.cengdong.store/p/k6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95k6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"【K6性能测试】K6学习笔记"},{"content":"什么是 Postman Postman 是一个用于使用、构建和测试 API 的平台。您可以使用 Postman 桌面应用来支持 API 生命周期的每个部分：\n使用 Postman API 客户端发送请求，包括 HTTP、GraphQL 和 gRPC 请求。 设计、构建和记录 API。 构建与 LLM 和 API 交互的 AI 代理。 测试并监控您的 API 的功能和性能。 组织您的工作并与您的团队合作进行 API 开发。 发现新的 API 并构建可视化 API 驱动的应用程序。 发送 Api 请求 Postman 的 API 客户端允许您创建和发送 API 请求 ，包括 HTTP、GraphQL 和 gRPC 请求。使用 Postman，您可以向端点发送请求、从数据源检索数据或测试 API 的功能。您无需在终端中输入命令或编写任何代码。当您创建新请求并选择 “发送” 时，API 响应会直接显示在 Postman 中。\n发送一个 Api 请求可以分为以下三步：\n在工作台点击【+】按钮用于打开一个新的选项卡 选择协议类型，输入postman-echo.com/get作为请求 url，传入路径参数和查询参数，传入请求正文 点击发送即可 成功发送请求之后你将看到\n在这之中发生了什么？\nPostman 向位于 postman-echo.com 的 Postman Echo API 服务器发送了 GET 请求。 API 服务器接收请求、处理请求并向 Postman 返回响应。 Postman 收到了响应并将其显示在 “响应” 窗格中。 编写测试 API 测试是一种确保 API 按照预期运行的方法。例如，您可以编写测试来验证 API 的错误处理方式，方法是发送包含不完整数据或错误参数的请求。您可以使用 JavaScript 为 Postman API 请求编写测试，并将其添加到单个请求 、 集合以及集合中的文件夹中。Postman 包含一些代码片段，您可以添加并修改这些代码片段以适应您的测试逻辑。\n要编写测试，请执行以下操作：\n转到您在发送您的第一个 API 请求中提出的请求。 在请求中，选择脚本选项卡，然后选择后响应 。 选择代码编辑器右下角的 Code icon Snippets ，然后选择 Status code: Code is 200 。这样就会输入以下测试代码： 1 2 3 pm.test(\u0026#39;Status code is 200\u0026#39;, function () { pm.response.to.have.status(200) }) 选择 “发送” 。 ","date":"2025-04-30T10:47:52+08:00","permalink":"https://www.cengdong.store/p/postmanpostman%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"【Postman】Postman学习笔记"},{"content":"为什么要写 Charles 最近又重返测试岗位，作为一名测试工作人员，掌握好代理工具，分析 bug 产生的原因，是一项必不可少的技能\n需要掌握的代理工具有哪些 或者说那些代理工具值得掌握\nCharles Fildder 二选一(因为习惯用 mac， 更倾向于 Charles) Mitmproxy(这个我觉得是更好的选项，code first, 灵活性更强) Charles 常用功能 流量过滤 过滤自己能看到的包有两种选项\nProxy -\u0026gt; recording settings -\u0026gt; include/exclude 左下角填写过滤表达式(我一般都按照域名过滤) 并发测试 其实不算是什么并发，就是 repeat 请求，advanced repeat 可以指定并发数\n在少量的批量接口调用时可以方便使用，会默认新建一个 seesion\n断点 breaking points可以对请求和响应进行截断并修改，最近在支付测试的时候用的多\n对符合breaking points规则的每一个请求/响应都会进行截断\n如果是需要每次都修改响应，可以使用map local更为方便\ncompose compose 可以生成一个新的请求，代替 postman 接口测试？\n重定向 map local(本地重定向，可以先save response到本地，再把接口请求重定向到保存的响应去) map remote(重定向到远程服务器, 客户端进行后端服务器替换，替换为mock服务器) 感觉这两个功能如果想要更高的灵活性，可以使用mitmproxy\n节流器 可以进行网弱测试，没怎么用过(devTools 也有相应功能)\n端口转发 没用过，不做评价\n","date":"2025-04-27T21:31:43+08:00","permalink":"https://www.cengdong.store/p/charlescharles%E5%8A%9F%E8%83%BD%E5%A4%A7%E5%85%A8/","title":"【Charles】Charles功能大全"},{"content":"为什么要写这个 转型失败，之前一直想从测试转到后端开发，但是国内互联网求职环境一再恶化 零经验转行基本上没戏 之后的职业规划 我想是有三个选项\nSDET(这个可能性最高，除非测试需求没有了，目标是从中高级开始) 前端开发(需求量应该是最高的，目标是从初级/助理开始) 全栈开发(这个的话就是 nodejs 全栈，目标也是初级/助理) 需要提升的技能 优先级从高到低\nPython/Js/Java（不能好高骛远，测试需要的就是这些技术栈） 开源项目参与，从 Playwright 入手参与开源项目 前端性能测试实战，之前用 Lighthouse 初步了解过一点，但是远远不够 正在做的事 k6 学习，最近使用k6做了一些压测实战，收获了不少，搭建了框架 搜索引擎压测(elasticsearch与meilisearch的压测比较) 工作中需要的技能 Mongo/Postgres（之前没怎么使用过） Elasticsearch DSL（大数据测试还是有门槛，也有需求的） All in Python/Js 以及 AI ","date":"2025-04-26T22:58:44+08:00","permalink":"https://www.cengdong.store/p/sdet%E4%B9%8B%E8%B7%AF%E5%BE%85%E6%8F%90%E5%8D%87%E6%8A%80%E8%83%BD/","title":"【SDET之路】待提升技能"},{"content":"好的习惯 测试用例的编写是重要的能力，需要专项提升(一个是测试用例设计方法，一个是全面了解前/后端技术方案) 测试发现与自己预期不一样的地方，先问是什么，再问是不是 bug，最后还要试着定位到底是谁的问题 考虑测试用例的时候不要仅仅考虑功能用例，还要考虑性能安全性等问题 在验证一个功能/回归一个 bug 时，要一次性验证所有的功能(相关所有平台)，防止重复返工 测试工程中要思考需求实现是不是合理 在测试环境进行的验证可能在生产环境不一样，因为测试环境架构与生产不一致（生产可能是集群），所以测试用例也要考虑到这种情况 在需求评审/测试的阶段首先要确定 UI 交互的问题 零碎的时间主要用于英语学习而不是技术学习 自动化进阶 把一些重复的工作通过自动化解决 造数平台 sql 进阶 常用 sql 在 navicat 中保存成查询 业务需要的特殊数据用 sql 定期查询 线上回归 基本功能需要过一遍 所有可能影响的功能都需要点一点 如何快速搞懂业务 平常多用功能 查看接口/接口文档(如果有的话) 查看数据库表/字段的注释 问同事的问题使用 typora 记录 组长不在的时候，快速找到业务负责人，问清楚有哪些数据库表，怎么进行测试 副业 最近有想法探索一点副业的方向，测试在业务开发中的地位太低了，而且互联网也确实不是很长久。准备搞短视频吧，记录生活玩玩而已。\n方向就是互联网梗相关的，因为自己也喜欢玩梗\n首先需要的就是视频剪辑能力，国内还是选择抖音吧\n工作中需要的能力 测试用例设计的高效以及功能覆盖率 功能点的 UI 校验（文字以及样式）(要学会使用 figma) 功能点输入的设计 功能点输出的设计 功能点状态的设计(状态机转移，状态是否可重入) 沟通能力 说明问题的能力（提 bug 是否清晰：复现步骤，必要时加上录屏） 请求问题（高效提问的能力） 解决问题的能力 作为一名遇到问题首先想到的是记录(因为复现的成本比较高) 不能有任何侥幸的想法，还有就是接口自动化吧 ","date":"2025-04-21T19:08:21+08:00","permalink":"https://www.cengdong.store/p/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%B5%8B%E8%AF%95%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/","title":"【工作心得】测试工作心得"},{"content":"ui 自动化需要跳转新的 tab 页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 async addMonitorEnterprise() { const pagePromise = this.page.context().waitForEvent(\u0026#39;page\u0026#39;) await this.searchInput.focus() await this.searchInput.fill(\u0026#39;乐视\u0026#39;) await expect(this.hisEntList).toBeVisible({}) await this.hisEntItem.first().click() // 等待新页面跳转并获取新的页面 const newPage = await pagePromise // 使用新页面的定位器 const addMonitorButton = newPage .locator(\u0026#39;.info-basic-box\u0026#39;) .getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39; 添加监控\u0026#39;, }) await expect(addMonitorButton).toBeVisible() await addMonitorButton.click() } 注意点 使用page.context().waitForEvent()得到新页面的 promise 等待自动化代码触发打开新页面 await 这个 promise 获得新页面 使用新页面的对象调用方法 ","date":"2025-04-17T23:45:57+08:00","permalink":"https://www.cengdong.store/p/playwrightplaywright%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%88%87%E6%8D%A2/","title":"【Playwright】playwright标签页切换"},{"content":"遇到的问题 使用playwright.config.ts中的dependencies配置项来进行其他用例的前置登陆\n1 2 3 4 5 6 7 8 9 10 11 // Setup project { name: \u0026#39;setup\u0026#39;, testMatch: /setup\\.ts/ }, { name: \u0026#39;chromium\u0026#39;, use: { ...devices[\u0026#39;Desktop Chrome\u0026#39;], storageState: \u0026#39;tests/.auth/zengdong.json\u0026#39;, }, dependencies: [\u0026#39;setup\u0026#39;], }, 其中setup.ts的内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { expect, test as setup } from \u0026#39;@playwright/test\u0026#39; import path from \u0026#39;path\u0026#39; const authFile = path.join(__dirname, \u0026#39;../.auth/zengdong.json\u0026#39;) setup(\u0026#39;authenticate\u0026#39;, async ({ page }) =\u0026gt; { // Perform authentication steps. Replace these actions with your own. await page.goto(\u0026#39;/auth/login\u0026#39;) await page.getByPlaceholder(\u0026#39;请输入邮箱地址\u0026#39;).fill(\u0026#39;xxxxxxxx\u0026#39;) await page.getByPlaceholder(\u0026#39;请输入密码\u0026#39;).fill(\u0026#39;xxxxxx\u0026#39;) await page.getByRole(\u0026#39;button\u0026#39;, { name: \u0026#39;登 录\u0026#39; }).click() // Wait until the page receives the cookies. await expect(page.getByText(\u0026#39;登录成功\u0026#39;)).toBeVisible() // Alternatively, you can wait until the page reaches a state where all cookies are set. await page.waitForURL(\u0026#39;http://xxxxxxxxxx\u0026#39;, { waitUntil: \u0026#39;load\u0026#39;, }) // End of authentication steps. await page.context().storageState({ path: authFile }) }) 但是登陆页面的用例不需要前置登陆\n解决方案 登陆用例单独配置成一个 project，其他 project 忽略登陆用例 登陆用例不使用 setup.ts 生成的 storageState 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { AuthPage } from \u0026#39;../pages/authPage\u0026#39; import { AllMonitorPage } from \u0026#39;../pages/allMonitorPage\u0026#39; import { test as baseTest } from \u0026#39;@playwright/test\u0026#39; export const test = baseTest.extend\u0026lt;{ authPage: AuthPage allMonitorPage: AllMonitorPage }\u0026gt;({ authPage: async ({ browser, storageState }, use) =\u0026gt; { // 👉 使用 test.use 传下来的 storageState 参数（默认或被覆盖） const context = await browser.newContext({ storageState: undefined, }) const page = await context.newPage() const authPage = new AuthPage(page) await use(authPage) await context.close() }, allMonitorPage: async ({ page }, use) =\u0026gt; { await use(new AllMonitorPage(page)) }, }) ","date":"2025-04-13T23:38:39+08:00","permalink":"https://www.cengdong.store/p/playwrightplaywright%E7%99%BB%E9%99%86%E8%AE%A4%E8%AF%81/","title":"【Playwright】playwright登陆认证"},{"content":"形容人的外表 pretty (adj.)漂亮的 ; (adv.)非常 beautiful (adj.)美丽的 handsome (adj.)帅气的 elegant (adj.)优雅的(气质好) attractive (adj.)吸引人的 cute (adj.)可爱的 homely (adj.)长相普通的、一般的 ugly (adj.)丑的 身材 skinny (adj.)消瘦的(皮包骨); slim (adj.)苗条的; ripped (adj.)健美的; curvy (adj.)曲线优美的、凹凸有致的; strong (adj.)强壮的; big-boned (adj.)骨架大的; chubby (adj.)微胖的、胖乎乎的; fat (adj.)肥胖的; 身高 tall (adj.)高的 medium-height (adj.)中等身高的 short (adj.)矮的 年龄 old (adj.)年老的 middle-aged (adj.)中等年龄的 young (adj.)年轻的 little (adj.)小的 外表及其他细节 straight (adj.)直的(头发、鼻子) curly (adj.)卷曲的 blond (adj.)金发碧眼的 bald (adj.)秃顶的 dark (adj.)深色的 light (adj.)浅色的 颜色 red (adj.)红色的 yellow (adj.)黄色的 blue (adj.)蓝色的 indigo (adj.)青色的 green (adj.)绿色的 orange (adj.)橙色的 purple (adj.)紫色的 violet (adj.)蓝紫色的 white (adj.)白色的 black (adj.)黑色的 pink (adj.)粉色的 brown (adj.)棕色的 grey (adj.)灰色的 golden (adj.)金色的 silver (adj.)银色的 transparent (adj.)透明的 面部动作与表情 laugh (v.)笑 (n.)笑 smile (v.)微笑 blush (v.)脸红(害羞) (n.)腮红 sigh (v.)叹气 (n.)叹气 cry (v.)哭，喊 (n.)哭声、喊声 scream (v.)尖叫 (n.)尖叫 cough (v.)咳嗽 (n.)咳嗽 sneeze (v.)打喷嚏 (n.)喷嚏 yawn (v.)打哈欠 (n).哈欠 whistle (v.)吹口哨 (n.)口哨 snore (v.)打鼾 (n.)呼噜声、鼾声 kiss (v.)亲吻 (n.)轻吻 breathe (v.)呼吸 smell (v.)闻 (n.)气味 taste (v.)品尝 (n.)味道 read (v.)阅读 look (v.) 看 (n.)看、目光、神色 watch (v.)观看 (n.)钟表 see (v.)看见 listen (v.)听 hear (v.)听见 write (v.)写 touch (v.)摸 (n.)联系 ","date":"2025-04-06T21:44:37+08:00","permalink":"https://www.cengdong.store/p/english%E6%B5%B7%E4%B9%8B%E5%85%89%E8%8B%B1%E8%AF%AD3000%E5%8D%95%E8%AF%8D/","title":"【English】海之光英语3000单词"},{"content":"介绍 Midscene.js 是一个由 AI 驱动的 UI 自动化测试框架，旨在通过自然语言交互简化测试流程，支持动作执行、数据查询和页面断言，并生成可视化报告。\ngithub 地址：https://github.com/web-infra-dev/midscene\n传统 UI 自动化测试的局限性 测试脚本编写与维护难点 学习特定框架事件语法 selector 选择器问题 难以对抗页面变化 需要侵入业务代码 页面信息提取困难 测试脚本可读性/可维护性差 报告可读性差 视觉检查 白屏检查困难(监测 dom 渲染变化不稳定) 样式错乱(依赖人工视觉检查) midscene 基于 AI 多模态的测试框架 让 UI 自动化测试脚本变得更容易编写、更易维护 对传统 E2E 工具和人工 QA 带来变革 产品形态 浏览器插件(自然语言) 与测试框架集成(playwright、puppeteer) cli(yaml 文件) 与传统 UI 自动化测试框架对比 传统 UI 自动化测试 多模态 AI 自动化测试 可维护性 🌟 🌟 🌟 🌟 🌟 🌟 可读性 🌟 🌟 🌟 🌟 🌟 🌟 开发成本 🌟 🌟 🌟 🌟 🌟 🌟 开发体验 🌟 🌟 🌟 🌟 🌟 🌟 视觉检查能力 🌟 🌟 🌟 🌟 🌟 🌟 常用 api agent.ai() / agent.aiAction() 1 2 function aiAction(steps: string): Promise\u0026lt;void\u0026gt;; function ai(steps: string): Promise\u0026lt;void\u0026gt;; // shorthand form Examples:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Basic usage await agent.aiAction( \u0026#39;Type \u0026#34;JavaScript\u0026#34; into the search box, then click the search button\u0026#39; ) // Using the shorthand .ai form await agent.ai( \u0026#39;Click the login button at the top of the page, then enter \u0026#34;test@example.com\u0026#34; in the username field\u0026#39; ) // Complex example of target-oriented prompts from the ui-tars model // Other models recommend writing the execution steps for each step await agent.aiAction(` 1. Scroll to the product list 2. Locate the \u0026#34;Sauce Labs Backpack\u0026#34; item 3. Click its \u0026#34;Add to cart\u0026#34; button 4. Wait for the shopping cart icon to update `) agent.aiQuery() 1 function aiQuery\u0026lt;T\u0026gt;(dataShape: string | Object): Promise\u0026lt;T\u0026gt;; Examples:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const dataA = await agent.aiQuery({ time: \u0026#39;The date and time displayed in the top-left corner as a string\u0026#39;, userInfo: \u0026#39;User information in the format {name: string}\u0026#39;, tableFields: \u0026#39;An array of table field names, string[]\u0026#39;, tableDataRecord: \u0026#39;Table records in the format {id: string, [fieldName]: string}[]\u0026#39;, }) // You can also describe the expected return format using a string: // dataB will be an array of strings const dataB = await agent.aiQuery(\u0026#39;string[], list of task names\u0026#39;) // dataC will be an array of objects const dataC = await agent.aiQuery( \u0026#39;{name: string, age: string}[], table data records\u0026#39; ) agent.aiAssert() 1 function aiAssert(assertion: string, errorMsg?: string): Promise\u0026lt;void\u0026gt;; Example:\n1 await agent.aiAssert(\u0026#39;The price of \u0026#34;Sauce Labs Onesie\u0026#34; is 7.99\u0026#39;) ","date":"2025-03-16T22:40:28+08:00","permalink":"https://www.cengdong.store/p/uiautomationai%E9%A9%B1%E5%8A%A8%E7%9A%84ui%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7midscene/","title":"【UIAutomation】AI驱动的UI自动化工具midscene"},{"content":"介绍 Python 正则表达式（Regular Expression，简称 regex）是一种强大的文本处理工具，主要用于字符串匹配、查找、替换和分割。Python 的 re 模块提供了对正则表达式的支持。\n导入 re 模块 在 Python 中使用正则表达式时，需要先导入 re 模块：\n1 import re 正则表达式基本语法 正则表达式使用特殊字符（元字符 metacharacters）来定义匹配模式。\n符号 说明 示例 . 匹配任意字符（除换行符） a.c 可匹配 abc, a+c ^ 匹配字符串开头 ^Hello 匹配 \u0026quot;Hello world\u0026quot; $ 匹配字符串结尾 end$ 匹配 \u0026quot;the end\u0026quot; * 匹配前一个字符 0 次或多次 ab*c 匹配 \u0026quot;ac\u0026quot;, \u0026quot;abc\u0026quot; + 匹配前一个字符 1 次或多次 ab+c 匹配 \u0026quot;abc\u0026quot;, \u0026quot;abbc\u0026quot; ? 匹配前一个字符 0 或 1 次 ab?c 匹配 \u0026quot;ac\u0026quot;, \u0026quot;abc\u0026quot; {n} 匹配前一个字符 n 次 a{3} 匹配 \u0026quot;aaa\u0026quot; {n,} 至少匹配 n 次 a{2,} 匹配 \u0026quot;aa\u0026quot;, \u0026quot;aaa\u0026quot; {n,m} 匹配 n 到 m 次 a{2,4} 匹配 \u0026quot;aa\u0026quot;, \u0026quot;aaa\u0026quot; [] 匹配字符类中的任意字符 [aeiou] 匹配任何元音字母 \\d 匹配数字（0-9） \\d+ 匹配 \u0026quot;123\u0026quot;, \u0026quot;456\u0026quot; \\D 匹配非数字 \\D+ 匹配 \u0026quot;abc\u0026quot; 常用预定义字符集 符号 作用 示例 \\d 匹配 数字（0-9） \\d+ 匹配 \u0026quot;123\u0026quot;, \u0026quot;456\u0026quot; \\D 匹配 非数字 \\D+ 匹配 \u0026quot;abc\u0026quot;, \u0026quot;hello\u0026quot; \\w 匹配 单词字符（字母、数字、下划线） \\w+ 匹配 \u0026quot;hello_123\u0026quot; \\W 匹配 非单词字符 \\W+ 匹配 \u0026quot;,.!@\u0026quot; \\s 匹配 空白字符（空格、制表符 \\t、换行 \\n） \\s+ 匹配 \u0026quot; \u0026quot; \\S 匹配 非空白字符 \\S+ 匹配 \u0026quot;hello\u0026quot; re 模块的常用函数 re.match() - 从字符串开头开始匹配 1 2 3 4 5 6 7 8 import re pattern = r\u0026#34;hello\u0026#34; text = \u0026#34;hello world\u0026#34; match = re.match(pattern, text) if match: print(\u0026#34;匹配成功:\u0026#34;, match.group()) # 输出: hello re.search() - 搜索整个字符串 1 2 3 4 5 6 7 8 import re pattern = r\u0026#34;world\u0026#34; text = \u0026#34;hello world\u0026#34; search_result = re.search(pattern, text) if search_result: print(\u0026#34;匹配成功:\u0026#34;, search_result.group()) # 输出: world re.findall() - 返回所有匹配项的列表 1 2 3 4 5 6 import re pattern = r\u0026#34;\\d+\u0026#34; text = \u0026#34;订单编号 12345，金额 67890\u0026#34; matches = re.findall(pattern, text) print(matches) # 输出: [\u0026#39;12345\u0026#39;, \u0026#39;67890\u0026#39;] re.finditer() - 返回所有匹配项的迭代器 1 2 3 4 5 6 7 8 9 10 11 import re pattern = r\u0026#34;\\d+\u0026#34; text = \u0026#34;订单编号 12345，金额 67890\u0026#34; matches = re.finditer(pattern, text) for match in matches: print(\u0026#34;匹配项:\u0026#34;, match.group()) # 输出: # 匹配项: 12345 # 匹配项: 67890 re.sub() - 替换匹配项 1 2 3 4 5 6 import re pattern = r\u0026#34;\\d+\u0026#34; text = \u0026#34;价格 100 元\u0026#34; new_text = re.sub(pattern, \u0026#34;200\u0026#34;, text) print(new_text) # 输出: 价格 200 元 re.split() - 根据匹配项分割字符串 1 2 3 4 5 6 import re pattern = r\u0026#34;\\s+\u0026#34; text = \u0026#34;Hello world Python\u0026#34; split_text = re.split(pattern, text) print(split_text) # 输出: [\u0026#39;Hello\u0026#39;, \u0026#39;world\u0026#39;, \u0026#39;Python\u0026#39;] 使用 re.compile() 提高性能 re.compile() 可以预编译正则表达式，提高匹配效率，适用于需要重复匹配的情况。\n1 2 3 4 5 6 7 8 import re pattern = re.compile(r\u0026#34;\\d+\u0026#34;) text = \u0026#34;订单编号 12345，金额 67890\u0026#34; # 复用编译后的正则表达式 print(pattern.findall(text)) # 输出: [\u0026#39;12345\u0026#39;, \u0026#39;67890\u0026#39;] print(pattern.sub(\u0026#34;X\u0026#34;, text)) # 输出: 订单编号 X，金额 X 贪婪匹配与非贪婪匹配 默认情况下，正则表达式是贪婪匹配（匹配尽可能多的字符）。\n1 2 3 4 5 6 7 8 9 10 11 import re text = \u0026#39;\u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;World\u0026lt;/div\u0026gt;\u0026#39; # 贪婪匹配（匹配最大可能的部分） print(re.findall(r\u0026#39;\u0026lt;div\u0026gt;.*\u0026lt;/div\u0026gt;\u0026#39;, text)) # 输出: [\u0026#39;\u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;\u0026lt;div\u0026gt;World\u0026lt;/div\u0026gt;\u0026#39;] # 非贪婪匹配（匹配最小可能的部分） print(re.findall(r\u0026#39;\u0026lt;div\u0026gt;.*?\u0026lt;/div\u0026gt;\u0026#39;, text)) # 输出: [\u0026#39;\u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;\u0026#39;, \u0026#39;\u0026lt;div\u0026gt;World\u0026lt;/div\u0026gt;\u0026#39;] ","date":"2025-03-15T22:43:13+08:00","permalink":"https://www.cengdong.store/p/pythonpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/","title":"【Python】Python正则表达式re模块"},{"content":"介绍 在 Python 中，Enum（枚举）是一种用于定义一组命名常量的类。它可以提高代码的可读性，防止使用魔法数字（magic numbers），并确保变量的值只能是预定义的选项之一。\n定义 Enum Python 提供了 enum 模块，可以用 Enum 类来定义枚举：\n1 2 3 4 5 6 from enum import Enum class Color(Enum): RED = 1 GREEN = 2 BLUE = 3 访问枚举成员\n1 2 3 print(Color.RED) # Color.RED print(Color.RED.name) # RED print(Color.RED.value) # 1 遍历枚举 可以使用 for 循环遍历枚举：\n1 2 3 4 5 6 for color in Color: print(color.name, color.value) # RED 1 # GREEN 2 # BLUE 3 成员比较 可以使用 is 或 == 进行比较：\n1 2 3 4 5 if Color.RED is Color.RED: print(\u0026#34;Same member\u0026#34;) if Color.RED == Color(1): print(\u0026#34;Same value\u0026#34;) 枚举的唯一性 默认情况下，枚举成员的值可以重复，但可以使用 @unique 装饰器强制唯一：\n1 2 3 4 5 6 7 8 from enum import Enum, unique @unique class UniqueColor(Enum): RED = 1 GREEN = 2 BLUE = 3 # YELLOW = 1 # 这行会报错 / This line will cause an error 自动赋值枚举 1 2 3 4 5 6 7 8 9 10 from enum import Enum, auto class AutoColor(Enum): RED = auto() GREEN = auto() BLUE = auto() print(AutoColor.RED.value) # 1 print(AutoColor.GREEN.value) # 2 print(AutoColor.BLUE.value) # 3 IntEnum（整数枚举） 如果想让枚举成员表现得像整数，可以使用 IntEnum：\n1 2 3 4 5 6 7 8 9 from enum import IntEnum class Status(IntEnum): SUCCESS = 200 NOT_FOUND = 404 ERROR = 500 print(Status.SUCCESS == 200) # True print(Status.SUCCESS + 100) # 300 注意：普通 Enum 不能直接与整数进行数学运算，而 IntEnum 可以。\n成员别名 如果多个成员的值相同，只有第一个定义的成员会作为正式成员，其他的是别名：\n1 2 3 4 5 6 7 8 class Shape(Enum): CIRCLE = 1 OVAL = 2 ELLIPSE = 2 # 这是 OVAL 的别名 / This is an alias for OVAL print(Shape.OVAL) # Shape.OVAL print(Shape.ELLIPSE) # Shape.OVAL print(Shape.OVAL is Shape.ELLIPSE) # True 自定义方法 1 2 3 4 5 6 7 8 class Message(Enum): HELLO = \u0026#34;Hello\u0026#34; GOODBYE = \u0026#34;Goodbye\u0026#34; def describe(self): return f\u0026#34;Message: {self.value}\u0026#34; print(Message.HELLO.describe()) # Message: Hello ","date":"2025-03-14T22:51:42+08:00","permalink":"https://www.cengdong.store/p/pythonpython%E6%9E%9A%E4%B8%BEenum/","title":"【Python】Python枚举Enum"},{"content":"介绍 Python 的**魔术方法（Magic Methods）**是以双下划线 __ 包围的特殊方法，常用于重载运算符、定义对象行为等。\n对象的创建与销毁 方法 作用 __new-_(cls, *args, **kwargs) 创建对象(在__init__之前调用) __init__(self, \\*args, \\*\\*kwargs) 初始化对象 __del__(self) 对象销毁时调用 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass: def __new__(cls): print(\u0026#34;Creating instance\u0026#34;) return super().__new__(cls) def __init__(self): print(\u0026#34;Initializing instance\u0026#34;) def __del__(self): print(\u0026#34;Destroying instance\u0026#34;) obj = MyClass() del obj # 显式销毁对象 字符串表示 方法 作用 __str__(self) str(obj)，用于用户可读的字符串表示 __repr__(self) repr(obj)，用于调试的字符串表示 __format__(self, format_spec) format(obj, spec)，自定义格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 class Person: def __init__(self, name): self.name = name def __str__(self): return f\u0026#34;Person: {self.name}\u0026#34; # 用户友好的描述 def __repr__(self): return f\u0026#34;Person(name={self.name!r})\u0026#34; # 开发者友好的表示 p = Person(\u0026#34;Alice\u0026#34;) print(str(p)) # Person: Alice print(repr(p)) # Person(name=\u0026#39;Alice\u0026#39;) 算数运算符重载 方法 作用 __add__(self, other) + 加法 __sub__(self, other) - 减法 __mul__(self, other) * 乘法 __truediv__(self, other) / 除法 __floordiv__(self, other) // 整除 __mod__(self, other) % 取余 __pow__(self, other) ** 幂运算 __neg__(self) - 取负 __abs__(self) abs(obj) 绝对值 1 2 3 4 5 6 7 8 9 10 11 12 13 class Vector: def __init__(self, x, y): self.x, self.y = x, y def __add__(self, other): return Vector(self.x + other.x, self.y + other.y) def __str__(self): return f\u0026#34;Vector({self.x}, {self.y})\u0026#34; v1 = Vector(1, 2) v2 = Vector(3, 4) print(v1 + v2) # Vector(4, 6) 比较运算符 方法 作用 __eq__(self, other) == 等于 __ne__(self, other) != 不等于 __lt__(self, other) \u0026lt; 小于 __le__(self, other) \u0026lt;= 小于等于 __gt__(self, other) \u0026gt; 大于 __ge__(self, other) \u0026gt;= 大于等于 1 2 3 4 5 6 7 8 9 10 class Person: def __init__(self, age): self.age = age def __lt__(self, other): return self.age \u0026lt; other.age p1 = Person(25) p2 = Person(30) print(p1 \u0026lt; p2) # True 容器相关 方法 作用 __len__(self) len(obj)，返回对象长度 __getitem__(self, key) obj[key]，获取元素 __setitem__(self, key, value) obj[key] = value设置元素 __delitem__(self, key) del obj[key]，删除元素 __contains__(self, item) item in obj检查是否包含 1 2 3 4 5 6 7 8 9 10 11 12 13 class CustomList: def __init__(self, data): self.data = data def __len__(self): return len(self.data) def __getitem__(self, index): return self.data[index] cl = CustomList([1, 2, 3]) print(len(cl)) # 3 print(cl[1]) # 2 迭代器 方法 作用 __iter__self) 使对象可迭代 __next__(self) next(obj)返回迭代器的下一个元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Counter: def __init__(self, max_count): self.max = max_count self.current = 0 def __iter__(self): return self # 迭代器返回自身 def __next__(self): if self.current \u0026lt; self.max: self.current += 1 return self.current else: raise StopIteration c = Counter(3) for i in c: print(i) # 1, 2, 3 上下文管理（Context Manager） 方法 作用 __enter__(self) 进入 with 代码块 __exit__(self, exc_type, exc_value, traceback) 退出 with 代码块 1 2 3 4 5 6 7 8 9 10 11 12 class FileHandler: def __init__(self, filename, mode): self.file = open(filename, mode) def __enter__(self): return self.file def __exit__(self, exc_type, exc_value, traceback): self.file.close() with FileHandler(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;Hello, world!\u0026#34;) ","date":"2025-03-13T15:27:47+08:00","permalink":"https://www.cengdong.store/p/pythonpython%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/","title":"【Python】Python魔术方法"},{"content":"介绍 CSS Grid Layout（网格布局）是最强大的 CSS 布局系统，它提供二维布局能力，能够精确控制行（row）和列（column），适用于网页整体结构或复杂组件\nGrid 容器（Grid Container） 使用 display: grid 或 display: inline-grid 声明一个 Grid 容器：\n1 2 3 .container { display: grid; /* 定义一个网格布局容器 */ } 📌 grid VS inline-grid：\ngrid：块级网格容器，占据整行 inline-grid：内联级网格容器，大小由内容决定 定义网格（行和列） 使用 grid-template-columns 和 grid-template-rows 定义列数和行数：\n1 2 3 4 5 .container { display: grid; grid-template-columns: 200px 100px auto; /* 3 列 */ grid-template-rows: 100px 200px; /* 2 行 */ } 📌 解释：\n200px 100px auto → 3 列，分别为 200px、100px 和剩余宽度 100px 200px → 2 行，分别 100px、200px fr（网格比例单位） 用 fr 让网格自动分配可用空间：\n1 2 3 4 .container { display: grid; grid-template-columns: 1fr 2fr 1fr; /* 按比例划分列 */ } 📌 1fr 2fr 1fr → 这三列的宽度比例为 1:2:1（类似 flex-grow）\nrepeat()（简化网格） 使用 repeat() 让代码更简洁：\n1 2 grid-template-columns: repeat(3, 1fr); /* 3 列，每列等宽 */ grid-template-rows: repeat(2, 100px); /* 2 行，每行 100px */ 📌 repeat(3, 1fr) → 相当于 1fr 1fr 1fr\ngap（网格间距） 1 2 3 4 5 .container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; /* 设置行列间距 */ } 📌 等价于：\n1 2 row-gap: 20px; /* 仅设置行间距 */ column-gap: 20px; /* 仅设置列间距 */ 自动填充 auto-fill \u0026amp; auto-fit 用于响应式布局：\n1 grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); 📌 解释：\nminmax(150px, 1fr) → 设定最小 150px，最大填充剩余空间 auto-fill → 尽可能多填充列，即使有空白 auto-fit → 适配列数，会压缩空列 子元素布局 grid-column \u0026amp; grid-row（控制网格项位置） 1 2 3 4 .item { grid-column: 1 / 3; /* 让元素跨越第 1 ~ 2 列 */ grid-row: 1 / 3; /* 让元素跨越第 1 ~ 2 行 */ } 📌 等价于：\n1 2 3 4 grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 3; span 语法 1 2 3 4 .item { grid-column: span 2; /* 让元素跨 2 列 */ grid-row: span 2; /* 让元素跨 2 行 */ } grid-auto-rows \u0026amp; grid-auto-columns 用于自动生成额外的行/列：\n1 2 3 4 .container { grid-template-columns: 200px 200px; /* 2 列 */ grid-auto-rows: 100px; /* 额外行高 100px */ } justify-content \u0026amp; align-content（网格整体对齐） 用于控制整个网格的对齐方式：\n1 2 3 4 5 .container { display: grid; justify-content: center; /* 水平对齐 */ align-content: center; /* 垂直对齐 */ } 属性 作用 可选值 justify-content 控制水平方向 start / center / end / space-between / space-around / space-evenly align-content 控制垂直方向 同上 justify-items \u0026amp; align-items（网格项对齐） 用于控制单个网格项的对齐：\n1 2 3 4 .container { justify-items: center; /* 水平居中 */ align-items: center; /* 垂直居中 */ } 📌 作用对象：\njustify-items 影响所有网格项的水平对齐 align-items 影响所有网格项的垂直对齐 justify-self \u0026amp; align-self（单个网格项对齐） 1 2 3 4 .item { justify-self: center; /* 仅影响当前元素的水平对齐 */ align-self: center; /* 仅影响当前元素的垂直对齐 */ } 📌 区别：\njustify-self 控制单个网格项的水平位置 align-self 控制单个网格项的垂直位置 grid-template-areas（网格布局命名） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 .container { display: grid; grid-template-areas: \u0026#39;header header header\u0026#39; \u0026#39;sidebar content content\u0026#39; \u0026#39;footer footer footer\u0026#39;; grid-template-columns: 200px 1fr 1fr; grid-template-rows: 80px auto 60px; } .header { grid-area: header; } .sidebar { grid-area: sidebar; } .content { grid-area: content; } .footer { grid-area: footer; } ","date":"2025-03-12T13:23:27+08:00","permalink":"https://www.cengdong.store/p/cssgrid%E5%B8%83%E5%B1%80/","title":"【CSS】Grid布局"},{"content":"介绍 Flex（Flexible Box）是一种用于布局的 CSS 方式，能够方便地实现元素在容器中的 自动调整大小、对齐、换行 等功能，特别适用于响应式设计。\n启用 flex 布局 要使用 Flex 布局，必须先在父容器上设置：\n1 2 3 .container { display: flex; } flex 容器(父级)属性 属性 作用 display: flex 启用 flex 布局，使子元素变成弹性 flex-direction 设定主轴方向(row、column) flex-wrap 设定子元素是否换行(wrap、nowrap) justify-content 控制主轴上的对齐方式(居中、均分) align-items 控制交叉轴上的对齐方式 align-content 控制多行弹性项的对齐方式 flex-direction（主轴方向） 决定主轴的方向，默认值是 row（从左到右）。\n1 2 3 4 5 6 .container { flex-direction: row; /* 从左到右 (默认) */ flex-direction: row-reverse; /* 从右到左 */ flex-direction: column; /* 从上到下 */ flex-direction: column-reverse; /* 从下到上 */ } flex-wrap（是否换行） 1 2 3 4 5 .container { flex-wrap: nowrap; /* 默认值，不换行 */ flex-wrap: wrap; /* 换行 */ flex-wrap: wrap-reverse; /* 反向换行 */ } justify-content（主轴对齐方式） 1 2 3 4 5 6 7 8 .container { justify-content: flex-start; /* 默认，左对齐 */ justify-content: flex-end; /* 右对齐 */ justify-content: center; /* 居中 */ justify-content: space-between; /* 两端对齐，中间平均分布 */ justify-content: space-around; /* 每个元素两侧间距相等 */ justify-content: space-evenly; /* 每个元素之间间距相等 */ } align-items（交叉轴对齐方式） 1 2 3 4 5 6 7 .container { align-items: flex-start; /* 顶部对齐 */ align-items: flex-end; /* 底部对齐 */ align-items: center; /* 垂直居中 */ align-items: baseline; /* 文字基线对齐 */ align-items: stretch; /* 高度自动拉伸（默认） */ } align-content（多行对齐方式） 适用于 flex-wrap: wrap 的多行情况\n1 2 3 4 5 6 7 8 .container { align-content: flex-start; /* 多行从顶部开始 */ align-content: flex-end; /* 多行从底部开始 */ align-content: center; /* 多行居中 */ align-content: space-between; /* 两端对齐 */ align-content: space-around; /* 每行两侧间距相等 */ align-content: stretch; /* 让所有行填充整个容器（默认） */ } Flex 子项（子元素）属性 属性 作用 flex-grow 控制元素放大比例(默认 0，不放大) flex-shrink 控制元素缩小比例(默认 1，允许缩小) flex-basis 设定元素初始大小 flex flex-grow, flex-shrink, flex-basis 的缩写 align-self 控制单个元素在交叉轴上的对齐方式 flex-grow（放大比例） 决定了元素在 有剩余空间 时如何分配：\n1 2 3 4 5 .item { flex-grow: 0; /* 不放大（默认值） */ flex-grow: 1; /* 均分剩余空间 */ flex-grow: 2; /* 该元素会占据 2 份空间 */ } flex-shrink（缩小比例） 决定了元素在 空间不足 时如何缩小：\n1 2 3 4 .item { flex-shrink: 1; /* 默认值，允许缩小 */ flex-shrink: 0; /* 不允许缩小 */ } flex-basis（初始大小） 用于设定元素的初始大小（类似 width，但受 flex-grow 影响）：\n1 2 3 4 .item { flex-basis: auto; /* 默认，取决于内容大小 */ flex-basis: 100px; /* 初始宽度 100px */ } flex（简写属性） 等价于 flex-grow flex-shrink flex-basis：\n1 2 3 4 5 .item { flex: 1; /* 等价于 flex: 1 1 0%; */ flex: 2; /* 等价于 flex: 2 1 0%; */ flex: 1 0 auto; /* 允许放大，不缩小，大小取决于内容 */ } align-self（单个子项的对齐方式） 单独调整某个子项的 align-items：\n1 2 3 4 5 6 .item { align-self: flex-start; /* 顶部对齐 */ align-self: flex-end; /* 底部对齐 */ align-self: center; /* 居中对齐 */ align-self: stretch; /* 拉伸填充 */ } ","date":"2025-03-12T12:22:21+08:00","permalink":"https://www.cengdong.store/p/cssflex%E5%B8%83%E5%B1%80/","title":"【CSS】Flex布局"},{"content":"介绍 在 Python 中，作用域（Scope） 和 命名空间（Namespace） 是管理变量访问和存储的核心概念。理解它们对于编写高效、可维护的代码非常重要。\n作用域 作用域 指的是 变量的可见范围，决定了变量在程序中的哪些部分可以被访问。\nPython 采用 LEGB 规则 确定变量的作用域：\nL（Local，局部作用域）：函数内部定义的变量，仅在函数内部有效。 E（Enclosing，嵌套作用域）：嵌套函数的外层函数作用域（非全局）。 G（Global，全局作用域）：当前 Python 文件（模块）内的全局变量。 B（Built-in，内置作用域）：Python 内置的变量，比如 len()、print()。 LEGB 规则的搜索顺序：\nLocal（局部） → Enclosing（嵌套） → Global（全局） → Built-in（内置） 一旦找到匹配的变量，就不会继续向上搜索。 作用域示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def scope_test(): def do_local(): spam = \u0026#34;local spam\u0026#34; def do_nonlocal(): nonlocal spam spam = \u0026#34;nonlocal spam\u0026#34; def do_global(): global spam spam = \u0026#34;global spam\u0026#34; spam = \u0026#34;test spam\u0026#34; do_local() print(\u0026#34;After local assignment:\u0026#34;, spam) do_nonlocal() print(\u0026#34;After nonlocal assignment:\u0026#34;, spam) do_global() print(\u0026#34;After global assignment:\u0026#34;, spam) scope_test() print(\u0026#34;In global scope:\u0026#34;, spam) 代码的输出是\n1 2 3 4 After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam 命名空间 命名空间 是存储变量（名字 → 值 映射）的地方，每个变量名在 Python 里都会被存储在某个命名空间中。\n局部命名空间 每个函数都会创建自己的局部命名空间，存储局部变量。 变量在函数执行完后会被销毁。 1 2 3 4 def foo(): x = 10 # x 在局部命名空间 print(x) foo() 全局命名空间 存储模块级变量，即定义在函数之外的变量。 只要 Python 解释器运行，变量就存在。 1 2 3 4 y = 20 # y 在全局命名空间 def bar(): print(y) # 访问全局变量 bar() 内置命名空间 由 Python 解释器预定义的内置函数和对象，例如 print(), len(), list()。\n1 print(len([1, 2, 3])) # 访问内置命名空间的 `len` 命名空间生命周期 函数内部赋值的变量 会被认为是局部变量，不会影响外部变量。 要修改全局变量，需要使用 global 关键字。 要修改嵌套作用域变量，需要使用 nonlocal 关键字。 global 与 nonlocal 关键字 在 Python 中，默认情况下：\n函数内部赋值的变量 会被认为是局部变量，不会影响外部变量。 要修改全局变量，需要使用 global 关键字。 要修改嵌套作用域变量，需要使用 nonlocal 关键字。 1 2 3 4 5 6 7 8 x = 100 # 全局变量 def change_global(): global x # 声明使用全局变量 x = 200 # 修改全局变量 change_global() print(x) # 输出 200 💡 不加 global，x 在 change_global() 内部是局部变量，不会影响外部变量。\n1 2 3 4 5 6 7 8 9 10 11 def outer(): x = 10 # 外部（Enclosing 作用域） def inner(): nonlocal x # 声明 `x` 来自外部作用域 x = 20 # 修改 `outer()` 里的 `x` inner() print(x) # 输出 20 outer() 💡 不加 nonlocal，inner() 里的 x 只是局部变量，不会影响 outer() 里的 x。\n作用域与命名空间的关系 作用域是变量的可见范围，而命名空间是变量的存储位置。 作用域决定了 Python 解释器在多个命名空间中如何查找变量。 Python 按照 LEGB 规则 在不同的命名空间中搜索变量。 locals() 与 globals() locals() 和 globals() 是 Python 内置的两个函数，它们分别用于访问 局部命名空间（Local Namespace） 和 全局命名空间（Global Namespace）。\n注意：locals()函数在全局作用域调用，返回的就是全局命名空间的字典\n","date":"2025-03-10T19:33:02+08:00","permalink":"https://www.cengdong.store/p/python%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","title":"【Python】作用域与命名空间"},{"content":"logging 介绍 日志是对软件执行时所发生事件的一种追踪方式。软件开发人员对他们的代码添加日志调用，借此来指示某事件的发生。\n什么时候使用日志 你可以通过执行 logger = getLogger(__name__) 创建一个日志记录器然后调用日志记录器的 debug(), info(), warning(), error() 和 critical() 方法来使用日志记录功能。 要确定何时使用日志记录，以及确定要使用哪个日志记录器方法，请参阅下表。 它针对一组常见任务中的每一个都列出了最适合该任务的工具。\n你想要执行的任务 此任务最好的工具 对于命令行或程序的应用，结果显示在控制台。 print() 在对程序的普通操作发生时提交事件报告(比如：状态监控和错误调查) 日志记录器的 info() (或者对于诊断目的需要非常详细的输出时则使用 debug() 方法) 提出一个警告信息基于一个特殊的运行时事件 warnings.warn() 位于代码库中，该事件是可以避免的，需要修改客户端应用以消除告警 对于客户端应用无法干预，但事件仍然需要被关注的场合则使用日志记录器的 warning() 方法 对一个特殊的运行时事件报告错误 引发异常 报告错误而不引发异常(如在长时间运行中的服务端进程的错误处理) 日志记录器的 error(), exception() 或 critical() 方法分别适用于特定的错误及应用领域 日志的级别 级别 何时使用 DEBUG 细节信息，仅当诊断问题时适用。 INFO 确认程序按预期运行。 WARNING 表明有已经或即将发生的意外（例如：磁盘空间不足）。程序仍按预期进行。 ERROR 由于严重的问题，程序的某些功能已经不能正常执行 CRITICAL 严重的错误，表明程序已不能继续执行 示例 基础用法 1 2 3 import logging logging.warning(\u0026#39;Watch out!\u0026#39;) # 将打印一条消息到控制台 logging.info(\u0026#39;I told you so\u0026#39;) # 将不打印任何消息 INFO 消息没有出现是因为默认级别为 WARNING\n在这个例子中，我们是直接使用 logging 模块的函数，比如 logging.debug，而不是创建一个日志记录器并调用其方法。 这些函数是在根日志记录器上操作的，但它们在未被调用时将会调用 basicConfig()来发挥作用，就像在这个例子中那样。 然而在更大的程序中你通常会需要显式地控制日志记录的配置 —— 所以出于这样那样的理由，最好还是创建日志记录器并调用其方法\n记录日志到文件 1 2 3 4 5 6 7 import logging logger = logging.getLogger(__name__) logging.basicConfig(filename=\u0026#39;example.log\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, level=logging.DEBUG) logger.debug(\u0026#39;This message should go to the log file\u0026#39;) logger.info(\u0026#39;So should this\u0026#39;) logger.warning(\u0026#39;And this, too\u0026#39;) logger.error(\u0026#39;And non-ASCII stuff, too, like Øresund and Malmö\u0026#39;) 上面的示例将日志事件记录到文件中并设置了日志等级\n显示消息的格式 1 2 3 4 5 import logging logging.basicConfig(format=\u0026#39;%(levelname)s:%(message)s\u0026#39;, level=logging.DEBUG) logging.debug(\u0026#39;This message should appear on the console\u0026#39;) logging.info(\u0026#39;So should this\u0026#39;) logging.warning(\u0026#39;And this, too\u0026#39;) 在消息中显示日期/时间\n1 2 3 import logging logging.basicConfig(format=\u0026#39;%(asctime)s %(message)s\u0026#39;) logging.warning(\u0026#39;is when this event was logged.\u0026#39;) 进阶日志教程 日志库采用模块化方法，并提供几类组件：记录器、处理器、过滤器和格式器。\n记录器暴露了应用程序代码直接使用的接口。 处理器将日志记录（由记录器创建）发送到适当的目标。 过滤器提供了更细粒度的功能，用于确定要输出的日志记录。 格式器指定最终输出中日志记录的样式。 最佳实践 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import logging import os # 日志文件路径 LOG_DIR = \u0026#34;logs\u0026#34; os.makedirs(LOG_DIR, exist_ok=True) # 确保日志目录存在 LOG_FILE = os.path.join(LOG_DIR, \u0026#34;app.log\u0026#34;) # 创建日志器（全局使用） logger = logging.getLogger(\u0026#34;my_app\u0026#34;) logger.setLevel(logging.DEBUG) # 设置最低日志级别 # 创建格式化器（统一日志格式） formatter = logging.Formatter( \u0026#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#34; ) # 创建控制台 Handler console_handler = logging.StreamHandler() console_handler.setLevel(logging.INFO) # 仅输出 INFO 及以上的日志 console_handler.setFormatter(formatter) # 创建文件 Handler file_handler = logging.FileHandler(LOG_FILE, encoding=\u0026#34;utf-8\u0026#34;) file_handler.setLevel(logging.DEBUG) # 记录所有级别的日志 file_handler.setFormatter(formatter) # 绑定 Handler（避免重复添加） if not logger.handlers: logger.addHandler(console_handler) logger.addHandler(file_handler) # 测试日志 logger.debug(\u0026#34;这是一条 DEBUG 日志\u0026#34;) logger.info(\u0026#34;这是一条 INFO 日志\u0026#34;) logger.warning(\u0026#34;这是一条 WARNING 日志\u0026#34;) logger.error(\u0026#34;这是一条 ERROR 日志\u0026#34;) logger.critical(\u0026#34;这是一条 CRITICAL 日志\u0026#34;) ","date":"2025-03-08T19:13:43+08:00","permalink":"https://www.cengdong.store/p/pythonlogging%E6%A8%A1%E5%9D%97/","title":"【Python】logging模块"},{"content":"介绍 这个模块实现了一些专门化的容器，提供了对 Python 的通用内建容器 dict、list、set 和 tuple 的补充。\n类 作用 namedtuple() 一个工厂函数，用来创建元组的子类，子类的字段是有名称的。 deque 类似列表的容器，但 append 和 pop 在其两端的速度都很快。 ChainMap 类似字典的类，用于创建包含多个映射的单个视图。 Counter 用于计数 hashable 对象的字典子类 OrderedDict 字典的子类，能记住条目被添加进去的顺序。 defaultdict 字典的子类，通过调用用户指定的工厂函数，为键提供默认值。 UserDict 封装了字典对象，简化了字典子类化 UserList 封装了列表对象，简化了列表子类化 UserString 封装了字符串对象，简化了字符串子类化 ChainMap ChainMap 类将多个映射迅速地链到一起，这样它们就可以作为一个单元处理。这通常比创建一个新字典再重复地使用 update() 要快得多。\nclass collections.ChainMap(*maps)\n基本用法 1 2 3 4 5 6 7 from collections import ChainMap dict1 = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} dict2 = {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4} cm = ChainMap(dict1, dict2) print(cm) # ChainMap({\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2}, {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4}) ChainMap 的键值查找规则 1 2 3 print(cm[\u0026#39;a\u0026#39;]) # 1 （来自 dict1） print(cm[\u0026#39;b\u0026#39;]) # 2 （dict1 覆盖了 dict2 的 \u0026#39;b\u0026#39;） print(cm[\u0026#39;c\u0026#39;]) # 4 （来自 dict2） ChainMap 按照 从左到右（即 从第一个字典到最后一个字典）的顺序进行查找。 b 在 dict1 和 dict2 都存在，但 dict1 里的值 优先级更高。 如果查找一个不存在的键，会报 KeyError：\n1 print(cm[\u0026#39;d\u0026#39;]) # KeyError: \u0026#39;d\u0026#39; ChainMap 的修改规则 修改 ChainMap 只会影响第一个字典\n1 2 3 cm[\u0026#39;b\u0026#39;] = 99 print(dict1) # {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 99} print(dict2) # {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4} 直接修改 cm[\u0026lsquo;b\u0026rsquo;] 只会影响 dict1，不会影响 dict2。 ChainMap 只允许修改 第一个字典中的值。 新增键值对也会加到第一个字典中 ChainMap 的动态特性 ChainMap 动态反映底层字典的变化：\n1 2 dict1[\u0026#39;a\u0026#39;] = 42 print(cm[\u0026#39;a\u0026#39;]) # 42 （dict1 改变后，ChainMap 也会更新） ChainMap 的方法 maps - 访问所有字典 1 print(cm.maps) # [{\u0026#39;a\u0026#39;: 42, \u0026#39;b\u0026#39;: 99, \u0026#39;d\u0026#39;: 100}, {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4}] new_child() - 创建新的 ChainMap 1 2 cm2 = cm.new_child({\u0026#39;e\u0026#39;: 5}) print(cm2) # ChainMap({\u0026#39;e\u0026#39;: 5}, {\u0026#39;a\u0026#39;: 42, \u0026#39;b\u0026#39;: 99, \u0026#39;d\u0026#39;: 100}, {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4}) 这样 cm2 里 e 只会影响最前面的新字典，cm 不受影响。 这在作用域管理中很有用（比如 Python 解释器的变量查找）。 ChainMap 的应用场景 配置管理 在应用程序中，我们通常有 默认配置，但也允许用户提供 自定义配置：\n1 2 3 4 5 6 7 default_config = {\u0026#39;theme\u0026#39;: \u0026#39;light\u0026#39;, \u0026#39;font\u0026#39;: \u0026#39;Arial\u0026#39;, \u0026#39;timeout\u0026#39;: 30} user_config = {\u0026#39;theme\u0026#39;: \u0026#39;dark\u0026#39;, \u0026#39;timeout\u0026#39;: 60} config = ChainMap(user_config, default_config) print(config[\u0026#39;theme\u0026#39;]) # dark （用户配置覆盖默认配置） print(config[\u0026#39;font\u0026#39;]) # Arial （用户未提供，使用默认值） 这样就能 优先使用用户配置，如果没有，就用默认值。\n变量作用域 Python 解释器在查找变量时，会按 局部 -\u0026gt; 全局 -\u0026gt; 内置 的顺序进行查找，这与 ChainMap 类似：\n1 2 3 4 5 6 7 global_scope = {\u0026#39;x\u0026#39;: 10, \u0026#39;y\u0026#39;: 20} local_scope = {\u0026#39;y\u0026#39;: 5, \u0026#39;z\u0026#39;: 30} env = ChainMap(local_scope, global_scope) print(env[\u0026#39;x\u0026#39;]) # 10 （来自全局作用域） print(env[\u0026#39;y\u0026#39;]) # 5 （局部作用域优先） print(env[\u0026#39;z\u0026#39;]) # 30 （来自局部作用域） 命令行参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import argparse # 定义命令行参数 parser = argparse.ArgumentParser() parser.add_argument(\u0026#39;--timeout\u0026#39;, type=int) parser.add_argument(\u0026#39;--theme\u0026#39;, type=str) args = parser.parse_args([]) # 模拟不传递参数 cli_args = {k: v for k, v in vars(args).items() if v is not None} # 默认配置 default_settings = {\u0026#39;theme\u0026#39;: \u0026#39;light\u0026#39;, \u0026#39;timeout\u0026#39;: 30} config = ChainMap(cli_args, default_settings) print(config[\u0026#39;theme\u0026#39;]) # light print(config[\u0026#39;timeout\u0026#39;]) # 30 defaultdict defaultdict 是 Python collections 模块中的一个字典子类，它和普通的 dict 很相似，但有一个关键的区别：当访问不存在的键时，defaultdict 不会报 KeyError，而是返回一个默认值，这个默认值由一个工厂函数提供。\ndefaultdict 基本用法 1 2 3 4 5 6 7 from collections import defaultdict # 创建一个默认值为 list 的 defaultdict d = defaultdict(list) # 访问不存在的键，返回一个新的空列表 print(d[\u0026#34;key\u0026#34;]) # 输出：[] 对比普通字典：\n1 2 d = {} print(d[\u0026#34;key\u0026#34;]) # ❌ KeyError defaultdict 的参数 1 defaultdict(default_factory[, ...]) default_factory：用于生成默认值的可调用对象（如 list、int、set、lambda 等）。 其他参数和 dict 一样。 常见默认工厂 默认值为 int（适用于计数器） 1 2 3 4 5 6 d = defaultdict(int) d[\u0026#34;apple\u0026#34;] += 1 d[\u0026#34;banana\u0026#34;] += 1 print(d) # {\u0026#39;apple\u0026#39;: 1, \u0026#39;banana\u0026#39;: 1} 默认值为 list（适用于分组） 1 2 3 4 5 6 7 8 d = defaultdict(list) d[\u0026#34;fruits\u0026#34;].append(\u0026#34;apple\u0026#34;) d[\u0026#34;fruits\u0026#34;].append(\u0026#34;banana\u0026#34;) d[\u0026#34;vegetables\u0026#34;].append(\u0026#34;carrot\u0026#34;) print(d) # {\u0026#39;fruits\u0026#39;: [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;], \u0026#39;vegetables\u0026#39;: [\u0026#39;carrot\u0026#39;]} 默认值为 set（去重分组） 1 2 3 4 5 6 7 8 d = defaultdict(set) d[\u0026#34;fruits\u0026#34;].add(\u0026#34;apple\u0026#34;) d[\u0026#34;fruits\u0026#34;].add(\u0026#34;banana\u0026#34;) d[\u0026#34;fruits\u0026#34;].add(\u0026#34;apple\u0026#34;) # 重复添加，不会重复存储 print(d) # {\u0026#39;fruits\u0026#39;: {\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;}} OrderedDict OrderedDict 是 collections 模块中的有序字典，它继承自 dict，但能够保持键值对的插入顺序（在 Python 3.7+ 的 dict 也默认保持顺序，但 OrderedDict 仍有一些额外功能）\n创建 OrderedDict 1 2 3 4 5 6 7 8 9 from collections import OrderedDict # 普通 dict（Python 3.7+ 默认保持顺序） d1 = {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} print(d1) # {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} # OrderedDict（显式使用） d2 = OrderedDict([(\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)]) print(d2) # OrderedDict([(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3)]) 特点：\nPython 3.6 及以下：普通 dict 不会 维持插入顺序，OrderedDict 可以。 Python 3.7+：普通 dict 默认 维持顺序，但 OrderedDict 仍然提供额外方法。 OrderedDict 关键特性 按照插入顺序迭代 1 2 3 4 5 6 7 8 9 10 11 12 d = OrderedDict() d[\u0026#34;x\u0026#34;] = 10 d[\u0026#34;y\u0026#34;] = 20 d[\u0026#34;z\u0026#34;] = 30 for k, v in d.items(): print(k, v) # 输出： # x 10 # y 20 # z 30 ✅ 顺序保持不变 支持 move_to_end 调整顺序 move_to_end(key, last=True) 可以移动指定键到末尾或开头：\n1 2 3 4 5 6 7 d = OrderedDict([(\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)]) d.move_to_end(\u0026#34;a\u0026#34;) # 把 \u0026#39;a\u0026#39; 移到末尾 print(d) # OrderedDict([(\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3), (\u0026#39;a\u0026#39;, 1)]) d.move_to_end(\u0026#34;c\u0026#34;, last=False) # 把 \u0026#39;c\u0026#39; 移到开头 print(d) # OrderedDict([(\u0026#39;c\u0026#39;, 3), (\u0026#39;b\u0026#39;, 2), (\u0026#39;a\u0026#39;, 1)]) 支持 popitem()取出(FIFO/LIFO) popitem(last=True):\nlast=True（默认）➡ 后进先出（LIFO） last=False ➡ 先进先出（FIFO） 1 2 3 4 5 d = OrderedDict([(\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)]) print(d.popitem()) # (\u0026#39;c\u0026#39;, 3) ✅ 默认 LIFO print(d.popitem(last=False)) # (\u0026#39;a\u0026#39;, 1) ✅ FIFO print(d) # OrderedDict([(\u0026#39;b\u0026#39;, 2)]) OrderedDict 应用场景 由于 OrderedDict 维护顺序，它可以实现 LRU（最近最少使用）缓存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key): if key not in self.cache: return -1 self.cache.move_to_end(key) # 最近访问的移动到末尾 return self.cache[key] def put(self, key, value): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) \u0026gt; self.capacity: self.cache.popitem(last=False) # 移除最早插入的元素（FIFO） # 示例 cache = LRUCache(2) cache.put(1, \u0026#34;A\u0026#34;) cache.put(2, \u0026#34;B\u0026#34;) print(cache.cache) # OrderedDict([(1, \u0026#39;A\u0026#39;), (2, \u0026#39;B\u0026#39;)]) cache.get(1) # 访问 1，使其变成最近使用 cache.put(3, \u0026#34;C\u0026#34;) # 淘汰最久未使用的 2 print(cache.cache) # OrderedDict([(1, \u0026#39;A\u0026#39;), (3, \u0026#39;C\u0026#39;)]) ","date":"2025-03-07T16:45:07+08:00","permalink":"https://www.cengdong.store/p/pythoncollections%E6%A8%A1%E5%9D%97/","title":"【Python】collections模块"},{"content":"CSS 属性计算过程 CSS 属性计算过程是指元素从所有 CSS 属性都没有值到所有 CSS 属性都有值，中间经历的过程。\nCSS 属性计算过程可以分为以下几个步骤：\n确定声明值 层叠 继承 使用默认值 确定声明值 关注两个样式表：\n作者样式表 浏览器默认样式表 找到这两个样式表中没有冲突的样式，直接作为计算后的样式\n层叠 层叠的样式经过层叠规则确定样式\n继承 有些样式通过继承获得，如字体、颜色、边框、背景等\n使用默认值 如果没有其他样式可以继承，则使用浏览器默认样式\n","date":"2024-11-28T22:09:23+08:00","permalink":"https://www.cengdong.store/p/csscss%E5%B1%9E%E6%80%A7%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/","title":"【CSS】css属性计算过程"},{"content":"层叠规则 比较重要性 比较特殊性 比较源次序 重要性 带有 important 的作者样式 带有 important 的默认样式 作者样式 浏览器默认样式 特殊性 特殊性是指样式的具体性质，具体来说，就是样式的来源和权重。\n对每个样式分别计数：\nstyle 是否内联 id 属性/类/伪类 元素/伪元素 源次序 后面覆盖前面，后面的样式会覆盖前面的样式。\n","date":"2024-11-28T21:56:37+08:00","permalink":"https://www.cengdong.store/p/csscss%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99/","title":"【CSS】css层叠规则"},{"content":"冠词 冠词的分类 不定冠词：a/an 定冠词：the 零冠词：无冠词 冠词的用法 不定冠词： 泛指用法: I saw a rabbit 表示数字\u0026quot;1\u0026quot;: an apple 表示\u0026quot;每\u0026quot;: a day = every day 主谓一致: a teacher and a video creator 固定表达：have a good time; as a result; in a hurry; all of a sudden; 定冠词： 特指用法: I saw a rabbit, the rabbit ran fast. 泛指用法: 西洋古典乐器：play the piano; 在形容词前：the beautiful girl 在序数词前/最高级：the first time 固定表达：all the time; by the way; in the end; out of the question; 零冠词： 复数泛指: rabbits are smart 专有名词: Papa Rabbit 泛指概念/复数: Summer is hot 固定表达：fish and chips; bread and butter; tea and coffee; 动词 实义动词 按照动作承受者划分： 及物动词：动词后面需要加宾语，表示动作的承受者。 不及物动词：动词后面不需要加宾语，表示动作的执行者。 按照动作状态划分： 动作动词 感官动词 系动词 系动词的作用就是给系动词前的对象赋值\nbe 感官动词：looks, tastes, smells, sounds, feels 一直：remained 慢慢增长: grrew 变得：became 保持：remained 持续：continued 消失：disappeared 助动词 按照动作状态划分： 短时助动词：表示动作的执行者正在执行某种动作。 长时助动词：表示动作的执行者已经完成了某种动作。 按照动作状态划分： 短时助动词：表示动作的执行者正在执行某种动作。 长时助动词：表示动作的执行者已经完成了某种动作。 情态动词 按照动作状态划分： 短时情态动词：表示动作的执行者正在执行某种动作。 长时情态动词：表示动作的执行者已经完成了某种动作。 按照动作状态划分： 短时情态动词：表示动作的执行者正在执行某种动作。 长时情态动词：表示动作的执行者已经完成了某种动作。 非谓语动词 不定式 动名词 现在分词 过去分词 名词 名词的分类 普通名词 专有名词 动名词 形容词 数词 介词 代词 连词 介词 放置在前面的词就叫介词：preposition + 名词/代词\n介词组成：\n简单介词: in; on; at; over; 介词短语：by way of; at the end of; along with; because of; previous to; 合成介词：into, onto, within 分词介词 按照作用划分：\n时间介词：in, on, at, over, above, under, below, near, by/beside, next to, across, through, past, in front of, before, behind, between \u0026hellip;and \u0026hellip;, among, round, around, along, to , towards, onto, into, out of 空间介词：in, on, at, during, for, since, before, after, from \u0026hellip; to \u0026hellip;, by, until 方式介词：in, through, by, with, on 原因介词：for, with, because/ because of, due to, as a result of, in order to, in the hope of, in case of 关于介词：about, concerning, on, in, of, for, to, with, from, by 数值介词：at, by, for 目的介词：for, in order to, to, in the hope of, in case of 条件介词：if, unless, in case of, in the event of, in the face of 比较介词：with, against, compared with, in comparison with, in contrast to, in the same way as, like, as, as if, as though 代词 代词分类：\n人称代词：I, you, he, she, we, they 人称代词宾格：me, you, him, her, us, them 形容词性物主代词：my, your, his, her, our, their 名词性物主代词：mine, yours, his, hers, ours, theirs 反身代词：myself, yourself, himself, herself, ourselves, themselves 强调代词：myself, yourself, himself, herself, ourselves, themselves 指示代词：this, that, these, those 相互代词：each other, one another 不定代词：some, any, every, all, none, much, many, few, little 疑问代词：who, what, where, when, why, how 连词代词：either, neither, both, all, none, some, any, each, every 关系代词：who, which, that ","date":"2024-07-23T21:18:47+08:00","permalink":"https://www.cengdong.store/p/english%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"【English】英语语法学习笔记"},{"content":"React 开发环境搭建 安装 nodejs：官网下载最近 LTS 版本 安装集成开发环境：vscode 创建 react 项目： npx create-react-app project-name npm create vite@latest React 核心语法：JSX JSX是 Javascript 和 Html 的缩写，表示在js代码中编写html模版\nJSX不能直接在浏览器中运行，需要bable进行编码成纯 js 代码\nJSX 基础 JSX 识别 js 表达式 JSX 通过{}语法可以识别 js 表达式\n可运行以下 js 表达式：\n字符串：{\u0026ldquo;hello world\u0026rdquo;}(支持模版字符串) 变量/js 语句(运算符) 函数调用 方法调用 列表渲染 1 2 3 4 5 6 7 8 function List() { const list = [\u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;] return ( \u0026lt;ul\u0026gt; list.map(item =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item}\u0026lt;/li\u0026gt;) \u0026lt;/ul\u0026gt; ) } 简单条件渲染 对于简单的条件渲染，可通过逻辑与运算符或者三目运算符实现\n1 2 3 4 5 6 7 8 9 const isLogin = true function UserInfo({ username }) { return ( \u0026lt;\u0026gt; isLogin ? \u0026lt;p\u0026gt;username: {username}\u0026lt;/p\u0026gt; : \u0026lt;p\u0026gt;请登录\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ) } 复杂条件渲染 复杂的条件渲染通过函数实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const type = 0 function showTypedTemplate() { if (type === 0) { return \u0026lt;div\u0026gt;我是type0\u0026lt;/div\u0026gt; } if (type === 1) { return \u0026lt;div\u0026gt;我是type1\u0026lt;/div\u0026gt; } if (type === 2) { return \u0026lt;div\u0026gt;我是type2\u0026lt;/div\u0026gt; } } func Article() { return showTypedTemplate() } React 事件绑定 语法 on + 事件名称 = {事件处理函数}\n使用事件对象 在事件处理函数中使用形参e\n1 2 3 4 5 6 7 8 9 10 11 12 13 function App() { const handlerFunc = (e) =\u0026gt; { console.log(e) } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handlerFunc}\u0026gt;click me\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App 传递参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function App() { const handlerFunc = (e, name) =\u0026gt; { console.log(e, name) } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={(e) =\u0026gt; { handlerFunc(\u0026#39;cengdong\u0026#39;) }} \u0026gt; click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App React 组件状态管理 给 React 组件添加一个状态变量，让组件在不同状态下有不同表现\nuseState 基本使用 通过 useState hook 函数给组件添加一个计数器变量\n1 2 3 4 5 6 7 8 9 fucntion App() { const [state, setState] = useState(0) const clickHandle = () =\u0026gt; { setState(count + 1) } return \u0026lt;button onClick={clickHandle}\u0026gt;{state}\u0026lt;/button\u0026gt; } useState 注意事项 状态变量是不可变的，只能通过setXXX函数，并且传入新的值来改变状态\n直接修改状态不能引发视图更新\nuseState 案例 tabl 栏切换 通过 useSate(type)记录 type 状态 通过事件回调函数调用状态修改函数，传递被点击项的 type 值为参数 通过 classnames 插件优雅实现类名切换 表单受控绑定 通过表单value属性绑定状态，通过onChange事件属性绑定状态同步的函数\n1 2 3 4 5 6 7 function App() { const [content, setContent] = useState(\u0026#34;\u0026#34;) const clickHandle = () =\u0026gt; { setContent(\u0026#34;\u0026#34;) } return \u0026lt;input type=text value={content} onChange={(e) =\u0026gt; setContent(e.target.value)}/\u0026gt; } React 获取 Dom 元素 通过 useRef hook 获取 dom 元素从而调用 dom 元素的方法\nuseRef 基本用法 1 2 3 4 5 6 7 8 function App() { const inputRef = useRef(null) const publishHandle = () =\u0026gt; { inputRef.current.focus() } return \u0026lt;input ref={inoutRef} onClick={publichHandle} /\u0026gt; } 注意事项 渲染完毕之后，dom 才可用\nuseRef 使用场景 获取 Dom 元素，调用 Dom 元素的属性或者方法 引用一个不需要被渲染的值 ref 不仅可以引用单个 dom 元素，也可以引用一个列表 父组件要获取子组件 Dom 需要 forwardRef 函数做处理，因为 React 框架不允许 组件间通信 父传子 实现步骤：\n父组件传递数据：在子组件标签上绑定属性 子组件接收数据：子组件通过props参数接受数据 props 说明 props 对象包含了父组件传递过来的所有数据 props 对象能传递任意类型的数据 props 对象是只读对象 children 说明 在子组件内部还可以嵌套内容，同样会给子组件传递数据，存在 props 对象children属性上\n子传父 子组件调用父组件传递过来的函数 通过函数参数传递数据给父组件 兄弟组件通信 兄弟组件之间通过状态提升传递数据\n数据跨层通信 使用 createContext 函数创建一个上下文对象 Ctx 在顶层组件(App)中通过 Ctx.Provider 组件提供数据 在底层组件(B)中通过 useContext hook 获取消费数据 useEffect useEffect 是一个 React Hook，它允许你 将组件与外部系统同步\n参考 useEffect(setup, dependencies?)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useEffect } from \u0026#39;react\u0026#39; import { createConnection } from \u0026#39;./chat.js\u0026#39; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState(\u0026#39;https://localhost:1234\u0026#39;) useEffect(() =\u0026gt; { const connection = createConnection(serverUrl, roomId) connection.connect() return () =\u0026gt; { connection.disconnect() } }, [serverUrl, roomId]) // ... } setup：处理 Effect 的函数。setup 函数选择性返回一个 清理（cleanup） 函数。当组件被添加到 DOM 的时候，React 将运行 setup 函数。在每次依赖项变更重新渲染后，React 将首先使用旧值运行 cleanup 函数（如果你提供了该函数），然后使用新值运行 setup 函数。在组件从 DOM 中移除后，React 将最后一次运行 cleanup 函数。\n可选 dependencies：setup 代码中引用的所有响应式值的列表。响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数。如果你的代码检查工具 配置了 React，那么它将验证是否每个响应式值都被正确地指定为一个依赖项。依赖项列表的元素数量必须是固定的，并且必须像 [dep1, dep2, dep3] 这样内联编写。React 将使用 Object.is 来比较每个依赖项和它先前的值。如果省略此参数，则在每次重新渲染组件之后，将重新运行 Effect 函数。如果你想了解更多，请参见 传递依赖数组、空数组和不传递依赖项之间的区别。\n不同依赖项的区别 依赖项 副作用函数执行时机 没有依赖项 组件初次渲染+组件更新时 空数组 组件初次渲染 特定依赖项 组件初次渲染+依赖项变化 注意事项：\nuseEffect 是一个 Hook，因此只能在 组件的顶层 或自己的 Hook 中调用它，而不能在循环或者条件内部调用。如果需要，抽离出一个新组件并将 state 移入其中。 如果你 没有打算与某个外部系统同步，那么你可能不需要 Effect。 当严格模式启动时，React 将在真正的 setup 函数首次运行前，运行一个开发模式下专有的额外 setup + cleanup 周期。这是一个压力测试，用于确保 cleanup 逻辑“映射”到了 setup 逻辑，并停止或撤消 setup 函数正在做的任何事情。如果这会导致一些问题，请实现 cleanup 函数。 如果你的一些依赖项是组件内部定义的对象或函数，则存在这样的风险，即它们将 导致 Effect 过多地重新运行。要解决这个问题，请删除不必要的 对象 和 函数 依赖项。你还可以 抽离状态更新 和 非响应式的逻辑 到 Effect 之外。 如果你的 Effect 不是由交互（比如点击）引起的，那么 React 会让浏览器 在运行 Effect 前先绘制出更新后的屏幕。如果你的 Effect 正在做一些视觉相关的事情（例如，定位一个 tooltip），并且有显著的延迟（例如，它会闪烁），那么将 useEffect 替换为 useLayoutEffect。 如果你的 Effect 是由一个交互（比如点击）引起的，React 可能会在浏览器重新绘制屏幕之前执行 Effect。通常情况下，这样是符合预期的。但是，如果你必须要推迟 Effect 执行到浏览器绘制之后，和使用 alert() 类似，可以使用 setTimeout。有关更多信息，请参阅 reactwg/react-18/128。 即使你的 Effect 是由一个交互（比如点击）引起的，React 也可能允许浏览器在处理 Effect 内部的状态更新之前重新绘制屏幕。通常，这样是符合预期的。但是，如果你一定要阻止浏览器重新绘制屏幕，则需要用 useLayoutEffect 替换 useEffect。 Effect 只在客户端上运行，在服务端渲染中不会运行。 使用场景 连接到外部系统 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { useEffect } from \u0026#39;react\u0026#39; import { createConnection } from \u0026#39;./chat.js\u0026#39; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState(\u0026#39;https://localhost:1234\u0026#39;) useEffect(() =\u0026gt; { const connection = createConnection(serverUrl, roomId) connection.connect() return () =\u0026gt; { connection.disconnect() } }, [serverUrl, roomId]) // ... } 在自定义 Hook 中封装 Effect Effect 是一种脱围机制：当你需要“走出 React 之外”或者当你的使用场景没有更好的内置解决方案时，你可以使用它们。如果你发现自己经常需要手动编写 Effect，那么这通常表明你需要为组件所依赖的通用行为提取一些 自定义 Hook。\n例如，这个 useChatRoom 自定义 Hook 把 Effect 的逻辑“隐藏”在一个更具声明性的 API 之后：\n1 2 3 4 5 6 7 8 9 10 11 function useChatRoom({ serverUrl, roomId }) { useEffect(() =\u0026gt; { const options = { serverUrl: serverUrl, roomId: roomId, } const connection = createConnection(options) connection.connect() return () =\u0026gt; connection.disconnect() }, [roomId, serverUrl]) } ","date":"2024-07-12T10:23:54+08:00","permalink":"https://www.cengdong.store/p/reactreact%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","title":"【React】React基础入门"},{"content":"正则表达式 ","date":"2024-05-01T22:49:12+08:00","permalink":"https://www.cengdong.store/p/javascriptwebapis%E5%85%AD/","title":"【JavaScript】webAPIs六"},{"content":"window 对象 BOM(浏览器对象模型) BOM(Browser Object Model ) 是浏览器对象模型 window 对象是一个全局对象，也可以说是 JavaScript 中的顶级对象 像 document、alert()、console.log()这些都是 window 的属性，基本 BOM 的属性和方法都是 window 的。 所有通过 var 定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法 window 对象下的属性和方法调用的时候可以省略 window window 对象组成：\ndocument location navigation history screen 定时器-延迟函数 语法：\n1 2 3 4 // 设置延迟函数 let timerId = setTimeout(function () {}, 1000) // 清除延迟函数 clearTimeout(timerId) 延迟函数与间歇函数对比：\n延时函数: 执行一次 间歇函数:每隔一段时间就执行一次,除非手动清除 Js 执行机制 JavaScript 语言的一大特点就是单线程 HTML5 提出Web Worker标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步 同步任务都在主线程上执行，形成一个执行栈 异步任务相关添加到任务队列中 先执行执行栈中的同步任务，一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 异步任务分类：\n普通事件，如 click、resize 等 资源加载，如 load、error 等 定时器，包括 setInterval、setTimeout 等 location 对象 location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分\n常用属性和方法：\nhref 属性获取完整的 URL 地址，对其赋值时用于地址的跳转 search 属性获取地址中携带的参数，符号 ？后面部分 hash 属性获取地址中的啥希值，符号 # 后面部分 reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新 navigator 对象 navigator 的数据类型是对象，该对象下记录了浏览器自身的相关信息\n常用属性和方法：通过 userAgent 检测浏览器的版本及平台\n1 2 3 4 5 6 7 8 9 10 11 // 检测 userAgent（浏览器信息） !(function () { const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) { location.href = \u0026#39;http://m.itcast.cn\u0026#39; } })() history 对象 history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等\n常用属性和方法：\nhistory 对象方法 说明 back() 后退 1 步 forward() 前进 1 步 go(步数) 正数前进，负数后退 本地存储 本地存储介绍 数据存储在用户浏览器中 设置、读取方便、甚至页面刷新不丢失数据 容量较大，sessionStorage 和 localStorage 约 5M 左右 本地存储分类 localStorage 可以将数据永久存储在本地(用户的电脑), 除非手动删除，否则关闭页面也会存在\n特性：\n可以多窗口（页面） 共享（同一浏览器可以共享） 语法：\n存储/修改数据：localSotrage.setItem('key', 'value') 获取数据：localStorage.getItem('key') 删除数据：localStorage.removeItem('key') 清空数据：localStorage.clear() sessonStorage 特性：\n生命周期为关闭浏览器窗口 在同一个窗口(页面)下数据可以共享 以键值对的形式存储使用 用法跟 localStorage 基本相同 存储复杂数据类型 本地只能存储字符串,无法存储复杂数据类型.\n需要将复杂数据类型转换成JSON字符串,在存储到本地\n语法：\n1 2 3 4 5 6 7 8 9 10 const obj = { name: \u0026#39;cengdong\u0026#39;, age: 18 gender: \u0026#39;男\u0026#39; } // 通过JSON.stringify序列化对象 localStorage.setItem(\u0026#39;obj\u0026#39;, JSON.stringify(obj)) const str = localStorage.getItem(\u0026#39;obj\u0026#39;) // 通过JSON.parse反序列化字符串为对象 console.log(JSON.parse(str)) ","date":"2024-04-30T05:08:37+08:00","permalink":"https://www.cengdong.store/p/javascriptwebapis%E4%BA%94/","title":"【JavaScript】webAPIs五"},{"content":"日期对象 实例化 时间对象实例化的两种方式：\n获得当前时间：const date = new Date() 获得指定时间：const date = new Date('2008-08-08') 时间对象方法 方法 作用 说明 getFullYear() 获得年份 获取四位年份 getMonth() 获得月份 取值为 0 ~ 11 getDate() 获取月份中的每一天 不同月份取值也不相同 getDay() 获取星期 取值为 0 ~ 6 getHours() 获取小时 取值为 0 ~ 23 getMinutes() 获取分钟 取值为 0 ~ 59 getSeconds() 获取秒 取值为 0 ~ 59 时间戳 获得时间戳的三种方式：\n对象方法：date.getTime() 隐式转换：const timeStamp = +new Date() 无需实例化：Date.now() 节点操作 DOM 节点 有三种节点类型：\n元素节点 属性节点 文本节点 查找节点 父节点 1 2 3 4 // 获取子节点 const son = document.querySelector(\u0026#39;.dad\u0026#39;) // 根据子节点获取父节点 console.log(son.parentNode) 子节点 1 2 3 4 5 // 获取父节点 const dad = document.querySelector(\u0026#39;.dad\u0026#39;) // 有两种方式获取子节点 // 元素.childNodes：获得所有子节点、包括文本节点（空格、换行）、注释节点等 // 元素.children：1.仅获得所有元素节点 2. 返回的还是一个伪数组 兄弟节点 下一个兄弟节点：nextElementSibling 属性 上一个兄弟节点：previousElementSibling 属性 增加节点 craeteElement 新增 DOM 节点分为两个步骤：\n创建节点：createElement('标签名') 插入节点： 父元素.appendChild(要插入的元素) 父元素.insertBefore(要插入的元素, 在哪个元素前面) cloneNode 语法：元素.cloneNode(false)\ncloneNode 会克隆出一个跟原标签一样的元素，括号内传入布尔值\n注意事项：\n若为 true，则代表克隆时会包含后代节点一起克隆 若为 false，则代表克隆时不包含后代节点 默认为 false 删除节点 若一个节点在页面中已不需要时，可以删除它 在 JavaScript 原生 DOM 操作中，要删除元素必须通过父元素删除 语法：父元素.removeChild(要删除的元素)\n注意事项：\n如不存在父子关系则删除不成功 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从 html 中删除节点 M 端事件 触屏 touch 事件 说明 touchstart 手指触摸到一个 DOM 元素触发 touchmove 手指在一个 DOM 元素上滑动触发 touchend 手指从一个 DOM 元素移开触发 JS 插件 插件: 就是别人写好的一些代码,我们只需要复制对应的代码,就可以直接实现对应的效果\n学习插件的基本过程：\n熟悉官网,了解这个插件可以完成什么需求 https://www.swiper.com.cn/ 看在线演示,找到符合自己需求的 demo https://www.swiper.com.cn/demo/index.html 查看基本使用流程 https://www.swiper.com.cn/usage/index.html 查看 APi 文档,去配置自己的插件 https://www.swiper.com.cn/api/index.html 注意: 多个 swiper 同时使用的时候,类名需要注意区分 ","date":"2024-04-30T04:12:05+08:00","permalink":"https://www.cengdong.store/p/javascriptwebapis%E5%9B%9B/","title":"【JavaScript】webAPIs四"},{"content":"事件流 事件流与两个阶段说明 两个阶段：\n捕获阶段(由大到小) 冒泡阶段(由小到大) 事件捕获 从 DOM 的根元素开始去执行对应的事件 (从外到里)\n1 2 3 4 addEventListener(\u0026#39;click\u0026#39;, function (e) {}, true) // addEventListener第三个参数传入 true 代表是捕获阶段触发（很少使用） // 若传入false代表冒泡阶段触发，默认就是false // 若是用L0 事件监听，则只有冒泡阶段，没有捕获 事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发，这一过程被称为事件冒泡。\n阻止冒泡 问题：因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素 需求：若想把事件就限制在当前元素内，就需要阻止事件冒泡 前提：阻止事件冒泡需要拿到事件对象 语法：事件对象.stopPropagation() 解绑事件 on 事件方式，直接使用null覆盖就可以实现事件的解绑\n1 2 3 4 5 6 // 绑定事件 btn.onclick = function () { console.log(\u0026#39;点击了\u0026#39;) } // 解绑事件 btn.onclick = null addEventListener 方式，必须使用：removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段])\n1 2 3 4 // 绑定事件 btn.addEventListener(\u0026#39;click\u0026#39;, fn) // 解绑事件 btn.removeEventListener(\u0026#39;click\u0026#39;, fn) 注意事项：匿名函数无法解绑\n事件委托 事件委托是利用事件流的特征解决一些开发需求的知识技巧\n优点：减少注册次数，可以提高程序性能 原理：事件委托其实是利用事件冒泡的特点，给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件。 实现：事件对象.target.tagName 可以获得真正触发事件的元素 1 2 3 4 5 6 7 8 9 10 11 // 获取元素 const ul = document.querySelector(\u0026#39;ul\u0026#39;) ul.addEventListener(\u0026#39;click\u0026#39;, function (e) { // 阻止冒泡 e.stopPropagation() // 获取真正触发事件的元素 // console.log(e.target.tagName) if (e.target.tagName === \u0026#39;LI\u0026#39;) { e.target.style.color = \u0026#39;red\u0026#39; } }) 其他事件 目标：掌握新的事件，做更强交互\n页面加载事件 事件名 触发时机 为什么 load 加载外部资源（如图片、外联 CSS 和 JavaScript 等）加载完毕时触发的事件 有些时候需要等页面资源全部处理完了做一些事情/老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到 DOMContentLoaded 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发 无需等待样式表、图像等完全加载 页面滚动事件 滚动条在滚动的时候持续触发的事件 为什么要学：很多网页需要检测用户把页面滚动到某个区域后做一些处理，比如固定导航栏，比如返回顶部 事件名：scroll 监听某个元素的内部滚动直接给某个元素加即可 scrollLeft 和 scrollTop（属性）：\n获取被卷去的大小 获取元素内容往左、往上滚出去看不到的距离 这两个值是可读写的 注意事项：document.documentElement HTML 文档返回对象为HTML元素\nscrollTo(x, y)方法可把内容滚动到指定的坐标\n页面尺寸事件 会在窗口尺寸改变的时候触发事件：resize\n获取宽高：\n获取元素的可见部分宽高（不包含边框，margin，滚动条等） clientWidth 和 clientHeight 1 2 3 4 window.addEventListener(\u0026#39;resize\u0026#39;, function (e) { let w = document.documentElement.clientWidth console.log(w) }) 元素尺寸与位置 使用场景：\n前面案例滚动多少距离，都是我们自己算的，最好是页面滚动到某个元素，就可以做某些事。 简单说，就是通过 js 的方式，得到元素在页面中的位置 这样我们可以做，页面滚动到这个位置，就可以做某些操作，省去计算了 使用方式：\n获取宽高： 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth 和 offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 获取位置： 获取元素距离自己定位父级元素的左、上距离 offsetLeft 和 offsetTop 注意是只读属性 ","date":"2024-04-25T05:17:46+08:00","permalink":"https://www.cengdong.store/p/javascriptwebapis%E4%B8%89/","title":"【JavaScript】webAPIs三"},{"content":"事件监听 事件监听三要素 目标：给 DOM 元素添加事件监听\n事件是编程世界发生的动作或者事情\n事件监听是让程序检测事件的发生，调用函数响应事件\n语法：元素对象.addEventListener('事件类型', 要执行的函数)\n1 2 3 4 5 6 7 // 获取元素 const btn = document.querySelector(\u0026#39;.btn\u0026#39;) // 绑定事件 // 事件监听三要素：事件源、事件类型、响应函数 btn.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;我被点击了\u0026#39;) }) 事件监听版本 事件监听有两个不同的版本：\nL0 版本网页元素.on事件类型 L2 版本网页元素.addEventListener 两个版本的区别：\nL0 版本相同类型事件会发生覆盖，L2 版本不会 L0 版本只有事件冒泡，没有事件捕获特性，L2 版本都有 事件类型 事件类型主要有四大类：\n鼠标 鼠标点击(click) 鼠标经过(mouseenter) 鼠标离开(mouseleave) input 表单 focus(获得焦点) blur(失去焦点) 键盘 keydown(键盘按下) keyup(键盘抬起) 表单输入 input(输入文本) 事件对象 event 事件对象是什么 是一个对象，里面有事件触发时的相关信息\n是addEventListener函数回调函数的第一个参数\n事件对象常见属性 属性名 说明 type 获取当前事件类型 clientX/clientY 获取光标相对于浏览器可见窗口左上角位置 offsetX/offsetY 获取光标相对于当前 DOM 元素左上角的位置 key/code 用户按下的键盘键的值(现在不推荐使用 keyCode) 环境对象 this 目标：能够分析判断函数运行在不同环境中 this 所指代的对象\n环境对象是什么 指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境\nthis 指向：\n函数的调用方式不同，this 指代的对象也不同 【谁调用， this 就是谁】 是判断 this 指向的粗略规则 直接调用函数，其实相当于是 window.函数，所以 this 指代 window 回调函数 目标：能够说出什么是回调函数\n定义：当一个函数当做参数来传递给另外一个函数的时候，这个函数就是回调函数\n注意事项：\n把函数当做另外一个函数的参数传递，这个函数就叫回调函数 回调函数本质还是函数，只不过把它当成参数使用 使用匿名函数做为回调函数比较常见 ","date":"2024-04-24T05:30:49+08:00","permalink":"https://www.cengdong.store/p/javascriptwebapis%E4%BA%8C/","title":"【JavaScript】webAPIs二"},{"content":"WebAPI 基础介绍 作用和类型 作用： 使用js操作html和浏览器\n类型：\nDOM(文档对象模型) BOM(浏览器对象模型) DOM 树 将 html 文档以树状的结构直观的展示出来\n网页内容关系的名词\n体现了标签与标签之间的关系\ndocument:\nhtml body a div head title meta 节点类型：\n元素节点 属性节点 文本节点 DOM 对象 浏览器根据 html 标签生成的js对象\n特性：\n所有的属性标签都可以在这个对象上找到 修改这个对象的属性会自动映射到标签上 获取 DOM 对象 根据 CSS 选择器获取 DOM 元素 document.querySelector()获取匹配的第一个元素，返回一个 HTMLElement 对象 document.querySelectorAll()获取匹配的所有元素，返回一个伪数组 伪数组：\n有长度，有索引号 但是没有pop、push等数组方法 通过for循环遍历伪数组 其他方式获取 DOM 元素 1 2 3 4 5 6 // 根据id获取一个元素 document.getElementById(\u0026#39;nav\u0026#39;) // 根据标签名获取所有标签 document.getElementsByTagName(\u0026#39;nav\u0026#39;) // 根据类名获取所有元素 document.getElementsByClassName(\u0026#39;w\u0026#39;) 操作元素内容 对象.innerText 属性 innerText 将文本类容添加/更新到任意标签位置\n显示纯文本，不解析 html 标签\n对象.innerHTML 属性 innerHTML 解析标签\n多标签建议使用模版字符串\n操作元素属性 操作元素常用属性 常见属性：\nhref title src 语法：\n1 2 const nav = document.querySelector(\u0026#39;.nav\u0026#39;) nav.src = \u0026#39;./images/nav\u0026#39; 操作元素样式属性 通过 style 属性修改样式 1 2 3 4 5 6 7 8 // 获取元素 const nav = document.querySelector(\u0026#39;.nav\u0026#39;) // 通过style属性修改样式 // 赋值为字符串 // 必须带单位 nav.style.width = \u0026#39;300px\u0026#39; // 多单词采用小驼峰命名法 nav.style.backgroundColor = \u0026#39;pink\u0026#39; 通过 className 修改样式 style 属性一次只能修改一个属性，className 可以一次修改多个样式属性\n1 2 3 4 5 6 const nav = document.querySelector(\u0026#39;.nav\u0026#39;) // class是关键字，通过className修改样式 // 值也是一个字符串 nav.className = \u0026#39;box\u0026#39; // 多类名 nav.className = \u0026#39;nav box\u0026#39; 通过 classList 修改样式 为了解决 className 容易覆盖以前类名，可以通过 classList 方式追加/删除类名\n1 2 3 4 5 6 7 // 追加一个类 元素.classList.add(\u0026#39;类名\u0026#39;) // 删除一个类 元素.classList.remove(\u0026#39;类名\u0026#39;) // 切换一个类 // 有就删除，没有就追加 元素.classList.toggle(\u0026#39;类名\u0026#39;) 操作表单元素属性 表单有以下常用属性：\ntype(表单类型：text/password) value(表单值) checked(复选框，值为 boolean 类型) disabled(是否被禁用，值为 boolean 类型) selected(下拉框是否被选择，值为 boolean 类型) 自定义属性 自定义属性有以下几种方式：\nsetAttribute(已弃用) getAttribute(已弃用) html5 新增的 data-自定义属性 自定义属性的使用方式：\n标签上以data-开头 DOM 上以dataset对象形式获取 1 2 3 4 // 获取元素 const one = document.querySelector(\u0026#39;div\u0026#39;) // 通过元素的dataset对象获取所有的自定义属性 const firstDiv = one.dataset.first 定时器 间歇函数 定时器可以开启和关闭：\nsetInterval(函数, 间隔时间(单位是毫秒))开启定时器 clearInterval(定时器id号)关闭定时器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 定义函数 function fn() { console.log(\u0026#39;我是定时器要执行的具名函数\u0026#39;) } // 开启定时器 // 定时器有一个返回值id全剧唯一 let n = setInterval(fn, 1000) console.log(\u0026#39;n\u0026#39;) // setInterval可以传入匿名函数 let m = setInterval(function () { console.log(\u0026#39;定时器匿名函数\u0026#39;) }, 1000) // 关闭定时器 clearInterval(n) ","date":"2024-04-23T19:11:09+08:00","permalink":"https://www.cengdong.store/p/javascriptwebapis%E4%B8%80/","title":"【JavaScript】webAPIs一"},{"content":"对象 变量的声明与初始化 声明对象的方式：\nlet obj = {} let obj = new Object() 对象的构成：\n属性：冒号分隔的键值对 方法：函数 对象的操作： 查询： obg.属性名 obg['属性名'] 新增：obj.新属性名 = 值 修改：obj.属性名 = 新属性值 删除：delete obj.属性名 对象的方法 方法本质是一个匿名函数\n调用方法：obg.方法名()\n遍历对象 通过for k in遍历对象，其中 k 是字符串类型的，也可以用这种方法遍历数组(但不推荐)\n因为 k 是字符串类型，所以遍历访问属性时，应该使用obg['属性名']的方式\n1 2 3 4 5 6 7 8 obg = { username: cengdong, age: 18, }; for (let k in obg) { console.log(obg.[k]); } 内置对象：Math Math 对象属性 都是静态属性，直接通过Math.属性名方式访问\nMath.E Math.PI Math 对象方法 Math.random()方法返回一个 0-1 的随机浮点数 Math.abs()返回一个数的绝对值 Math.ceil()向上取整 Math.floor()向下取整 Math.round()四舍五入 Math.max()：返回作为输入参数的最大数字，如果没有参数，则返回 -Infinity Math.min()：返回作为输入参数的数字中最小的一个，如果没有参数，则返回 Infinity 随机数场景 0-10 的随机数：Math.floor(Math.random(10 + 1)) N-M之间的随机整数：Math.floor(Math.random() * (M - N + 1) + N) ","date":"2024-04-23T16:57:54+08:00","permalink":"https://www.cengdong.store/p/javascriptjavascript%E5%9F%BA%E7%A1%80%E5%9B%9B/","title":"【JavaScript】JavaScript基础四"},{"content":"数组 数组的声明和初始化 字面量声明数组 1 let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] 使用 new Array 构造函数声明数组 1 let arr = new Array(1, 2, 3, 4, 5, 6, 7, 8, 9) 数组操作 查询 通过下标/索引的方式访问数组元素\nJavasScript 数组索引越界不会报错，只会返回undefined\n1 2 3 4 let arr = new Array(1, 2, 3, 4, 5, 6) for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]) } 数组求和\n1 2 3 4 5 6 let sum = 0 let arr = new Array(1, 2, 3, 4, 5) for (let i = 0; i \u0026lt; arr.length; i++) { sum += arr[i] } console.log(sum) 修改 数组[索引] = 新值\n新增 arr.push()将一个或者多个元素添加到元素末尾，并且返回新数组的长度\narr.unshift()将一个或者多个元素添加到元素开头，并且返回新数组的长度\n删除 arr.pop()方法删除数组中最后一个元素，并且返回删除的元素(当数组为空时返回undefined) arr.shift()方法删除数组中第一个元素，并且返回删除的元素(当数组为空时返回undefined)\n就地删除：\n1 2 3 4 5 splice(start) splice(start, deleteCount) splice(start, deleteCount, item1) splice(start, deleteCount, item1, item2) splice(start, deleteCount, item1, item2, /* …, */ itemN) 函数 函数的作用 通过封装，提高代码复用性\n函数定义 function 函数名(参数) { 函数体 return 返回值}\n函数命名规范：\n和变量命名基本一致 小驼峰命名法 前缀应该为动词 函数调用：函数名(参数列表)\n函数的参数以及默认参数 术语：\n形参与实参 缺省参数：定义时等号赋值 注意事项：\n调用时少传了参数，则缺少的参数值为undefined 调用时多传了参数，则多余的参数不做处理 函数返回值 函数使用return关键字返回函数的返回值 return语句之后的代码不再执行，因此 return 下面不要写代码 javascript不支持多返回值，要返回多个值，应该使用容器(数组、字典等)对象返回 没有书写return语句的函数，其返回值是undefined 变量的作用域 局部作用域(函数内部let定义) 全局作用域(函数外部let定义) 变量向上查找机制，就近一致原则 匿名函数 函数既可以作为参数也可以作为返回值\n函数表达式 1 2 3 let fn = function () { console.log(\u0026#39;hello world\u0026#39;) } 函数表达式与具名函数的不同之处：\n具名函数的调用位置随意 函数表达式必须先声明，再使用 立即执行函数 立即执行函数是为了避免全局变量的污染\n1 2 3 4 // 第一种写法 ;(function () {})() // 第二种写法 ;(function () {})() 带参数的立即执行函数：\n1 2 3 ;(function (x, y) { console.log(x, y) })(x, y) 逻辑中断 逻辑与左边为 false 就中断，两边都为真时取后面的值 逻辑或左边为 true 时就中断。两边都为真时取前面的值 ","date":"2024-04-21T18:08:23+08:00","permalink":"https://www.cengdong.store/p/javascriptjavascript%E5%9F%BA%E7%A1%80%E4%B8%89/","title":"【JavaScript】JavaScript基础三"},{"content":"运算符 赋值运算符 赋值运算符用于简化变量自身的算数运算\n=：普通赋值 +=：算数赋值 -= *= /= %= 自增运算符 自增运算符常用于计数\n++number：前置自增 number++：后置自增 --number：前置自减 number--：后置自减 前置自增和后置自增的区别：前置自增先自增再参与运算，后置自增先参与运算再自增\n比较运算符 \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= !==：左右两边是否不全等 ==：左右两边值是否相等 ===：左右两边值和类型是否都相等 注意事项：\n字符串比较，比较的是 ASCII 码，从左至右依次比较 NaN 不等于任何值，包括它本身 尽量不要比较小数，有精度问题 逻辑运算符 \u0026amp;\u0026amp; || ! 运算符优先级 小括号 一元运算符 算数运算符：先*/后+- 关系运算符 相等运算符 逻辑运算符：先\u0026amp;\u0026amp;后|| 赋值运算符 逗号运算符 语句 表达式和语句 表达式是可以被求值的代码\n语句是一段可以执行的代码，不一定有值\nif 语句 if 单分支语句 1 2 3 4 let age = Number(prompt(\u0026#39;请输入您的年龄‘)) if (age \u0026gt; 18) { console.log(\u0026#39;成年人\u0026#39;) } 括号内为 true 时，执行大括号内代码 小括号内不是 boolean 类型数据时，会发生隐式转换 大括号只有一条语句时，可以省略大括号，但是不提倡 if 双分支语句 1 2 3 4 5 6 let age = Number(prompt(\u0026#39;请输入您的年龄\u0026#39;)) if (age \u0026gt; 18) { console.log(\u0026#39;成年人\u0026#39;) } else { console.log(\u0026#39;少年人\u0026#39;) } if 三分支语句 1 2 3 4 5 6 7 8 let score = Number(prompt(\u0026#39;请输入您的成绩\u0026#39;); if (score \u0026gt; 90) { console.log(\u0026#39;优秀\u0026#39;); } else if (score \u0026gt; 80) { console.log(\u0026#39;良好\u0026#39;); } else { console.log(\u0026#39;一般\u0026#39;); } 三元运算符 比 if 双分支更简单的写法\n?与:结合\n条件 ? 满足条件执行的代码 : 不满足条件执行的代码\n1 2 3 4 let a = 1 let b = 2 // 三目运算符 a \u0026gt; b ? a : b switch 语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let number = +prompt(\u0026#39;请输入一个1-7数字\u0026#39;) switch (number) { case 1: console.log(\u0026#39;星期一\u0026#39;) break case 2: console.log(\u0026#39;星期二\u0026#39;) break case 3: console.log(\u0026#39;星期三\u0026#39;) break case 4: console.log(\u0026#39;星期四\u0026#39;) break case 5: console.log(\u0026#39;星期五\u0026#39;) break case 6: console.log(\u0026#39;星期六\u0026#39;) break case 7: console.log(\u0026#39;星期七\u0026#39;) break default: console.log(\u0026#39;输入有误\u0026#39;) } 表达式的值必须与 case 语句后的值全等 case 语句后应该加上 break 语句，否则会穿透 应该加上 default 语句，没有匹配的值时，执行该语句 断点调试 打开开发者工具 添加断点 刷新浏览器 while 循环语句 1 2 3 4 5 let n = 0 while (n \u0026lt; 5) { console.log(n) n++ } 退出循环 break 退出整个循环 continue 跳过本次循环，继续下一个循环 for 循环语句 相比于 while 循环，for 循环把起始量，循环条件，循环量自增放在一起，更加清晰。\n1 2 3 for (var i = 0; i \u0026lt; 10; i++) { console.log(i); } 遍历数组\n1 2 3 4 let arr = [1, 2, 3, 4, 5] for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]) } 退出 for 循环 break continue 循环嵌套 1 2 3 4 5 6 7 8 // 外层循环，控制行数 for (let i = 0; i \u0026lt; 10; i++) { // 内层循环，控制列数 for (let j = 0; j \u0026lt;= i; j++) { document.write(`${i} * ${j} = ${i * j}`) } document.write(`\u0026lt;/br\u0026gt;`) } ","date":"2024-04-21T02:18:42+08:00","permalink":"https://www.cengdong.store/p/javascriptjavascript%E5%9F%BA%E7%A1%80%E4%BA%8C/","title":"【JavaScript】JavaScript基础二"},{"content":"JavaScript 简介 Javascript 是什么 是一种运行在客户端(浏览器)的编程语言，实现人机交互效果\nJavaScript 应用场景 网页特效(事件监听) 表单验证(针对表单数据的合法性进行判断) 数据交互(获取后台数据，渲染到前端) 服务端编程(node.js) JavaScript 组成 JavaScript：\nECMScript(JavaScript 语言基础) js 基础核心语法知识 变量 分支语句 循环语句 对象 WebAPIs DOM(文档对象模型) BOM(浏览器对象模型) JavaScript 书写位置 行内 JavaScript 内部 JavaScript 外部 JavaScript(通过 src 属性引入，中间无需写代码，否则会被忽略) 内部 JavaScript 放在\u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签最下方\n浏览器按照代码在文件中顺序加载html\n放在其他位置，可能会由于HTML未加载而失败\nJavaScript 注释和结束符 注释 单行注释：// (ctrl + /) 多行注释：/* */ (alt + shift + a) 结束符 作用： ;，代表语句结束 实际情况： 可写可不写 现状：更多人主张省略结束符 约定：风格统一，按照团队要求 JavaScript 输入输出语法和字面量 文档输出内容 1 document.write(\u0026#39;我是div标签\u0026#39;) 页面弹出警告 1 alert(\u0026#39;hello world\u0026#39;) 控制台输出内容 1 console.log(\u0026#39;hello world\u0026#39;) 输入语句 1 prompt(\u0026#39;请输入您的年龄\u0026#39;) 字面量 就是常量的意思：\n数字字面量 字符串字面量 数组字面量 对象字面量 JavaScript 变量 变量是什么 计算机存储数据的容器\n变量的作用 存储数据\n变量的声明与赋值 1 2 3 4 5 6 7 8 9 10 11 // 声明变量 let age // 变量赋值 age = 18 // 声明多个变量，不提倡，可读性不好 let name = \u0026#39;xixi\u0026#39;, number = 20 // 打印变量的值 console.log(age) // 变量声明的同时赋值，叫做变量的初始化 let name = \u0026#39;cengdong\u0026#39; 注意事项：\n变量不能重复声明 多个变量同时声明中间使用逗号隔开 交换两个变量的值 定义临时变量\n1 2 3 4 5 6 let number1 = 10 let number2 = 20 let tmp tmp = number1 number1 = number2 number2 = tmp 变量的本质与命名规则 变量的本质就是程序在内存中申请的一块存储数据的空间\n变量命名规则：\n只能包含字母``数字``$和下划线 不能以数字开头 不能用关键字 大小写敏感 变量命名规范：\n见名知意 小驼峰命名法：userName let 与 var 的区别 var 声明：\n可以先使用再声明(不合理) 可以重复声明(不合理) 变量提升、全局变量、没有块级作用域 变量声明优先使用 const，如果发现变量需要修改，再使用 let 替换 数组和对象等引用数据类型使用 const 声明\n数组 数组的声明与初始化 数组可以存储任意数据类型\n1 let arr = [1, 2, 3] 数组相关术语：\n索引(从零开始) 元素 长度(arr.length) 常量 常量声明：const\n1 2 const COUNT = 100 console.log(COUNT) 注意事项：\n声明的时候必须赋值 不允许重新赋值 数据类型 JavaScript 数据类型 基本数据类型 number string boolean undefined null 引用数据类型 object 获取一个变量的数据类型：typeof()函数或者typeof x运算符\n数字类型与算数运算符 所有的数字都是数字型\n数字间有很多操作：\n+加 -减 *乘 /除 %取余 算数运算符有优先级，按照优先级先后顺序进行运算\n优先级口诀：先乘除后加减，有小括号先算小括号\n数字类型特殊的值：NaN(运算错误时)\nNaN 是粘性的，任何对 NaN 的操作都会返回 NaN\n字符串类型 通过单引号、双引号、反引号包裹的数据都叫字符串\n单引号与双引号本质没有区别，推荐使用单引号\n字符串拼接 通过+进行字符串拼接\n口诀：数字相加，字符拼接\n模版字符串 使用场景：拼接字符串与变量\n语法：\n反引号包裹 内容拼接变量时，使用${}包裹 boolean\u0026amp;undefined\u0026amp;null boolean boolean 类型数据有两种值：\ntrue false 可以与数字型进行运算，false 为 0，true 为 1\nundefined 只声明，不赋值的情况下，变量的默认值为 undefined 一般很少直接给变量赋值为 undefined null 代表无、空、未知的特殊值\nnull 和 undefined 的区别：\nundefined 表示没有赋值 null 表示赋值了，但是内容为空 计算时有区别，null 可表示为 0 变量类型转换 类型转换有两种：\n数据类型转换就是把一种数据类型的变量转换为我们需要的数据类型\n隐式转换(自动类型转换) 显示转换(强制类型转换) 隐式转换 任何数据和字符串相加结果都是字符串 除了+的其他运算符(比较运算符也会)，会把数字的字符串转换为 number 类型 +号作为正号解析可以转换为数字型 null 类型参与运算 boolean 类型数据参与运算或者逻辑判断 显示转换 转换为数字型 转换为数字型：Number()，转换失败时为NaN 只保留整数：parseInt() 保留小数：parseFloat() 1 2 3 4 5 6 console.log(Number(\u0026#39;1.1\u0026#39;)) console.log(Number(\u0026#39;abc\u0026#39;)) console.log(parseInt(\u0026#39;1.2\u0026#39;)) console.log(parseInt(\u0026#39;1.2px\u0026#39;)) console.log(parseFloat(\u0026#39;1.2px\u0026#39;)) console.log(parseFloat(\u0026#39;abc1.2px\u0026#39;)) 转换为字符串型 String() toString() 区别：\nString()可以转换所有数据类型，toString()不能转换 null、undefined toString 可以传参，表示以多少进制的格式输出结果；String 方法传参无效 转换为 boolean 类型 通过 Boolean()函数可以将其他类型数据转换为 boolean 类型\n数字型：除了 0 为 false，其他所有数字型都是 true 字符串：除了空字符串为 false，其他所有字符串都是 true null：false undefined：false NaN：false 注意事项：NaN == undefined为 true，NaN === undefined为 false\n","date":"2024-04-20T06:34:54+08:00","permalink":"https://www.cengdong.store/p/javascriptjavascript%E5%9F%BA%E7%A1%80%E4%B8%80/","title":"【JavaScript】JavaScript基础一"},{"content":"rem 基础 rem 的优点 文字能随着屏幕大小发生变化 元素高度和宽度都能随着屏幕大小发生变化 rem 单位 rem(root em)是一个相对单位，类似于em，em 是父元素字体大小。 rem的基准是相对于 html 元素的字体大小。 父元素文字大小可能不一致， 但是整个页面只有一个 html，可以很好来控制整个页面的元素大小 媒体查询 什么是媒体查询 媒体查询（Media Query）是 CSS3 新语法 使用 @media 查询，可以针对不同的媒体类型定义不同的样式 媒体查询语法 1 2 3 @media mediatype and|not|only (media feature) { CSS-Code; } 用 @media 开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性 必须有小括号包含 mediatype 查询类型 值 解释说明 all 用于所有设备 print 用于打印机和打印预览 scree 用于电脑屏幕，平板电脑，智能手机等 关键字 and：可以将多个媒体特性连接到一起，相当于“且”的意思。 not：排除某个媒体类型，相当于“非”的意思，可以省略。 only：指定某个特定的媒体类型，可以省略。 媒体特性 值 解释说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域宽度 max-width 定义输出设备中页面最大可见区域宽度 从小到大来写，这样代码更简洁\n引入资源 语法规范：\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;mediatype and|not|only (media feature)\u0026#34; href=\u0026#34;mystylesheet.css\u0026#34;\u0026gt; less 基础 css 弊端 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。 不方便维护及扩展，不利于复用。 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 less 介绍 中文官网\nLess （Leaner Style Sheets 的缩写） 是一门 CSS 扩展语言，也成为 CSS 预处理器 它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写 常见的 CSS 预处理器：Sass、Less、Stylus less 安装 安装 nodejs，可选择版本(8.0)，网址：http://nodejs.cn/download/ 检查是否安装成功，使用 cmd 命令（win10 是 window +r 打开 运行输入 cmd） \u0026mdash; 输入“ node –v ”查看版本即可 基于 nodejs 在线安装 Less，使用 cmd 命令“ npm install -g less ”即可 检查是否安装成功，使用 cmd 命令“ lessc -v ”查看版本即可 less 语法 less 语法包括以下几个方面：\nLess 变量 Less 编译 Less 嵌套 Less 运算 less 变量 变量是指没有固定的值，可以改变的。因为我们 CSS 中的一些颜色和数值等经常使用。\n语法规范：\n1 @color: pink; 使用变量：\n1 2 3 4 5 6 7 //直接使用 body { color: @color; } a:hover { color: @color; } 变量命名规范：\n必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 less 编译 vocode Less 插件: easy less\n保存 less 文件，自动生成 css 文件\nless 嵌套 1 2 3 4 5 #header { .logo { width: 300px; } } 如果遇到：交集|伪类|伪元素选择器\n内层选择器的前面没有 \u0026amp; 符号，则它被解析为父选择器的后代； 如果有 \u0026amp; 符号，它就被解析为父元素自身或父元素的伪类。 less 运算 任何数字、颜色或者变量都可以参与运算。就是 Less 提供了加（+）、减（-）、乘（*）、除（/）算术运算。\n1 2 3 4 5 6 7 8 9 10 11 /*Less 里面写*/ @witdh: 10px + 5; div { border: @witdh solid red; } /*生成的css*/ div { border: 15px solid red; } /*Less 甚至还可以这样 */ width: (@width + 5) * 2; 注意事项：\n乘号（*）和除号（/）的写法 运算符中间左右有个空格隔开 1px + 5 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位 rem 适配方案 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。 rem 实际开发适配方案 按照设计稿与设备宽度的比例，动态计算并设置 html 根标签的 font-size 大小；（媒体查询） CSS 中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为 rem 为单位的值； rem 适配方案技术使用（市场主流） 技术方案 1 less 媒体查询 rem 技术方案 2（推荐） flexible.js rem ","date":"2024-04-20T05:34:54+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFrem%E5%B8%83%E5%B1%80/","title":"【前端】rem布局"},{"content":"移动端基础 浏览器现状 兼容移动端主流浏览器，处理Webkit内核浏览器即可\n手机屏幕现状 移动端设备屏幕尺寸非常多，碎片化严重\n移动端调试技巧 Chrome DevTools（谷歌浏览器）的模拟手机调试 搭建本地 web 服务器，手机和服务器一个局域网内，通过手机访问服务器 视口 视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口\n布局视口 layout viewport 视觉视口 visual viewport 理想视口 ideal viewport 用理想视口布局 理想视口，对设备来讲，是最理想的视口尺寸\nmeta 视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽\nmeta 视口标签 1 2 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; 属性 解释说明 width 宽度设置的是viewport宽度，可以设置device-width特殊值 initial-scale 初始缩放比，大于 0 的数字 maximum-scale 最大缩放比，大于 0 的数字 minimum-scale 最小缩放比，大于 0 的数字 user-scalable 用户是否可以缩放，yes 或 no（1 或 0） 标准的 viewport 设置：\n视口宽度和设备保持一致 视口的默认缩放比例 1.0 不允许用户自行缩放 最大允许的缩放比例 1.0 最小允许的缩放比例 1.0 二倍图 物理像素\u0026amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。\n我们开发时候的 1px不是一定等于1 个物理像素的\nPC 端页面，1 个 px 等于 1 个物理像素的，但是移动端就不尽相同\n一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比\n多倍图 对于一张图片,在手机屏中打开，物理像素比会放大倍数，这样会造成图片模糊\n在标准的 viewport 设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题\n通常使用二倍图，还存在3倍图4倍图的情况\n1 2 3 4 5 6 7 8 9 10 /* 在 iphone8 下面 */ img { /*原始图片100*100px*/ width: 50px; height: 50px; } .box { /*原始图片100*100px*/ background-size: 50px 50px; } 背景缩放 background-size background-size 属性规定背景图像的尺寸\n语法格式：background-size: 背景图片宽度 背景图片高度;\n注意事项：\n单位： 长度|百分比|cover|contain; cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容 二倍精灵图做法 在firework里面把精灵图等比例缩放为原来的一半 之后根据大小测量坐标 注意代码里面background-size也要写： 精灵图原来宽度的一半 移动端开发选择 移动端主流方案：\n单独制作移动端页面（主流） 响应式页面兼容移动端（其次） 单独移动端页面 通常情况下，网址域名前面加 m(mobile) 可以打开移动端。\n通过判断设备/user-agent，如果是移动设备打开，则跳到移动端页面。\n响应式兼容 PC 移动端 通过判断屏幕宽度来改变样式，以适应不同终端。\n制作麻烦，需要花很大精力去调兼容性问题\n移动端技术解决方案 移动端浏览器 移动端浏览器基本以webkit内核为主，因此我们就考虑webkit兼容性问题\nCSS 初始化 normalize.css 移动端 CSS 初始化推荐使用 normalize.css/\nNormalize.css：保护了有价值的默认值 Normalize.css：修复了浏览器的 bug Normalize.css：是模块化的 Normalize.css：拥有详细的文档 官网地址\nCSS3 盒子模型 box-sizing 传统模式宽度计算：盒子的宽度 = CSS 中设置的 width + border + padding CSS3 盒子模型： 盒子的宽度 = CSS 中设置的宽度 width 里面包含了 border 和 padding 特殊样式 1 2 3 4 5 6 7 8 9 10 11 12 /*CSS3盒子模型*/ box-sizing: border-box; -webkit-box-sizing: border-box; /*点击高亮我们需要清除清除 设置为transparent 完成透明*/ -webkit-tap-highlight-color: transparent; /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/ -webkit-appearance: none; /*禁用长按页面时的弹出菜单*/ img, a { -webkit-touch-callout: none; } 移动端常见布局 流式布局 flex 布局 rem 布局 流式布局（百分比布局） 流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 流式布局方式是移动 web 开发使用的比较常见的布局方式。 max-width 最大宽度 （max-height 最大高度） min-width 最小宽度 （min-height 最小高度） flex 布局 传统布局\u0026amp;flex 布局 传统布局：\n兼容性好 布局繁琐 局限性，不能再移动端很好的布局 flex 弹性布局：\n操作方便，布局极为简单，移动端应用很广泛 PC 端浏览器支持情况较差 IE 11 或更低版本，不支持或仅部分支持 flex 布局原理 flex 是flexible Box的缩写，意为弹性布局，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。\n当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 =flex 布局 体验中 div 就是 flex 父容器 体验中 span 就是 子容器 flex 项目 子容器可以横向排列也可以纵向排列 flex 布局父元素常见属性 属性值 说明 flex-direction 设置主轴的方向 justify-content 设置主轴上的子元素排列方式 flex-wrap 设置子元素是否换行  align-content：设置侧轴上的子元素的排列方式（多行） align-items 设置侧轴上的子元素排列方式（单行） flex-flow 复合属性，相当于同时设置了 flex-direction 和 flex-wrap flex-direction flex-direction属性决定主轴的方向（即项目的排列方向）\n主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。\n属性值 说明 row 默认值从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 justify-content justify-content属性定义了项目在主轴上的对齐方式\n属性值 说明 flex-start 默认值 从头部开始 如果主轴是 x 轴，则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐（如果主轴是 x 轴则 水平居中） space-around 平分剩余空间 space-between 先两边贴边 再平分剩余空间（重要） flex-wrap flex-wrap设置子元素是否换行\n属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items align-items设置侧轴上的子元素排列方式（单行）\n属性值 说明 flex-start 从上到下 flex-end 从下到上 center 挤在一起居中（垂直居中） stretch 拉伸 （默认值 ） align-content align-content设置侧轴上的子元素的排列方式（多行）\n属性值 说明 flex-start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 align-content 和 align-items 区别 align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content 适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、 下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找 align-items/多行找 align-content flex-flow flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性\n1 flex-flow: row wrap; flex 布局子项常见属性 属性值 说明 flex 子项目占的份数 align-self 控制子项自己在侧轴的排列方式 order 属性定义子项的排列顺序（前后顺序） flex flex属性定义子项目分配剩余空间，用 flex 来表示占多少份数。\nalign-self align-self 控制子项自己在侧轴上的排列方式\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。\n默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于stretch。\norder order 属性定义项目的排列顺序\n数值越小，排列越靠前，默认为 0\n","date":"2024-04-18T05:04:57+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AF%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7/","title":"【前端】移动端布局技巧"},{"content":"2D 变换 2D 变换有三种形式：\ntranslate：平移 rotate：旋转 scale：伸缩 可以同时使用多个形式\n2D 变换-平移 语法格式：transform: translate(x, y)，\nx、y 的单位可以是px，也可以是百分比，当值是百分比时，表示自身宽度/高度的比例\n也可以分开写：translateX()/translateY()\n注意事项：\ntranslate 对行内标签没有作用 translate(x, y)表示相对于父元素移动的距离，且是一种声明式写法 translate 最大的特点：不会影响其他元素的位置(不脱标) 2D 变换-旋转 语法格式：transform: rotate(60deg)，单位是deg\n角度为正时，顺时针，负时，为逆时针\n默认旋转的中心点是元素的中心点\n2D 旋转-中心点 语法格式：transform-origin: x y;\n注意事项：\n的参数 x 和 y 用空格隔开，单位可以是px/百分比/方位名词 x y 默认转换的中心点是元素的中心点 (50% 50%) 可以给 x y 设置 像素 或者 方位名词 （top bottom left right center） 2D 变换-伸缩 语法格式：transform:scale(x,y);\n注意事项：\n宽和高都放大一倍，相对于没有放大 只写一个参数，第二个参数则和第一个参数一样 sacle 缩放最大的优势：默认以中心点缩放的，而且不影响其他盒子(不脱标) CSS 动画 制作动画可以分为两部：\n定义 调用 动画的定义 语法格式：\n1 2 3 4 5 6 7 8 @keyframes 动画名称 { 0% { width: 100px; } 100% { width: 200px; } } 注意事项：\n0%是动画的开始，100%是动画的完成。这样的规则就是动画序列(关键帧) 用关键词from和to，等同于0%和100% 在0%和100%中间可以随意定义多个百分比关键帧 动画的调用 在需要使用该动画的元素上加上animation-name、animation-duration等属性\n动画常用属性：\n属性 描述 @keyframes 定义动画 animation 所有动画属性的简写 animation-name 动画名称 animation-duration 动画持续时间 animation-time-function 动画速度曲线，默认是ease，还有liner/steps/ease-in等属性 animation-delay 动画何时开始 animation-iteration-count 动画播放次数，默认是1，还有infinite animation-direction 是否在下一个周期逆向播放，默认值是normal，还有alternate(逆向播放) animation-fill-mode 规定动画结束之后保持forwards，回到起点backwards animation-play-state 动画播放状态，running/paused 3D 变换 3D 变换有三种形式：\ntranslate3d：3D 平移 rotate3d：3D 旋转 3 维坐标系 三维坐标系其实就是指立体空间，立体空间是由 3 个轴共同组成的。\nx 轴：水平向右 注意： x 右边是正值，左边是负值 y 轴：垂直向下 注意： y 下面是正值，上面是负值 z 轴：垂直屏幕 注意： 往外面是正值，往里面是负值 因为 z 轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动\n透视 perspective perspective在 2D 平面产生近大远小视觉立体，但是只是效果二维的\n注意事项：\n视距应该给父元素/祖元素添加 透视我们也称为视距：视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大，越远成像越小 透视的单位是px 3D 变换-平移 语法格式：transform:translate3d(x,y,z)\n也可以分开写：translateX/translateY/translateZ\n3D 变换-旋转 语法格式：transform:rotate3d(x,y,z,deg)，了解即可\n也可以按照坐标轴旋转：rotateX(45deg)/rotateY(45deg)/rotateZ(45deg)\n注意事项：\n旋转方向遵循左手准则 3D 呈现 transfrom-style 给父元素添加变换属性时，子元素的变换属性可能失效\n为了保持子元素 3D 变换效果，应该给父元素添加transfrom-style: preserve-3d;属性(默认值是flat)\n私有浏览器前缀 浏览器私有前缀是为了兼容老版本的写法，比较新版本的浏览器无须添加。\n私有前缀：\n-moz-：代表 firefox 浏览器私有属性 -ms-：代表 ie 浏览器私有属性 -webkit-：代表 safari、chrome 私有属性 -o-：代表 Opera 私有属性 ","date":"2024-04-18T03:15:42+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss3%E5%8A%A8%E7%94%BB/","title":"【前端】CSS3动画"},{"content":"模块化开发 项目目录结构 一个好的项目目录结构清晰：\ncss(样式：通过外部样式引入) fonts(字体图标) images(网站静态图片) upload(用户上传的图片) js(javascrip 脚本) favicon.ico(网站图标) index.html(网站入口) 样式的模块化开发 样式的初始化放在 base.css 文件中 可共用的样式放在 common.css 文件中 网站 SEO 优化 TDK 三大标签 title(网站标题-解释说明) description(网站说明) Keywords(关键字) 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 网站标题 --\u0026gt; \u0026lt;title\u0026gt;品优购商城-正品低价、品质保障、配送及时、轻松购物！\u0026lt;/title\u0026gt; \u0026lt;!-- 网站描述 --\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;品优购商城-专业的综合网上购物商城，为您提供正品低价的购物选择、优质便捷的服务体验。商品来自全球数十万品牌商家，囊括家电、手机、电脑、服装、居家、母婴、美妆、个护、食品、生鲜等丰富品类，满足各种购物需求。\u0026#34; /\u0026gt; \u0026lt;!-- 关键字 --\u0026gt; \u0026lt;meta name=\u0026#34;Keywords\u0026#34; content=\u0026#34;网上购物,网上商城,家电,手机,电脑,服装,居家,母婴,美妆,个护,食品,生鲜,京东\u0026#34; /\u0026gt; favicon.ico 图标制作与使用 figma切图切出 png 格式的图片 https://favicon.io/进行格式转化，转化为 ico 格式 放在项目根目录下，通过\u0026lt;link rel=\u0026quot;shortcut icon\u0026quot; href=\u0026quot;./favicon.ico\u0026quot; /\u0026gt;引入 网站 logo 制作 先放置一个\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;标签 标签里放置一个链接，链接里的文字是网站名称，会跳转网站首页，文字不展示。链接的背景图片是 logo 文字不展示的方法： text-indent: -9999px; overflow: hidden; font-size: 0; 给链接一个title属性 ","date":"2024-04-09T09:04:08+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFweb%E7%AB%AF%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/","title":"【前端】Web端网页项目实战技巧"},{"content":"HTML5 新特性 新的标签 新的表单 新的表单属性 新的标签 针对搜索引擎的，可以多次使用，移动端更常见\n语义化标签 header(头部标签) nav(导航标签) article(内容标签) section(区域标签) aside(侧边栏标签) footer(尾部标签) 视频标签：\u0026lt;video\u0026gt;\u0026lt;/video\u0026gt; 视频格式 mp4(所有浏览器都支持，尽量使用该格式) WebM Ogg 属性 src(文件地址) autoplay(自动播放：autoplay，谷歌浏览器需要添加muted属性解决自动播放) controls(显示播放控件：controls) loop(循环播放) preload(预先加载：auto/none) width(宽度) height(高度) poster(加载等待的图片) muted(静音播放：muted) 音频标签：\u0026lt;audio\u0026gt;\u0026lt;/audio\u0026gt; 音频格式 mp3(所有浏览器都支持，尽量使用该格式) Wav Ogg 属性 src(文件地址) autoplay(自动播放：autoplay) controls(播放控件：controls) loop(循环播放：loop) muted(静音：muted) 新的表单 HTML5 中input表单新增了很多种类型：\nnumber(数字) email(邮箱) tel(电话) search(搜索框) color(颜色) date(日期) time(时间) month(月) week(周) 新的表单属性 required(必填) placeholder(提示文本) autocomplete(自动补全之前搜索记录) autofocus(自动聚焦：百度首页) multiple(可以提交多个文件) CSS3 新特性 CSS3 新增特性：\n新的选择器 新的盒子模型 图片模糊处理 属性过度 属性选择器 属性选择器通过元素具有的属性来选择元素\n语法：input[属性]\n选择符 简介 E[att] 选择具有属性的 E 元素 E[att=\u0026ldquo;val\u0026rdquo;] 选择具有属性 att 且其值等于 val 的 E 元素 E[att^=\u0026ldquo;vale] 选择具有属性 att 且其值以 val 开头 的 E 元素 E[att$=\u0026ldquo;val\u0026rdquo;] 选择具有属性 att 且其值以 val 结尾的 E 元素 E[att*=\u0026ldquo;val\u0026rdquo;] 选择具有属性 att 且其值包含 val 的 E 元素 结构伪类选择器 结构伪类选择器通过文档的结构来选择元素，常用于选择父级里的子元素\n选择符 简介 E:first-child 匹配父元素里的第一个子元素 E:last-child 匹配父元素里的最后一个子元素 E:nth-child(n) 匹配父元素里的第 n 个子元素 E:first-of-type 匹配父元素里指定类型的第一个子元素 E:last-of-type 匹配父元素里指定类型的最后一个子元素 E:nth-of-type(n) 匹配父元素里指定类型的第 n 个元素 nth结构伪类选择器中的n既可以是数字也可以是公式/关键字\n数字 even(偶数)、odd(奇数) 包含n的公式：n 从零开始计算，超过的不计算 nth-child(n)与 nth-of-type(n)的区别：\nnth-child(n)会把所有子元素进行排序，再看前面选择的类型，如果匹配不上，则选不上 nth-of-type(n)只会把指定类型的元素进行排序，再选择第 n 个 伪元素选择器 伪元素选择器的由来：伪元素选择器可以利用CSS创建新标签，简化HTML代码\n选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意事项：\nbefore 和 after 创建一个元素，但是属于行内元素 新创建的元素在文档树中不存在，所以叫做伪元素 before 和 after 伪元素选择器必须包含content属性 伪元素选择器和标签选择器一样权重是1 使用场景：\n字体图标 遮罩层 清除浮动 CSS3 盒子模型 CSS2 的盒子模型，边框、内边距都会撑开盒子\nCSS3 可以通过box-sizing无需考虑\n可选择的值：\ncontent-box(和 CSS2 盒子模型一样) border-box(新的盒子模型) CSS3 其他特性 图片变模糊 img {filter: blur(n px);}\nn 越大，图片越模糊。当 n=0 时，没有模糊效果\n盒子宽度计算函数 calc() width: calc(100% - 30px)\nCSS3 属性过渡 是一种简单的动画效果\n语法：transtion: 要过渡的属性 花费时间 运动曲线 何时开始;，在原选择器上写(谁做过渡给谁加)。\n属性：宽度/高度/背景颜色/内外边距/all，如果想要写多个属性，应该使用逗号分隔 花费时间：单位是秒 运动曲线：默认是 ease(可以省略) linear(匀速) ease(逐渐慢下来) ease-in(加速) ease-out(减速) ease-in-out(先加速后减速) 何时开始：单位是秒，用于设置延迟触发时间 ","date":"2024-04-07T19:32:51+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml5css3/","title":"【前端】HTML5CSS3"},{"content":"精灵图 为什么需要精灵图技术 很多小图片，每一个小图片请求一次，浪费网络 IO\n为了减少服务器发送/接受请求次数，提高页面加载速度\n精灵图技术原理 精灵图技术主要针对背景图片 将多个背景图片整合到一张图片中 使用background-position/width/height属性将图片进行切割得到想要的图片 一般background-position都是负值 字体图标 字体图标产生的原因 网页上有许多小图标，使用精灵图技术实现有很多缺点\n精灵图是背景图片，图片占用存储比较大 图片进行放大缩小时会失真 精灵图一旦确定，修改很麻烦 字体图标的优点 展示的是图标，其实是字体 放大缩小不失真，可以随便改变颜色 字体图标使用 下载字体图标 引入字体图标 下载的字体图标放在项目根目录 通过 CSS 引入 在页面中通过font-family使用图标 更新下载图标 原来的文件不能删除 导入selection.json CSS 三角 CSS 三角的原理 通过边框实现\n一个没有大小的盒子：box { width: 0; height: 0;} 为盒子设置边框：大小为三角底边长度，颜色为透明，风格为实线：border: 10px solid transparent; 想要的三角形底边在哪，哪个方向的边框设置颜色border-left: red; 用户界面控制 用户界面样式，提高用户体验\n鼠标样式 通过li {cursor: value;}控制\ndefault(小白，默认) pointer(小手) move(移动) text(文本) not-allow(禁止) 表单轮廓 文本框默认有边框轮廓，通过outline: none;取消\n防止表单拖拽 文本域防拖拽，默认可以拖拽：resize: none;\n行内块元素与文本垂直居中 行内块元素(图片/表单)与文本垂直对齐\n为行内块元素设置vertical-align属性\nvertical-align: baseline | top | middle | bottom;\n值 描述 baseline 基线 top 顶线 middle 中线 bottom 底线 图片和文字默认是基线对齐\n图片底部空白缝隙 产生原因 因为图片默认和文字基线对齐，所以底部有缝隙\n解决方案 设置vertical-align: bottom | middle | top; 把图片转换为块元素 溢出文字省略号显示 单行文字溢出 单行文本溢出省略显示的三个条件：\n强制文本一行显示：white-space: nowrap; 默认normal自动换行 超出部分隐藏：overflow: hidden; 文字用省略号替代超出的部分：text-overflow: ellipsis; 多行文字溢出 多行文本溢出显示省略号，适用于 web-kit 内核，有较大的兼容性问题\noverflow: hidden; text-overflow: ellipsis; display: -webkit-box; -wbekit-line-clamp: 2; -webkit-box-orient: vertical; 常见布局技巧 margin 负值的应用 盒子细线边框(合并边框)：\nmargin-left: -边框宽度;，右边盒子压住左边盒子右边框 鼠标经过，边框变换颜色： 盒子没有定位，添加相对定位(不脱标) 盒子有定位：z-index: 9999 文字围绕浮动元素 利用浮动不会压住文字的特点，添加浮动之后，文字就会围绕浮动元素\n行内块元素巧妙应用 页码布局的实现\n利用行内块元素间自带的间隙 文字水平居中：text-align: center; 文字垂直居中：line-height: 行内块元素高度 所有的行内块元素与行内元素水平居中：给父元素text-align: center; CSS 三角强化 非等腰三角的实现\n等腰三角的实现：宽度高度为0的盒子 四条边框颜色不一样，除了直角边设置颜色，其他边设置为transparent 无关的边框设置为 0 短边对面的边框调整宽度 1 2 3 4 5 6 7 box { width: 0; height: 0; border-color: transparent red transparent transparent; border-style: solid; border-width: 22px 8px 0 0; } CSS 初始化 不同浏览器对于有些标签的默认值不一样，为了消除这个，需要对 CSS 进行初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /* 清除元素默认内外边距 */ * { margin: 0; padding: 0 } /* 斜体样式正常化 */ em, i { font-style: normal } /* 清除列表默认样式：小圆点 */ li { list-style: none } /* 图片与文字垂直对齐 */ img { border: 0; vertical-align: middle } /* 用户界面：按钮鼠标变为小手 */ button { cursor: pointer } /* 清除链接下划线 */ a { color: #666; text-decoration: none } a:hover { color: #c81623 } button, input { font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif } body { -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \u0026#34;\\5B8B\\4F53\u0026#34;, sans-serif; color: #666 } .hide, .none { display: none } /* 清除浮动 */ .clearfix:after { visibility: hidden; clear: both; display: block; content: \u0026#34;.\u0026#34;; height: 0 } .clearfix { *zoom: 1 } ","date":"2024-04-06T18:33:34+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"【前端】网页布局常用技巧"},{"content":"网页布局入门 网页布局的本质就是通过CSS把盒子摆到相应位置。\n网页布局方式 网页布局有以下三种方式：\n普通流布局 浮动布局 定位布局 网页布局准则 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动\n网页布局第二准则：先设置盒子大小，再设置盒子位置\n网页布局流程 确认页面版心(可视区)，可视区水平居中 分析页面中行模块，以及每个行中的列模块 一行中列模块经常浮动布局，先确定列大小，再确定列位置 先制作 html 结构。先结构，后样式。 标准流/普通流 标准流就是元素按照规定的默认方式排序\n行内元素 块元素 行内块元素 浮动布局 为什么需要浮动 使多个\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;在同一行展示：在标准流中使用display: inline-block，但是盒子之间会有缝隙 实现两个盒子左右对齐：标准流很难实现 什么是浮动 float属性用于创建浮动框，将其移动到一边，直至左边缘/右边缘遇到其他块，或者是另一个浮动框的边缘\n浮动语法：float: 属性值\nnone(默认值) left right 浮动的特性 加了浮动的元素会脱离标准流 浮动的元素会一行显示并且元素顶部对齐 浮动的元素具有行内块元素特性 浮动的注意点 浮动和标准流父盒子搭配使用 一个元素浮动，其他元素也要浮动 浮动的盒子只会影响后面的标准流 清除浮动 不一定需要给父盒子设置高度\n理想的状态：子盒子撑开父盒子\n浮动的元素不占位置(浮动布局中没有子盒子撑开父盒子)\n因此需要清除浮动，清除浮动有以下几种方式：\n额外标签法(w3c 推荐)：在最后一个浮动的元素添加块级元素并添加属性clear: left/right/both(推荐) 父级元素添加overflow: hidden/auto/scroll属性 父级添加after伪元素 父级添加双伪元素 1 2 3 4 5 .clearfix:after { content: \u0026#34;\u0026#34;; display: block; clear: both; } 1 2 3 4 5 .clearfix::before, .clearfix::after { content: \u0026#34;\u0026#34;; display: table; clear: both; } 切图 常见的图片格式 jpg：对色彩保留信息好，产品类图片 gif：显示简单的图形及字体，图片动画。特点：保存透明背景和动画效果 png：结合 jpg 与 gif psd：photoshop 的专用格式 切图方式 图层切图：移动工具、合并图层(ctrl + e) 切片切图：切片工具 插件切图：Cutterman 其他软件：蓝湖、幕客 定位 为什么需要定位 盒子自由移动，并且压住其他盒子 盒子位置固定 定位组成 定位方式 static(默认值) relative absolute fixed sticky 边偏移 top right bottom left 相对定位：relative 相对定位是相对于盒子自己原来位置 相对定位原来位置继续占有(不脱标，保留原来位置) 绝对定位：absolute 没有父元素/父元素没有定位则相对浏览器进行移动 父元素有定位(相对/决定/固定)则相对最近一级有定位的父元素进行移动 绝对定位脱标，不占有原来位置 子绝父相 子级使用绝对定位，父亲需要相对定位\n子级绝对定位，不会占有位置，可以放在任何地方 父级相对定位，约束子级相对自己移动，并且相对定位占有原来位置 固定定位 固定定位是固定于浏览器可视区的位置 固定定位会脱标，可以看做是特殊的绝对定位 固定版心右侧：left: 50%; margin-left: 1/2版心宽度 粘性定位 position: sticky 必须设置top/right/bottom/left中的一个 不脱标 定位的叠放顺序 z-index，值越大，越在上面\n绝对定位的盒子水平/垂直居中 left: 50%; margin-left: -1/2自己宽度 top: 50%; margin-top: -1/2自己宽度 定位特性 加了绝对/固定定位/浮动的盒子会变成行内块元素 加了绝对/固定定位/浮动的元素默认宽度是内容宽度 绝对/固定定位/浮动的盒子不会发生外边距合并 绝对/固定定位会压住标准流所有(盒子+文字)，浮动不会压住文字 元素的显示与隐藏 display 通过display控制隐藏的元素不会占有原来位置，有以下几个主要可选的值：\nnone(隐藏元素) block(显示元素/更改为块元素) visibility 通过visibility控制隐藏的元素还会占有原来位置，有以下几个可选的值：\ninherit(继承，默认值) visible(可见的) hidden(隐藏) collapse(隐藏表格) overflow overflow主要控制溢出部分的显示策略，有以下几个可选的值：\nhidden(隐藏) visible(可见的，默认值) auto(有溢出，才展示滚轮。textarea元素的默认值) scroll(总是展示滚轮) ","date":"2024-04-04T19:32:48+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/","title":"【前端】网页布局"},{"content":"盒子模型组成 盒子模型有以下四个成员：\ncontent(内容) padding(内边距) border(边框) margin(外边距) 盒子模型 border 边框会影响盒子实际大小\n边框属性 border-width：宽度 border-style：样式 solid(实线) dashed(虚线) dotted(点线) border-color：颜色 边框简写： border: border-widtgh border-style border-color，没有顺序要求\n边框分开写法 border-top border-bottom border-left border-right 合并相邻边框：border-collapse: collapse\n盒子模型 padding padding会影响盒子实际大小\n内边距属性 padding-left padding-top padding-right padding-bottom 内边距简写 值的个数 效果 padding: 5px; 1 个值，代表上下左右 padding: 5px 10px; 2 个值，上下 5px，左右 10px padding: 5px 10px 20px; 3 个值，上边距 5px，左右边距 10px，下边距 20px padding: 5px 10px 15px 20px; 4 个值，上边距 5px，右边距 10px，下边距 15px，左边距 20px padding 不会影响盒子的情况 不设置width/height的情况下，不会影响盒子没有设置的属性。\n盒子模型 margin 外边距属性 margin-top margin-right margin-bottom margin-left 外边距简写 值的个数 效果 margin: 5px; 1 个值，代表上下左右 margin: 5px 10px; 2 个值，上下 5px，左右 10px margin: 5px 10px 20px; 3 个值，上边距 5px，左右边距 10px，下边距 20px margin: 5px 10px 15px 20px; 4 个值，上边距 5px，右边距 10px，下边距 15px，左边距 20px 外边距应用场景 块元素水平居中：margin: 0 auto;\n行内元素/行内块元素水平居中，给其父亲添加：text-align: center;\n外边距注意点 相邻垂直外边距合并：只给一个元素添加外边距 嵌套垂直外边距塌陷： 给父元素添加上边框 给父元素添加上内边距 给父元素添加overflow: hidden; 内外边距注意事项 清除内外边距 清除网页元素自带的内外边距\n1 2 3 4 * { margin: 0; padding: 0; } 开发建议 行内元素一般只设置左右内外边距 块元素之间使用外边距 块元素内部使用内边距 取消列表原点：lisr-style: none; 圆角边框 圆角边框的作用是可以把盒子变成圆形\n语法格式 border-radius: length; length既可以是单位/px，也可以是百分比. 可以设置4个值，从左上角开始顺时针变化 length越大，弧度越大 盒子阴影 使用box-shadow属性为盒子添加阴影\n语法格式 box-shadow: h-shadow v-shadow blur spread color inset;\n属性值 值 描述 h-shadow 必需。水平阴影。允许负值 v-shadow 必需。垂直阴影。允许负值 blur 可选。模糊距离 spread 可选。阴影尺寸 color 可选。阴影颜色 inset 可选。将外部阴影(outset)改为内部阴影 注意事项 阴影默认 outset，但是不可以书写，否则失效 阴影不占位置，不影响其他元素布局 文字阴影 text-shadow: h-shadow v-shadow blur color;\n相关属性的意义与盒子阴影一样\n","date":"2024-04-03T21:32:09+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","title":"【前端】CSS盒子模型"},{"content":"Emmet 语法 Emmet语法用于快速编写html标签与css样式\n快速生成 html 结构 生成网页骨架：html: 5 生成标签：输入标签名，按下tab键 生成多个相同标签：输入标签名*number，按下tab键 生成父子关系标签：输入标签名\u0026gt;标签名，按下tab键 生成兄弟关系标签：输入标签名+标签名，按下tab键 生成带类名的：输入标签名#classname或者标签名.classname，按下tab键 类名自增 快速生成 css 样式 通过单词缩写快速生成 css 样式属性值\nCSS 复合选择器 复合选择器可以更准确、高效定位元素\n通过两个或者多个``基础选择器组成\n复合选择器主要有以下几种：\n后代选择器 子选择器 并集选择器 伪类选择器 后代选择器 后代选择器选择的是父元素里的后代元素\n格式：标签1 标签2 ... 标签n { 样式声明 }\n既可以选择孩子，也可以选择孙子。\n选择器可以是任意基础选择器的组合\n.nav ol li\n子选择器 子选择器选择的是父元素里的子元素\n格式：父元素\u0026gt;子元素 { 样式声明 }\n并集选择器 并集选择器可以选择多组标签，为他们设定相同的样式\n格式：元素1, 元素2, ... 元素n { 样式声明 }\n伪类选择器 伪类选择器可以给某些选择器添加特殊效果(链接)，或者用于选择第1个或者第n个元素\n链接伪类选择器 hover 伪类选择器种类：\na:link(未访问) a:visited(已访问) a:hover(鼠标经过) a:active(鼠标点击但未抬起) 注意事项：\n必须按照lvha顺序编写链接伪类选择器\nfocus 伪类选择器 focus伪类选择器用于选择获得焦点的表单元素\n格式：input:focus { 样式声明 }\nCSS 元素显示模式 块元素 常见的块元素有：h1-h6、p、div、ul、ol、li 等\n块元素`独占一行`` 可以对块元素的宽、高、内外间距进行设置 默认宽度为父元素的宽度 块元素内部可以放其他行内元素/块元素 文本块元素(p、h1-h6)内部不能放置块元素 行内元素 常见的行内元素有：a、文本格式化标签、span\n多个行内元素一行展示 不可以直接对行内元素进行宽、高设置 行内元素默认宽度为内容的宽度 行内元素内部可以放文本或其他行内元素 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;标签内部不能放置\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; 特殊情况\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;内部可以放块元素 行内块元素 常见的行内块元素有：img、input、td，同时具有行内元素和块元素的特点：\n多个一行展示 可以设置宽和高 默认宽度为内容宽度 显示模式转换 增加\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;链接触发范围\ndisplay: bolck; display: inline; display: inline-block; CSS 背景 CSS背景用于设置背景颜色、图片、平铺、图片位置、图片固定\n背景颜色 通过background-color设置\ntransparent(默认值) 和文本color一样 背景图片 通过background-image设置，小图片一般通过背景图片设置\n既可以设置背景图片，也可以设置背景颜色，背景图片会压住背景颜色\nnone url() 背景平铺 背景平铺就是背景图片重复展示，通过background-repeat设置\nno-repeat repeat(默认值) repeat-x repeat-y 背景位置 background-position: x y;属性可以改变背景图片的位置\n方位名词：background-position: left top;，可以省略一个参数，第二个参数居中 精准单位：background-position: x y; 混合单位：严格顺序，第一个为x，第二个为y 背景固定 background-attchment用于设置背景图片是随着页面滚动，还是随着页面固定\nscroll(默认值) fixed 背景复合写法 background: 背景颜色 背景图片 背景平铺 背景图片滚动 背景图片位置;\n背景颜色半透明 rgba(0, 0, 0, 0.3)，a 的取值范围为 0-1，越小越淡.\nCSS 三大特性 层叠性 继承性 优先级 层叠性 为了解决样式冲突，就近原则\n继承性 子标签继承父标签的某些样式：文本颜色和字号/(text-、font-、line-、color)\nline-height可以不设置单位，最终显示当前元素``文字大小的倍数：font: 12px/1.5 'Microsoft YaHei'\n优先级 当给同一个元素指定多个选择器名，就会有优先级产生\n选择器相同：执行层叠行 选择器不同：执行优先级 选择器 选择器权重 继承或者* 0,0,0,0 标签选择器 0,0,0,1 类选择器、伪类选择器、属性选择器 0,0,1,0 id 选择器 0,1,0,0 行内样式 1,0,0,0 !important +∞ 注意事项：\n权重计算有四位，但是不会进位 从左至右判断 权重叠加 如果是复合选择器，则会有权重叠加问题\n","date":"2024-04-02T18:04:46+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss%E4%B8%8B/","title":"【前端】CSS下"},{"content":"CSS 简介 HTML 局限性 用html修改网页外观代价太大\nCSS 的作用 CSS(Cascading style sheets)用于进行网页布局\n用于改变文字、图片、网页布局、外观\nCSS 语法规范 构成 选择器 + 一个或者多个声明：属性: 值;\n书写位置 内部样式表：\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;标签中，用\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt;标签声明 行内样式表：标签内部style属性，style=\u0026quot;key: value; key: value\u0026quot; 外部样式表(推荐)：\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;文件路径\u0026quot;\u0026gt; 规范 一般采用分散式：一行设置一个属性值 选择器与括号、属性 key/value 之间需要一个空格 CSS 书写顺序： 布局定位属性(display/position/float/clear/visibility/overflow) 自身属性(width/height/margin/padding/border/background) 文本属性(color/font/text-decoration/text-align/vertical-align) 其他属性(CSS3)：content/cursor/border-radius/box-shadow/text-shadow CSS 选择器 选择器的作用 选出需求的标签\n选择器分类 基础选择器 标签选择器 id 选择器 class 选择器 通配符选择器 复合选择器 选择器使用方式 基础选择器 作用 特点 使用情况 用法 标签选择器 选出所有相同标签 不能差异化选择 较多 p {color: red;} 类选择器 选出一个或多个标签 可以根据需求选择 非常多 .nav {color: red;} id 选择器 一次只能选择一个标签 id 具有唯一性 一般和 js 搭配使用 #red {color: red;} 通配符选择器 选择所有标签 一般用于设置盒子间距 特殊情况使用 * {color: red;} class 多类名 一个标签可以使用多个类选择器定义的css 样式，多个类名之间使用空格分隔\n\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot; class=\u0026quot;red green\u0026quot;\u0026gt;百度一下，你就知道\u0026lt;/a\u0026gt;\n字体属性 CSS 字体属性用于定义字体系列、大小、粗细、文字样式\nfont-family font-family用于给字体设置系列\n多种字体之间使用逗号分隔，从左至右依次匹配\n有空格分开的多个单词组成的字体，使用单引号包裹\nfont-size/line-height font-size用于设置字体大小，必须使用单位px\nline-height用于设置行高\n文字垂直居中的技巧：line-height等于元素高度\n可以给\u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签设置整个 html 文档的字体大小\n标题标签应使用额外样式设置字体大小\nfont-weight font-weight用于给字体设置粗细，值可以设置以下几种：\nnormal(默认，400) bold(粗体，700) bolder(特粗体) lighter(细体) number(100-900)，不能跟单位 font-style font-style用于设置字体样式，有以下属性值：\nnormal italic(斜体) 复合属性 复合属性通过font属性设置\nfont: font-style font-weight font-size/line-height font-family\n必须严格按照顺序书写\nfont-size与font-family必须设置，其他可以省略\n文本属性 color color属性用于设置标签内字体颜色\n颜色有三种表示方式\n英语单词(red、green 等) #16 进制表示(用的最多) rgb 表示 text-align text-align用于设置文本对齐方式，有以下三种值：\ncenter left(默认值) right text-decoration text-decoration用于设置文本装饰，有以下四种值：\nnone underline overline line-through text-indent text-indent用于设置文本缩进，单位是 px/em，1em 等于一个文字大小\np {text-indent: 2em;}\n注意，只缩进首行\nline-height line-height用于设置文字行间距离\nline-height = font-size + 上间距 + 下间距，上下间距相等\n","date":"2024-04-01T18:40:44+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFcss/","title":"【前端】CSS"},{"content":"表格标签 表格的作用 表格标签用于展示数据\n\u0026lt;table\u0026gt;\u0026lt;/table\u0026gt;标签定义一个表格\n\u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;标签表示一行(table row)\n\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;标签表示一个单元格(table data)\n\u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;标签表示表头单元格(table header)，内容会加粗居中展示\n表格属性 align：对齐方式 border：边框 cellpadding：边缘与内容之间的距离(默认 1 像素) cellspacing：单元格之间的距离(默认 2 像素) width：表格宽度 表格标签结构 \u0026lt;table\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;thead\u0026gt;\u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt;\u0026lt;/tbody\u0026gt; 合并单元格 合并单元格方式：\n跨行合并：rowspan=\u0026ldquo;个数\u0026rdquo; 跨列合并：colspan=\u0026ldquo;个数\u0026rdquo; 列表标签 列表的作用 列表标签用于布局\n列表分类 无序列表：\u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 有序列表：\u0026lt;ol\u0026gt;\u0026lt;/ol\u0026gt;、\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 自定义列表：\u0026lt;dl\u0026gt;\u0026lt;/dl\u0026gt;、\u0026lt;dt\u0026gt;\u0026lt;/dt\u0026gt;、\u0026lt;dd\u0026gt;\u0026lt;/dd\u0026gt; 自定义列表用于对名词或者专业术语进行解释\n表单标签 表单的作用 表单标签用于收集用户信息\n表单组成 表单域：\u0026lt;form\u0026gt;\u0026lt;/form\u0026gt; 表单控件：表单元素 提示信息： 表单域属性 action：提交地址 method：提交方式(get/post) name: 表单域名称 input 表单元素 input 元素作用 input 元素用于收集用户信息\ninput 标签属性 type： button：按钮 cehckbox：复选框 file：文件选择 hidden：隐藏 image：图片 password：密码 text：文本 radio：单选框 reset 重置按钮 submit：提交按钮 name：name是表单的名字，单选框必须有相同的名字才可以实现多选一 value：表单的默认值，使用placeholder更好 checked：规定 input 元素首次加载时自动被选中 maxlength：输入字段中字符最大长度 label 标签 label 标签用于 input 聚焦\n通过label标签的for属性与input标签的id属性\n\u0026lt;lable for=\u0026quot;sex\u0026quot;\u0026gt;男\u0026lt;/lable\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; id=\u0026quot;sex\u0026quot;/\u0026gt;\nselect 下拉表单元素 下拉表单元素的作用 如果有多个选项提供用户选择，节约空间\n标签 1 2 3 4 5 \u0026lt;select\u0026gt; \u0026lt;option\u0026gt;选项1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选项2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;选项3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 属性 option标签有一个selected=\u0026quot;selected\u0026quot;属性，表示默认选中\ntextarea 文本域元素 textarea 使用场景 当用户要输入的内容比较多时，不应使用text类型的input标签，而是应该使用textarea标签\n","date":"2024-04-01T14:36:49+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml%E6%A0%87%E7%AD%BE%E4%B8%8B/","title":"【前端】HTML标签下"},{"content":"浏览器内核 浏览器内核就是浏览器的渲染引擎，目前引擎分类：\n浏览器 内核 IE Trident firefox Gecko safari Webkit chrome/opera Blink Web 标准 W3C 主要包括：结构(HTML)、表现(CSS)、行为(JAVASCRIPT)三个部分。\nWEB 标准提出的最佳解决方案：结构、样式、行为相分离。\nHtml 语法规范 标签一般成对出现，也有单标签 标签之间的关系：包含/并列 Html 基本结构标签 \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt;标签 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;标签 \u0026lt;meta\u0026gt;标签 \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;标签 \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;标签 html 常用标签 标题标签 h1-h6 分别代表不同级别标题\n段落标签 \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;标签表示一个段落\n换行标签 \u0026lt;br/\u0026gt;标签表示换行\n空格 \u0026amp;nbsp;表示空格\n文本格式化标签 粗体：\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;或者\u0026lt;strong\u0026gt;\u0026lt;/strong\u0026gt; 倾斜：\u0026lt;em\u0026gt;\u0026lt;/em\u0026gt;或者\u0026lt;i\u0026gt;\u0026lt;/i\u0026gt; 删除线：\u0026lt;del\u0026gt;\u0026lt;/del\u0026gt;或者\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt; 下划线：\u0026lt;ins\u0026gt;\u0026lt;/ins\u0026gt;或者\u0026lt;u\u0026gt;\u0026lt;/u\u0026gt; 盒子标签 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;标签，独占一行 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;标签，多个在同一行展示 图像标签 \u0026lt;img/\u0026gt;标签表示一张图片，是一个单标签\n图像标签的属性：\nsrc：图片路径 title：图片标题，提示文本 alt：替换文本(图片展示不了时的文本) width：图片宽度 height：图片高度 border：图片边框 超链接标签 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;标签表示一个超链接\n超链接标签的属性：\nhref：链接的地址 target：以何种方式打开：_self(默认)、_blank 超链接的种类：\n外部链接：跳转到外部网站 内部链接：跳转到内部 html 页面 空链接：href=\u0026quot;#\u0026quot; 下载链接：地址链接的是文件 网页元素链接：为网页元素添加超链接：文本、图片、表格、音频、视频 锚点链接：href=\u0026quot;#id\u0026quot; 注释标签与特殊字符 \u0026lt;!-- 注释 --\u0026gt;进行注释\n特殊字符：\n空格：\u0026amp;nbsp; 大于：\u0026amp;gt; 小于：\u0026amp;lt; ","date":"2024-04-01T10:04:06+08:00","permalink":"https://www.cengdong.store/p/%E5%89%8D%E7%AB%AFhtml%E6%A0%87%E7%AD%BE/","title":"【前端】HTML标签"},{"content":"通过 docker 安装 gitlab 安装 gitlab，你起码需要一台 2c4g 的服务器，gitlab 依赖很多很重的组件，我的环境是一台 2c4g 的虚拟机\n挂载三个目录：/etc/gitlab、/var/log/gitlab、/var/opt/gitlab\n映射三个端口：443/https、80/http、22/ssh\n443 端口如果不用到证书不需要挂载\n1 2 3 4 5 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab \\ --restart always -v ~/data/gitlab/config:/etc/gitlab \\ -v ~/data/gitlab/logs:/var/log/gitlab \\ -v ~/data/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce 等待几分钟之后，通过网站访问 gitlab，用户名为 admin，密码挂载在/Users/cengdong/data/gitlab/config目录下\n修改 gitlab 配置 编辑挂载的配置目录：/Users/cengdong/data/gitlab/config/gitlab.rb\ngitlab 的配置项非常多，只修改一项就能满足基本需求：external_url 'http://192.168.184.9'\n重启容器docker restart gitlab或者进入容器通过gitlab-ctl reconfigure命令使配置生效\n通过 docker 安装 gitlab-runner gitlab-runner 不建议与 gitlab 安装在同一台服务器上\n挂载容器运行时以及配置文件 1 2 3 4 docker run -d --name gitlab-runner --restart always \\ -v ~/data/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner 非交互式注册 runner 有三种类型的 runner：shared、group、specific\n全局类型 runner 所有人都能用，组类型 runner 只有组内人能用，特殊 runner 只有当前项目能用\n在不同地方的 settings-\u0026gt;cicd 中可以查看不同的 token\nrunner 有很多类型的执行器，常用的有shell、docker、k8s，通过--execuotr参数指定\n1 2 3 4 5 6 7 8 9 10 docker run --rm -v ~/data/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \\ --non-interactive\\ --executor \u0026#34;docker\u0026#34; \\ --docker-image alpine\u0026#34;latest \\ --url \u0026#34;http://192.168.184.9\u0026#34; \\ --registeration-token \u0026#34;your token\u0026#34; \\ --description \u0026#34;test \\ --tag-list \u0026#34;build\u0026#34; \\ --run-untagged=\u0026#34;true\u0026#34; \\ --locked=\u0026#34;false\u0026#34; 修改 gitlab-runner 配置 修改～/data/gitlab-runner/config/config.toml文件concurrent = 10\nconcurrent控制一个 stage 能最多同时执行多少个 job，默认为 1 的情况下如果一个 stage 有多个 job 无法并发执行\n在[runners.docker]项下面添加pull_policy = if-not-present，否则每次都需要拉取镜像\n运行流水线 现在，你可以愉快的运行流水线了。通过创建或者导入项目，在项目的根目录下创建.gitlab-ci.yml文件\n通过 pipeline 语法控制流水线的流程\n","date":"2024-03-28T04:20:36+08:00","permalink":"https://www.cengdong.store/p/devopsgitlabci%E5%AE%9E%E8%B7%B5/","title":"【Devops】GitLabCI实践"},{"content":"1. 听力短句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 August is coming to an end. 八月就要结束了。 How old is this temple? 这座寺庙有多古老？ Please don\u0026#39;t call me after ten 请不要在十点以后给我打电话！ You are going to wait for a little bit. 你要稍微等一下。 The boy didn\u0026#39;t change his mind. 男孩没有改变他的想法。 I\u0026#39;m sorry, but I can\u0026#39;t accept such an expensive gift. 对不起，我不能接受这么贵重的礼物。 On Thursday we went to the poor. 周四，我们去了游泳池。 Monday Tuesday Wednesday Thursday Friday Saturday Sunday I\u0026#39;m talking to a friend. 我正在和朋友谈话。 Your plan is good, but my is better. 你的计划不错，但我的更好。 I fell into a trap. 我掉进了一个陷阱。 trap：陷阱 Cut the cake with this knife. 用这把刀切蛋糕。 knife：刀 It may sound strange, but it is true. 这听起来很奇怪，但他是真的。 He doesn\u0026#39;t know anything yet. 他还什么都不知道。 He is thinking about something else. 他在思考其他的事情。 The room is clean and comfortable. 房间整洁又舒适。 We\u0026#39;ll make our announcement on Thursday. 我们将在周四宣布。 announcement：宣布，声明 Have you chosen a name for the baby？ 你为孩子起好名字了吗？ chosen/choice：选择 Have you forgotten about your promise? 你忘记你的承诺了吗？promise：承诺 propose：求婚 Tom was blindfolded and taken out of the house. 汤姆被蒙上眼睛，带出了房子。 blind：失明 blindfold：被遮住 A short walk will bring you to the station. 走一小段路你就能到达车站。 2. 学到的知识点 生词： temple：寺庙 trap：陷阱 announcement: 宣布、声明 blindfold：被遮住 短语： fell into: 掉进 fell into love with：爱上某人 wait for a little bit：等一会儿 ","date":"2023-09-30T22:44:05+08:00","permalink":"https://www.cengdong.store/p/english%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0day1/","title":"【English】英语学习Day1"},{"content":"1. go-zero 分布式锁实现 看下 go-zero 中 redis 分布式锁的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 var ( lockScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;PX\u0026#34;, ARGV[2]) return \u0026#34;OK\u0026#34; else return redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;NX\u0026#34;, \u0026#34;PX\u0026#34;, ARGV[2]) end`) delScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) else return 0 end`) ) 加锁和解锁的过程都是通过 lua 脚本实现的，因为 lua 脚本能够保证 redis 的原子性。\n2. 分布式锁必须拥有的属性 排他性(只能有一个协程持有) 可重入(已经获取锁的协程能再次访问) 防死锁(必须有超时时间，达到后持有者自动释放) 高性能高可用 3. go-zero 分布式锁加锁流程 1 2 3 4 5 6 7 8 # 判断ARGV[1]是否等于KEY[1]的值 # 如果相等，说明是该锁的持有者重入，更新锁的过期时间，返回OK # 如果不想等，说明锁不存在或者该用户不是锁的持有者，用set nx px命令操作该key lockScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;PX\u0026#34;, ARGV[2]) return \u0026#34;OK\u0026#34; else return redis.call(\u0026#34;SET\u0026#34;, KEYS[1], ARGV[1], \u0026#34;NX\u0026#34;, \u0026#34;PX\u0026#34;, ARGV[2]) 4. go-zero 分布式锁解锁流程 1 2 3 4 5 6 7 # 判断ARGV[1]是否等于KEY[1]的值 # 如果相等，说明是锁的拥有者，删除分布式锁的KEY # 如果不想等，说明不是锁的拥有者，返回0 delScript = NewScript(`if redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) else return 0 ","date":"2023-09-28T09:30:39+08:00","permalink":"https://www.cengdong.store/p/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","title":"【分布式锁】利用Redis实现分布式锁"},{"content":"1. 起因 最近在学习go-zero，用go-zero自带的sqlx+sqlc操作数据库。因为sqlx+sqlc不会像gorm一样自动管理软删除字段，所以对表结构进行重新的设计。 下面是新的表结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT \u0026#39;用户id\u0026#39;, `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT \u0026#39;用户名\u0026#39;, `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT \u0026#39;密码\u0026#39;, `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, `delete_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;删除时间\u0026#39;, `is_delete` tinyint unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;是否被删除\u0026#39;, `version` bigint unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;版本号\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `idx_username` (`username`,`is_delete`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=\u0026#39;用户记录\u0026#39;; 业务上需要username上这个唯一索引，同时当业务需要删除数据时只能软删除，方便数据溯源与恢复。\n2. 遇到的问题 当时只考虑到业务语义上username需要唯一索引，写完代码后用 postman 进行测试，插入一条数据，再删除这条数据。再插入一条相同用户名的数据时， 接口报错唯一索引冲突。参考go-zero微信群的建议，给软删除字段is_delete也加上唯一索引。插入一条数据，再删除这条数据。再插入一条相同用户名的数据， 再删除这条数据时，接口还是报错唯一索引冲突。\n3. 再加索引 群里立马又有大佬说还需要给删除时间加上唯一索引，因为删除时业务上会把删除时间更新为当前时间，不会有冲突。一顿操作下来，就给三个字段加上了唯一索引。 个人感觉这个索引还是有点大，又去网上找了不少相关博客。首先确定的是：\n有唯一索引需要的字段必须加上唯一索引，不能因为业务上有校验就删除该索引。 同时删除数据时应该使用软删除。 但是有一点可以优化，就是标记软删除的字段不必只是 0 和 1，当删除数据时，更新该字段为该记录的主键值。 4. 又遇到问题 因为go-zero的数据库操作代码是靠代码生成的，会根据索引字段自动生成方法名，当有唯一索引需求是，自动生成的方法名会带上索引的所有字段，包括 软删除字段，方法名格外尴尬不说，内部生成的代码还多判断了一次is_delete = 0，请教了 looklook 项目作者，这种需要 fork go-zero源代码再自己进行魔改。\n","date":"2023-09-28T08:37:51+08:00","permalink":"https://www.cengdong.store/p/mysql%E8%A7%A3%E5%86%B3%E8%BD%AF%E5%88%A0%E9%99%A4%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/","title":"【MySQL】解决软删除中的唯一索引问题"},{"content":"1. 需求 需要把 mysql 的数据聚合同步到 es 以提供海量数据检索能力\n2. 解决方案 变更 mysql 数据时同步调用 es 的 api 变更 mysql 数据时异步调用 es 的 api(先发送消息到消息队列，搜索微服务调用 es 的 api 消费数据) canal 监听 mysql 的 binlog 日志，再同步到 es flink-cdc 监听 mysql 的 binlog 日志同步到 es 3. 选用方案 最终选择 flink-cdc 的方案，一是 go-canal 的仓库不活跃，就三个 issue，提了 bug 也没人修，而且后续可能有实时分析的大数据需求，本身就有 flink 集群的需求。 二是 canal 的 release 版本要最近才会更新，最后一次更新是 21 年 4 月，害怕烂尾。三是俺尝试部署 canal，最后失败了 💦。\n4. 部署环境 选用 docker-compose 部署 mysql、link 与 elasticsearch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 version: \u0026#39;3\u0026#39; services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.17.13 container_name: elasticsearch user: root environment: - discovery.type=single-node - \u0026#39;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#39; - TZ=Asia/Shanghai volumes: - ./data/elasticsearch/data:/usr/share/elasticsearch/data restart: always ports: - \u0026#39;9200:9200\u0026#39; - \u0026#39;9300:9300\u0026#39; networks: - douyin_net kibana: image: docker.elastic.co/kibana/kibana:7.17.13 container_name: kibana environment: - elasticsearch.hosts=http://elasticsearch:9200 - TZ=Asia/Shanghai restart: always networks: - douyin_net ports: - \u0026#39;5601:5601\u0026#39; depends_on: - elasticsearch mysql: image: mysql:latest container_name: mysql environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: my-secret-pw ports: - \u0026#39;3306:3306\u0026#39; volumes: # 数据挂载 - Data mounting - ./data/mysql/data:/var/lib/mysql - ./data/mysql/my.cnf:/etc/my.cnf privileged: true restart: always networks: - douyin_net jobmanager: image: flink:latest container_name: jobmanager expose: - \u0026#39;6123\u0026#39; ports: - \u0026#39;8081:8081\u0026#39; command: jobmanager environment: - TZ=Asia/Shanghai - JOB_MANAGER_RPC_ADDRESS=jobmanager restart: always networks: - douyin_net taskmanager: image: flink:latest container_name: taskmanager expose: - \u0026#39;6121\u0026#39; - \u0026#39;6122\u0026#39; depends_on: - jobmanager command: taskmanager environment: - JOB_MANAGER_RPC_ADDRESS=jobmanager - TZ=Asia/Shanghai restart: always networks: - douyin_net networks: douyin_net: driver: bridge ipam: config: - subnet: 172.16.0.0/16 其中 mysql 挂载的配置文件内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [mysqld] skip-host-cache skip-name-resolve datadir=/var/lib/mysql socket=/var/run/mysqld/mysqld.sock secure-file-priv=/var/lib/mysql-files user=mysql log-bin=mysql-bin binlog-format=ROW server_id=66 pid-file=/var/run/mysqld/mysqld.pid [client] socket=/var/run/mysqld/mysqld.sock !includedir /etc/mysql/conf.d/ 主要是为了开启 binlog\n5. 配置 先启动集群\n1 docker-compose up -d 检查 binlog 是否开启\n1 2 3 docker exec mysql -uroot -pmy-secret-pw show variables like \u0026#39;log_bin\u0026#39;; show variables like \u0026#39;binlog_format\u0026#39;; 下载 mysql、es 的 connector 并拷贝到容器内部\nflink-sql-connector-elasticsearch7-3.0.1-1.17.jar flink-sql-connector-mysql-cdc-2.4.1.jar 1 2 3 docker cp ./flink-sql-connector-elasticsearch7-3.0.1-1.17.jar jobmanager:/opt/flink/lib/ docker cp ./flink-sql-connector-mysql-cdc-2.4.1.jar jobmanager:/opt/flink/lib/ docker restart jobmanager 6. 测试 进入 mysql 容器/连接 mysql 创建 mysql 数据库表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE DATABASE mydb; USE mydb; CREATE TABLE orders ( order_id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, order_date DATETIME NOT NULL, customer_name VARCHAR(255) NOT NULL, price DECIMAL(10, 5) NOT NULL, product_id INTEGER NOT NULL, order_status BOOLEAN NOT NULL -- Whether order has been placed ) AUTO_INCREMENT = 10001; INSERT INTO orders VALUES (default, \u0026#39;2020-07-30 10:08:22\u0026#39;, \u0026#39;Jark\u0026#39;, 50.50, 102, false), (default, \u0026#39;2020-07-30 10:11:09\u0026#39;, \u0026#39;Sally\u0026#39;, 15.00, 105, false), (default, \u0026#39;2020-07-30 12:00:30\u0026#39;, \u0026#39;Edward\u0026#39;, 25.25, 106, false); 进入 jobmanager 容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 docker exec -it jobmanager /bin/bash cd bin \u0026amp;\u0026amp; ./sql-client.sh SET execution.checkpointing.interval = 3s; CREATE TABLE orders ( order_id INT, order_date TIMESTAMP(0), customer_name STRING, price DECIMAL(10, 5), product_id INT, order_status BOOLEAN, PRIMARY KEY (order_id) NOT ENFORCED ) WITH ( \u0026#39;connector\u0026#39; = \u0026#39;mysql-cdc\u0026#39;, \u0026#39;hostname\u0026#39; = \u0026#39;192.168.2.248\u0026#39;, \u0026#39;port\u0026#39; = \u0026#39;3306\u0026#39;, \u0026#39;username\u0026#39; = \u0026#39;root\u0026#39;, \u0026#39;password\u0026#39; = \u0026#39;my-secret-pw\u0026#39;, \u0026#39;database-name\u0026#39; = \u0026#39;mydb\u0026#39;, \u0026#39;table-name\u0026#39; = \u0026#39;orders\u0026#39; ); CREATE TABLE es_orders ( order_id INT, order_date TIMESTAMP(0), customer_name STRING, price DECIMAL(10, 5), product_id INT, order_status BOOLEAN, PRIMARY KEY (order_id) NOT ENFORCED ) WITH ( \u0026#39;connector\u0026#39; = \u0026#39;elasticsearch-7\u0026#39;, \u0026#39;hosts\u0026#39; = \u0026#39;http://192.168.2.248:9200\u0026#39;, \u0026#39;index\u0026#39; = \u0026#39;orders\u0026#39; ); INSERT INTO es_orders SELECT * FROM orders; 访问 kibana 查询 es 数据\n1 2 3 4 5 6 GET orders/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match_all\u0026#34;: {} } } ","date":"2023-09-20T22:34:29+08:00","permalink":"https://www.cengdong.store/p/flink%E5%88%A9%E7%94%A8flink-cdc%E5%90%8C%E6%AD%A5mysql%E6%95%B0%E6%8D%AE%E5%88%B0es/","title":"【Flink】利用flink Cdc同步mysql数据到es"},{"content":"1. 遇到的问题：上传文件到阿里云 Oss 失败，通过日志定位到是 Linux 系统时间不正确 2. 解决方案 1 2 3 4 5 timedatectl set-timezone Asia/Shanghai sudo yum -y install ntp ntpdate pool.ntp.org systemctl start ntpd systemctl enable ntpd ","date":"2023-09-15T02:58:36+08:00","permalink":"https://www.cengdong.store/p/linuxcentos7%E8%A7%A3%E5%86%B3%E6%97%B6%E9%97%B4%E4%B8%8D%E6%AD%A3%E7%A1%AE%E9%97%AE%E9%A2%98/","title":"【Linux】Centos7解决时间不正确问题"},{"content":"1. 环境准备 M1 Mac Vmware Fusion Tech Preview 终端连接工具 Termius Centos7 虚拟机三台，内存都为 4G，磁盘 30G，线程数为 4 master: 192.168.2.3 node-1: 192.168.2.4 node-2: 192.168.2.5 2. 修改主机名 在三台节点上都执行\n1 2 3 4 5 cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF 192.168.2.3 master 192.168.2.4 node-1 192.168.2.5 node-2 EOF 1 2 3 4 5 6 # master上执行 hostnamectl set-hostname master # node-1上执行 hostnamectl set-hostname node-1 # node-2上执行 hostnamectl set-hostname node-2 3. 关闭 selinux、swap 1 2 3 4 5 6 swapoff -a sed -i \u0026#39;s/enforcing/disabled/\u0026#39; /etc/selinux/config setenforce 0 echo \u0026#34;net.bridge.bridge-nf-call-iptables = 1 \u0026#34;\u0026gt;\u0026gt;/etc/sysctl.d/k8s.conf echo \u0026#34;net.bridge.bridge-nf-call-ip6tables = 1 \u0026#34;\u0026gt;\u0026gt;/etc/sysctl.d/k8s.conf sysctl --system 4. ipvs 安装 1 2 3 4 modprobe br_netfilter echo 1 \u0026gt; /proc/sys/net/bridge/bridge-nf-call-iptables echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward lsmod | grep br_netfilter 1 yum -y install ipset ipvsadm 1 2 3 4 5 6 7 cat \u0026gt; /etc/sysconfig/modules/ipvs.modules \u0026lt;\u0026lt;EOF modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack EOF 1 chmod a+x /etc/sysconfig/modules/ipvs.modules 执行脚本 /etc/sysconfig/modules/ipvs.modules\n验证 ipvs 模块 lsmod | grep -e ip_vs -e nf_conntrack_ipv4\n1 2 3 4 5 # 执行脚本 /etc/sysconfig/modules/ipvs.modules # 验证ipvs模块 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 1 2 3 4 cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/modules-load.d/containerd.conf overlay br_netfilter EOF 1 2 modprobe overlay modprobe br_netfilter 5. 安装 docker 1 2 3 4 5 6 7 yum install -y yum-utils yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo yum install docker-ce-19.03.5 docker-ce-cli-19.03.5 systemctl enable docker systemctl start docker 配置 docker\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/docker/daemon.json { \u0026#34;insecure-registries\u0026#34;:[\u0026#34;47.99.140.12:8077\u0026#34;], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://l10nt4hq.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; ] } EOF #重新加载服务的配置文件 systemctl daemon-reload #重启docker systemctl restart docker systemctl status docker.service 6. 配置 k8s 源 1 2 3 4 5 6 7 8 9 10 11 12 13 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-aarch64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF yum clean all yum makecache 7. 安装 kubeadm、kubectl、kubelet 1 2 3 4 5 yum install -y kubeadm-1.23.3-0 kubectl-1.23.3-0 kubelet-1.23.3-0 --disableexcludes=kubernetes # 只在master节点执行 systemctl enable kubelet systemctl start kubelet 8. master 节点加入 K8s 集群 1 kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.23.3 --apiserver-advertise-address 192.168.2.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.1.0.0/16 9. master 节点部署 flannel 网络 1 2 3 4 tar zxvf cni-plugins-linux-arm-v0.8.6.tgz cp flannel /opt/cni/bin chmod 777 /opt/cni/bin/flannel kubectl apply -f kube-flannel.yml 10. node 节点加入 k8s 集群 1 2 kubeadm join 192.168.2.2:6443 --token uxohvw.84c30cwr4g6t8he8 \\ --discovery-token-ca-cert-hash sha256:cc7e139e28e61db426dc91a3ecccc0a72f26b09af6dfd12c6171d58f4359c0e5 token 失效后重新生成\n1 2 3 4 5 kubeadm token create # master 执行 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u0026gt;/dev/null | openssl dgst -sha256 -hex | sed \u0026#39;s/^.* //\u0026#39; 11. node 节点加入 flannel 网络 1 2 3 4 5 6 7 8 # 子节点上创建文件夹 mkdir -p /etc/cni/net.d # master节点拷贝文件到node节点 scp /etc/cni/net.d/10-flannel.conflist root@192.168.2.3:/etc/cni/net.d systemctl daemon-reload systemctl restart kubelet ","date":"2023-08-28T19:51:03+08:00","permalink":"https://www.cengdong.store/p/kubernetesarm%E6%9E%B6%E6%9E%84centos7%E9%80%9A%E8%BF%87kubeadm%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/","title":"【Kubernetes】arm架构Centos7通过kubeadm安装k8s集群"},{"content":"1. 起因 最近在学习 go-zero 框架，把 faker-douyin 项目重构成微服务项目。在重构的过程中有一些变动：\n原来使用本地虚拟机构建服务中间件依赖，现在使用阿里云的服务 原来上传视频时直接通过 ftp 上传到虚拟机，现在直接上传到阿里云 oss 在代码上传 github 上之后，阿里云发现我的 accessKey 在 github 上泄漏（主要是我安全意识不好）\n2. 解决办法 使用.gitignore 文件使 git 忽视配置文件上传 在.gitignore 文件中添加.yaml 忽视所有 yaml 类型文件 3. 遇到问题 更改.gitignore 文件之后，本地仓库没有生效（没有删除 gitignore 文件匹配的文件）\n4. 解决办法 1 2 3 4 git rm --cached -r . git add . git commit -am \u0026#39;注释\u0026#39; git push ","date":"2023-08-12T15:00:13+08:00","permalink":"https://www.cengdong.store/p/git%E6%B7%BB%E5%8A%A0gitignore%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E5%88%A0%E9%99%A4github%E4%B8%8A%E5%A4%9A%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6/","title":"【Git】添加gitignore文件之后删除github上多上传的文件"},{"content":"1. 介绍 RabbitMQ is the most widely deployed open source message broker.\n直接把 RabbitMQ 官网的介绍抄过来：它是部署最广泛的消息代理\n2. 作用 消息代理中间件的作用：\n削峰：大量请求写入消息中间件，服务器按照自己能力去消费 解耦：服务上游与下游解耦，上游只需把请求写入消息代理，下游只需要去消息中间件消费 异步：实时性不高的功能放入代理，快速响应客户端请求 3. 竞品 ActiveMQ(已经寄了) RocketMQ（阿里开源，广泛应用在电商场景） Kafka（大数据利器，日志系统重要组件） 4. 系统架构 生产者：消息发送方 channel：通信信道，一个连接里有多个可用信道（感觉是资源池），生产者和消费者都会与 broker 建立连接 exchange：交换机，生产者将消息发送给对应交换机（生产者只与交换机打交道），交换机通过 routingKey 将消息发送给消息队列 queue：消息队列，存放消息的实体 消费者：从消息队列中消费消息 虚拟主机：多租户的资源隔离（不想深入，也不做过多了解） 5. 工作模式 RabbitMQ 官方给出了七种工作模式\nHello World Work Queues Publish/Subscribe Routing Topics RPC Publisher confirms 6. 安装 RabbitMQ 我的虚拟机已经安装好Docker，通过 Docker 安装带 web 可视化插件的RabbitMQ，其中 5672 是服务端的端口，15672 是 web 可视化的端口\n1 docker run --name rabbit --restart=always -p 15672:15672 -p 5672:5672 -d rabbitmq:management 访问 web 管理界面，用户名密码都是guest\n7. 创建项目 创建目录：mkdir rabbitmq-demo 初始化项目：go mod init rabbitmq-demo go 客户端选用：老规矩，最多 star 的项目，虽然已经停止维护很久了github.com/streadway/amqp 8. 发送消息：以简单模式为例 简单模式就是点对点的消息传输模型，官网称之为Hello World模式。生产者发送消息给指定队列，消费者从指定队列消费消息，其中生产者以及消费者都绑定的是默认交换机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; ) const url = \u0026#34;amqp://guest:guest@192.168.18.3:5672/\u0026#34; func main() { // 连接服务器 conn, err := amqp.Dial(url) if err != nil { fmt.Println(err) } defer conn.Close() // 获取channel channel, err := conn.Channel() defer channel.Close() if err != nil { fmt.Println(err) } // 声明队列 queue, err := channel.QueueDeclare(\u0026#34;test\u0026#34;, false, false, false, false, nil) if err != nil { fmt.Println(err) } // 发布消息 err = channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(\u0026#34;hello world\u0026#34;)}) if err != nil { fmt.Println(err) } } 9. 接受消息：以简单模式为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; ) const rabbit_url = \u0026#34;amqp://guest:guest@192.168.18.3:5672/\u0026#34; func main() { // 链接服务器 conn, err := amqp.Dial(rabbit_url) if err != nil { fmt.Println(err) } defer conn.Close() // 建立链接 channel, err := conn.Channel() if err != nil { fmt.Println(err) } defer channel.Close() // 声明队列 queue, err := channel.QueueDeclare(\u0026#34;test\u0026#34;, false, false, false, false, nil) if err != nil { fmt.Println(err) } // 消费消息 msg, err := channel.Consume(queue.Name, \u0026#34;\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } // 遍历管道，读取消息 for d := range msg { fmt.Println(string(d.Body)) } } 10. 如何保障消息不丢失 10.1 消息应答机制 RabbitMQ 有两种消息应答机制：自动应答和手动应答，自动应答即 NOACK，不需要接收方回应 ACK 消息，默认是这种应答方式。要开启手动应答，首先要把 channel.Consume 方法的第三个参数设置为 false\n1 func (ch *Channel) Consume(queue, consumer string, autoAck, exclusive, noLocal, noWait bool, args Table) (\u0026lt;-chan Delivery, error) 还需要在消费消息时调用Ack或Reject或 Nack方法\n1 func (d Delivery) Ack(multiple bool) error 10.2 消息持久化 要保障消息不丢失，就要保障消息的持久化，避免服务器故障或重启时内存中的消息丢失。消息持久化分为两部分：队列持久化、消息持久化。\n队列持久化需要在声明队列时把参数 durable 传为 true\n1 func (ch *Channel) QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args Table) (Queue, error) 消息持久化需要在实例化消息时把Publishing结构体的DeliveryMode字段设置为Persistent\n1 2 3 4 5 6 channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ DeliveryMode: amqp.Persistent, ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(\u0026#34;hello world\u0026#34;), } ) 10.3 生产方发布确认 生产方发布确认又叫发布确认模式，是一种保障生产方能确认发布消息到 Broker 的机制\n要开启发布确认模式需要调用 channel.Conform 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Confirm puts this channel into confirm mode so that the client can ensure all publishings have successfully been received by the server. After entering this mode, the server will send a basic.ack or basic.nack message with the deliver tag set to a 1 based incremental index corresponding to every publishing received after the this method returns. Add a listener to Channel.NotifyPublish to respond to the Confirmations. If Channel.NotifyPublish is not called, the Confirmations will be silently ignored. The order of acknowledgments is not bound to the order of deliveries. Ack and Nack confirmations will arrive at some point in the future. Unroutable mandatory or immediate messages are acknowledged immediately after any Channel.NotifyReturn listeners have been notified. Other messages are acknowledged when all queues that should have the message routed to them have either received acknowledgment of delivery or have enqueued the message, persisting the message if necessary. When noWait is true, the client will not wait for a response. A channel exception could occur if the server does not support this method. */ func (ch *Channel) Confirm(noWait bool) error { if err := ch.call( \u0026amp;confirmSelect{Nowait: noWait}, \u0026amp;confirmSelectOk{}, ); err != nil { return err } ch.confirmM.Lock() ch.confirming = true ch.confirmM.Unlock() return nil } 再调用NotifyPublish方法或NotifyConfirm注册发布消息的回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* NotifyConfirm calls NotifyPublish and starts a goroutine sending ordered Ack and Nack DeliveryTag to the respective channels. For strict ordering, use NotifyPublish instead. */ func (ch *Channel) NotifyConfirm(ack, nack chan uint64) (chan uint64, chan uint64) { confirms := ch.NotifyPublish(make(chan Confirmation, cap(ack)+cap(nack))) go func() { for c := range confirms { if c.Ack { ack \u0026lt;- c.DeliveryTag } else { nack \u0026lt;- c.DeliveryTag } } close(ack) if nack != ack { close(nack) } }() return ack, nack } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* NotifyPublish registers a listener for reliable publishing. Receives from this chan for every publish after Channel.Confirm will be in order starting with DeliveryTag 1. There will be one and only one Confirmation Publishing starting with the delivery tag of 1 and progressing sequentially until the total number of Publishings have been seen by the server. Acknowledgments will be received in the order of delivery from the NotifyPublish channels even if the server acknowledges them out of order. The listener chan will be closed when the Channel is closed. The capacity of the chan Confirmation must be at least as large as the number of outstanding publishings. Not having enough buffered chans will create a deadlock if you attempt to perform other operations on the Connection or Channel while confirms are in-flight. It\u0026#39;s advisable to wait for all Confirmations to arrive before calling Channel.Close() or Connection.Close(). */ func (ch *Channel) NotifyPublish(confirm chan Confirmation) chan Confirmation { ch.notifyM.Lock() defer ch.notifyM.Unlock() if ch.noNotify { close(confirm) } else { ch.confirms.Listen(confirm) } return confirm } 11. 工作队列模式 11.1 公平调度的工作队列模式 工作队列模式类似于 Kafka 的消费者组，为了提高消费者的消费能力。生产者代码与简单模式一致，为了能从命令行控制要发送的消息，做一些改造。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) const url = \u0026#34;amqp://guest:guest@47.99.140.12:5672/\u0026#34; func main() { connection, err := amqp.Dial(url) if err != nil { fmt.Println(err) } defer connection.Close() channel, err := connection.Channel() if err != nil { fmt.Println(err) } defer channel.Close() queue, err := channel.QueueDeclare(\u0026#34;work_queues\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } body := bodyFrom(os.Args) err = channel.Publish(\u0026#34;\u0026#34;, queue.Name, false, false, amqp.Publishing{ ContentType: \u0026#34;text/plain\u0026#34;, DeliveryMode: amqp.Persistent, Body: []byte(body), }) if err != nil { fmt.Println(err) } fmt.Printf(\u0026#34;send msg %s\u0026#34;, body) } func bodyFrom(args []string) string { var s string if len(args) \u0026lt; 2 || os.Args[1] == \u0026#34;\u0026#34; { s = \u0026#34;hello\u0026#34; } else { s = strings.Join(args[1:], \u0026#34; \u0026#34;) } return s } 消费者代码也与简单模式一致，为了能从多个消费者区分差异，对消息做了一些虚假的业务处理（按照消息中字符.的个数睡眠相应秒数）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/streadway/amqp\u0026#34; \u0026#34;time\u0026#34; ) const rabbit_url = \u0026#34;amqp://guest:guest@47.99.140.12:5672/\u0026#34; func main() { connection, err := amqp.Dial(rabbit_url) if err != nil { fmt.Println(err) } defer connection.Close() channel, err := connection.Channel() if err != nil { fmt.Println(err) } defer channel.Close() queue, err := channel.QueueDeclare(\u0026#34;work_queues\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } deliveries, err := channel.Consume(queue.Name, \u0026#34;\u0026#34;, true, false, false, false, nil) if err != nil { fmt.Println(err) } for delivery := range deliveries { fmt.Printf(\u0026#34;receive work: %s\\n\u0026#34;, delivery.Body) dotCount := bytes.Count(delivery.Body, []byte(\u0026#34;.\u0026#34;)) d := time.Duration(dotCount) time.Sleep(d * time.Second) fmt.Printf(\u0026#34;work done after %d\\n\u0026#34;, d) } } 先分别在两个终端中启动两个消费者\n1 go run receive.go 再启动生产者发送多条消息\n1 2 3 4 5 go run send.go First Message. go run send.go Second Message.. go run send.go Third Message... go run send.go Fourth message.... go run send.go Fifth message..... 生产者 消费者 1 消费者 2 消费者 1 消费了消息 135，消费者 2 消费了消息 24，这样提高了消费者消费的能力，并且由于工作队列模式默认的消息分发机制是轮询，官网称之为Fair dispatch(公平调度)\n当有多个消费者时，每个消费者的消费能力不一样，轮询的方式会有问题。\n11.2 设置预取值的工作队列方式 为了解决公平调度带来的问题，我们可以将预取计数设置为值1。这告诉RabbitMQ不要一次向一个worker提供多条消息。\n或者，换句话说，在worker处理并确认前一条消息之前，不要向worker发送新消息。相反，它会将其调度给下一个尚未繁忙的工作人员。\n设置预取值需要调用 channel.Qos 方法\n1 2 3 4 5 6 7 8 9 10 11 # 通常设置 prefetchCount = 1 prefetchSize = 0 global = false func (ch *Channel) Qos(prefetchCount, prefetchSize int, global bool) error { return ch.call( \u0026amp;basicQos{ PrefetchCount: uint16(prefetchCount), PrefetchSize: uint32(prefetchSize), Global: global, }, \u0026amp;basicQosOk{}, ) } ","date":"2023-07-31T00:02:07+08:00","permalink":"https://www.cengdong.store/p/gorabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"【Go】RabbitMQ学习笔记"}]